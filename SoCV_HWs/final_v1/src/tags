!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AIG_FALSE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
AIG_NODE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
BDD_CMD_H	bdd/bddCmd.h	10;"	d
BDD_EDGEV_BITS	bdd/bddNodeV.h	18;"	d
BDD_EDGEV_DUMMY	bdd/bddNodeV.h	/^   BDD_EDGEV_DUMMY  \/\/ dummy end$/;"	e	enum:BDD_EDGEV_FLAG
BDD_EDGEV_FLAG	bdd/bddNodeV.h	/^enum BDD_EDGEV_FLAG$/;"	g
BDD_MGRV_H	bdd/bddMgrV.h	10;"	d
BDD_NEG_EDGEV	bdd/bddNodeV.h	/^   BDD_NEG_EDGEV = 1,$/;"	e	enum:BDD_EDGEV_FLAG
BDD_NODEV_H	bdd/bddNodeV.h	10;"	d
BDD_NODE_PTR_MASKV	bdd/bddNodeV.h	20;"	d
BDD_POS_EDGEV	bdd/bddNodeV.h	/^   BDD_POS_EDGEV = 0,$/;"	e	enum:BDD_EDGEV_FLAG
BUF_SIZE	itp/reader.h	17;"	d
BUF_SIZE	pdr/reader.h	17;"	d
BV_ADD	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_AND	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_BUF	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_CONST	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_DIV	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_EQUALITY	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_GEQ	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_GREATER	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_INV	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_LEQ	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_LESS	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_MERGE	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_MODULO	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_MULT	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_MUX	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_NAND	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_NEQ	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_NOR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_OR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_RED_AND	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_RED_OR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_RED_XOR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_SHL	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SHR	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SLICE	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_SUB	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SVR_BOOLECTOR_C	svr/v3SvrBoolector.cpp	10;"	d	file:
BV_XNOR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_XOR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BddArr	bdd/bddMgrV.h	/^typedef vector<size_t>                        BddArr;$/;"	t
BddCache	bdd/bddMgrV.h	/^typedef Cache<BddCacheKeyV, size_t>    BddCache;$/;"	t	class:BddMgrV
BddCacheKeyV	bdd/bddMgrV.h	/^   BddCacheKeyV() {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/bddMgrV.h	/^   BddCacheKeyV(size_t f, size_t g, size_t h) : _f(f), _g(g), _h(h) {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/bddMgrV.h	/^class BddCacheKeyV$/;"	c
BddHash	bdd/bddMgrV.h	/^typedef Hash<BddHashKeyV, BddNodeVInt*> BddHash;$/;"	t	class:BddMgrV
BddHashKeyV	bdd/bddMgrV.h	/^   BddHashKeyV(size_t l, size_t r, unsigned i) : _l(l), _r(r), _i(i) {}$/;"	f	class:BddHashKeyV
BddHashKeyV	bdd/bddMgrV.h	/^class BddHashKeyV$/;"	c
BddMap	bdd/bddMgrV.h	/^typedef map<string, size_t>                   BddMap;$/;"	t
BddMapConstIter	bdd/bddMgrV.h	/^typedef map<string, size_t>::const_iterator   BddMapConstIter;$/;"	t
BddMapPair	bdd/bddMgrV.h	/^typedef pair<string, size_t>                  BddMapPair;$/;"	t
BddMgrV	bdd/bddMgrV.h	/^   BddMgrV(size_t nin = 64, size_t h = 8009, size_t c = 30011)$/;"	f	class:BddMgrV
BddMgrV	bdd/bddMgrV.h	/^class BddMgrV$/;"	c
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(BddNodeVInt* n, BDD_EDGEV_FLAG f)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(const BddNodeV& n) : _nodeV(n._nodeV)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(size_t l, size_t r, size_t i, BDD_EDGEV_FLAG f)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(size_t v) : _nodeV(v)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.h	/^   BddNodeV() : _nodeV(0) {}$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.h	/^class BddNodeV$/;"	c
BddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt() : _level(0), _refCount(0), _visited(0) {}$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt(size_t l, size_t r, unsigned ll)$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/bddNodeV.h	/^class BddNodeVInt$/;"	c
BtorExp	svr/v3SvrType.h	/^typedef struct BtorNode             BtorExp;$/;"	t	typeref:struct:BtorNode
Bucket	adt/v3Bucket.h	/^   typedef typename V3Stack<T>::Stack     Bucket;$/;"	t	class:V3BucketList
Bucket	adt/v3Bucket.h	/^   typedef typename V3Vec<T>::Vec         Bucket;$/;"	t	class:V3IncBucketList
BucketId	adt/v3Bucket.h	/^   typedef pair<uint32_t, Bucket>         BucketId;$/;"	t	class:V3IncBucketList
BucketList	adt/v3Bucket.h	/^   typedef typename V3Vec<Bucket>::Vec    BucketList;$/;"	t	class:V3BucketList
BucketList	adt/v3Bucket.h	/^   typedef typename V3Vec<BucketId>::Vec  BucketList;$/;"	t	class:V3IncBucketList
C2PMapON	ntk/v3NtkHandler.h	/^      static inline const bool C2PMapON()  { return _extVerbosity & 16ul; }$/;"	f	class:V3NtkHandler
CC_MINIMIZATION	pdr/SolverV.cpp	25;"	d	file:
CMD_EXEC_DONE	cmd/v3CmdMgr.h	/^   CMD_EXEC_DONE  = 0,$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_ERROR	cmd/v3CmdMgr.h	/^   CMD_EXEC_ERROR = 1,$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_NOP	cmd/v3CmdMgr.h	/^   CMD_EXEC_NOP   = 3$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_QUIT	cmd/v3CmdMgr.h	/^   CMD_EXEC_QUIT  = 2,$/;"	e	enum:V3CmdExecStatus
CMD_OPT_EXTRA	cmd/v3CmdMgr.h	/^   CMD_OPT_EXTRA      = 1,$/;"	e	enum:V3CmdOptionError
CMD_OPT_FOPEN_FAIL	cmd/v3CmdMgr.h	/^   CMD_OPT_FOPEN_FAIL = 3$/;"	e	enum:V3CmdOptionError
CMD_OPT_ILLEGAL	cmd/v3CmdMgr.h	/^   CMD_OPT_ILLEGAL    = 2,$/;"	e	enum:V3CmdOptionError
CMD_OPT_MISSING	cmd/v3CmdMgr.h	/^   CMD_OPT_MISSING    = 0,$/;"	e	enum:V3CmdOptionError
CMD_TYPE_BDD	cmd/v3CmdMgr.h	/^   CMD_TYPE_BDD         = 11,  \/\/ MODIFICATION FOR SoCV BDD$/;"	e	enum:V3CmdType
CMD_TYPE_COMMON	cmd/v3CmdMgr.h	/^   CMD_TYPE_COMMON      = 1,$/;"	e	enum:V3CmdType
CMD_TYPE_DEBUGFIX	cmd/v3CmdMgr.h	/^   CMD_TYPE_DEBUGFIX    = 10,$/;"	e	enum:V3CmdType
CMD_TYPE_EXTRACT	cmd/v3CmdMgr.h	/^   CMD_TYPE_EXTRACT     = 6,$/;"	e	enum:V3CmdType
CMD_TYPE_IO	cmd/v3CmdMgr.h	/^   CMD_TYPE_IO          = 2,$/;"	e	enum:V3CmdType
CMD_TYPE_ITP	cmd/v3CmdMgr.h	/^   CMD_TYPE_ITP         = 12,  \/\/ MODIFICATION FOR SoCV ITP$/;"	e	enum:V3CmdType
CMD_TYPE_MANIP	cmd/v3CmdMgr.h	/^   CMD_TYPE_MANIP       = 5,$/;"	e	enum:V3CmdType
CMD_TYPE_MODELCHKING	cmd/v3CmdMgr.h	/^   CMD_TYPE_MODELCHKING = 9,$/;"	e	enum:V3CmdType
CMD_TYPE_PDR	cmd/v3CmdMgr.h	/^   CMD_TYPE_PDR         = 13,  \/\/ MODIFICATION FOR SoCV PDR$/;"	e	enum:V3CmdType
CMD_TYPE_PRINT	cmd/v3CmdMgr.h	/^   CMD_TYPE_PRINT       = 3,$/;"	e	enum:V3CmdType
CMD_TYPE_REVEALED	cmd/v3CmdMgr.h	/^   CMD_TYPE_REVEALED    = 0,$/;"	e	enum:V3CmdType
CMD_TYPE_SIMULATE	cmd/v3CmdMgr.h	/^   CMD_TYPE_SIMULATE    = 7,$/;"	e	enum:V3CmdType
CMD_TYPE_SYNTHESIS	cmd/v3CmdMgr.h	/^   CMD_TYPE_SYNTHESIS   = 4,$/;"	e	enum:V3CmdType
CMD_TYPE_TOTAL	cmd/v3CmdMgr.h	/^   CMD_TYPE_TOTAL       = 14   \/\/ MODIFICATION FOR SoCV $/;"	e	enum:V3CmdType
CMD_TYPE_VERIFY	cmd/v3CmdMgr.h	/^   CMD_TYPE_VERIFY      = 8,$/;"	e	enum:V3CmdType
COMMON	itp/satMgr.h	/^  COMMON,$/;"	e	enum:VAR_GROUP
Cache	bdd/myHash.h	/^   Cache() : _size(0), _cache(0) {}$/;"	f	class:Cache
Cache	bdd/myHash.h	/^   Cache(size_t s) : _size(0), _cache(0) { init(s); }$/;"	f	class:Cache
Cache	bdd/myHash.h	/^class Cache$/;"	c
CacheNode	bdd/myHash.h	/^typedef pair<CacheKey, CacheData> CacheNode;$/;"	t	class:Cache
Clause	pdr/SolverTypesV.h	/^    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {$/;"	f	class:Clause
Clause	pdr/SolverTypesV.h	/^class Clause {$/;"	c
ClauseId	pdr/SolverTypesV.h	/^typedef int ClauseId;     \/\/ (might have to use uint64 one day...)$/;"	t
ClauseId_NULL	pdr/SolverTypesV.h	/^const   int ClauseId_NULL = INT_MIN;$/;"	v
Clause_new	pdr/SolverTypesV.h	/^inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {$/;"	f
Cube	pdr/PDRDef.h	/^  Cube(){$/;"	f	class:Cube
Cube	pdr/PDRDef.h	/^  Cube(Cube* c) {$/;"	f	class:Cube
Cube	pdr/PDRDef.h	/^  Cube(bool* b) {$/;"	f	class:Cube
Cube	pdr/PDRDef.h	/^  Cube(bool* b, bool* d) {$/;"	f	class:Cube
Cube	pdr/PDRDef.h	/^  Cube(const Cube& c) {$/;"	f	class:Cube
Cube	pdr/PDRDef.h	/^class Cube {$/;"	c
Current_Pos	itp/reader.h	/^	unsigned int Current_Pos()	{ return overall_pos; }$/;"	f	class:Reader
Current_Pos	pdr/reader.h	/^	unsigned int Current_Pos()	{ return overall_pos; }$/;"	f	class:Reader
DEFAULTS	pdr/FileV.h	40;"	d
DEFAULTS	pdr/FileV.h	48;"	d
DIR_MOD_MASK	util/v3FileUtil.h	21;"	d
DO_STD_ITE	bdd/bddMgrV.cpp	104;"	d	file:
Datum	pdr/GlobalV.h	/^    typedef T   Datum;$/;"	t	class:vec
Exception_EOF	pdr/FileV.h	/^class Exception_EOF {};$/;"	c
F	pdr/pdrMgr.h	/^    vector<vector<Cube*>*>*   F;         \/\/ be careful of the type of this data member$/;"	m	class:PDRMgr
File	pdr/FileV.h	/^    File(cchar* name, cchar* mode) : DEFAULTS {$/;"	f	class:File
File	pdr/FileV.h	/^    File(int fd, FileMode mode, bool own_fd = true) : DEFAULTS  {$/;"	f	class:File
File	pdr/FileV.h	/^    File(void) : DEFAULTS {}$/;"	f	class:File
File	pdr/FileV.h	/^class File {$/;"	c
FileMode	pdr/FileV.h	/^enum FileMode { READ, WRITE };$/;"	g
File_BufSize	pdr/FileV.h	22;"	d
File_h	pdr/FileV.h	2;"	d
GClause	pdr/SolverTypesV.h	/^    GClause(void* d) : data(d) {}$/;"	f	class:GClause
GClause	pdr/SolverTypesV.h	/^class GClause {$/;"	c
GClause_NULL	pdr/SolverTypesV.h	143;"	d
GClause_new	pdr/SolverTypesV.h	/^inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }$/;"	f
GClause_new	pdr/SolverTypesV.h	/^inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }$/;"	f
Global_h	pdr/GlobalV.h	21;"	d
Hash	adt/v3Hash.h	/^   typedef tr1::unordered_map<Key, Data, HashFcn, EqualKey, Alloc> Hash;$/;"	t	struct:V3HashMap
Hash	adt/v3Hash.h	/^   typedef tr1::unordered_set<Key, HashFcn, EqualKey, Alloc> Hash;$/;"	t	struct:V3HashSet
Hash	bdd/myHash.h	/^   Hash() : _numBuckets(0), _buckets(0) {}$/;"	f	class:Hash
Hash	bdd/myHash.h	/^   Hash(size_t b) : _numBuckets(0), _buckets(0) { init(b); }$/;"	f	class:Hash
Hash	bdd/myHash.h	/^class Hash$/;"	c
HashNode	bdd/myHash.h	/^typedef pair<HashKey, HashData> HashNode;$/;"	t	class:Hash
Heap	pdr/HeapV.h	/^    Heap(C c) : comp(c) { heap.push(-1); }$/;"	f	class:Heap
Heap	pdr/HeapV.h	/^class Heap {$/;"	c
Heap_h	pdr/HeapV.h	21;"	d
I64_fmt	pdr/GlobalV.h	41;"	d
I64_fmt	pdr/GlobalV.h	47;"	d
IDX_MASK	adt/v3BitVec.cpp	/^static const unsigned char IDX_MASK[]  = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };$/;"	v	file:
Key	pdr/GlobalV.h	/^    typedef int Key;$/;"	t	class:vec
L	pdr/pdrMgr.h	/^    unsigned                  L;         \/\/ latch size$/;"	m	class:PDRMgr
LOCAL_OFF	itp/satMgr.h	/^  LOCAL_OFF,$/;"	e	enum:VAR_GROUP
LOCAL_ON	itp/satMgr.h	/^  LOCAL_ON,$/;"	e	enum:VAR_GROUP
L_LIT	pdr/SolverV.h	224;"	d
L_lit	pdr/SolverV.h	225;"	d
LessThan_default	pdr/SortV.h	/^struct LessThan_default {$/;"	s
List	adt/v3List.h	/^   typedef std::list<T> List;$/;"	t	struct:V3List
Lit	pdr/SolverTypesV.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	pdr/SolverTypesV.h	/^    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}$/;"	f	class:Lit
Lit	pdr/SolverTypesV.h	/^class Lit {$/;"	c
MOD_WORD	adt/v3BitVec.cpp	/^static const unsigned char MOD_WORD    = 0x07;$/;"	v	file:
MSG_DBG	util/v3Msg.h	/^   MSG_DBG = 3,$/;"	e	enum:V3MsgType
MSG_ERR	util/v3Msg.h	/^   MSG_ERR = 1,$/;"	e	enum:V3MsgType
MSG_IFO	util/v3Msg.h	/^   MSG_IFO = 4$/;"	e	enum:V3MsgType
MSG_LOG	util/v3Msg.h	/^   MSG_LOG = 0,$/;"	e	enum:V3MsgType
MSG_WAR	util/v3Msg.h	/^   MSG_WAR = 2,$/;"	e	enum:V3MsgType
MYCLK_TCK	util/v3Usage.h	25;"	d
MYCLK_TCK	util/v3Usage.h	26;"	d
MY_HASH_H	bdd/myHash.h	10;"	d
Map	adt/v3Map.h	/^   typedef std::map<Key, Data, Compare, Alloc> Map;$/;"	t	struct:V3Map
Msg	main/main.cpp	/^V3MsgMgr Msg;$/;"	v
MsgTypeString	util/v3Msg.h	/^      vector<string> MsgTypeString;$/;"	m	class:V3MsgMgr
Msgs	util/v3Msg.h	/^      vector<V3Msg*> Msgs;$/;"	m	class:V3MsgMgr
NONE	itp/satMgr.h	/^  NONE$/;"	e	enum:VAR_GROUP
P2CMapON	ntk/v3NtkHandler.h	/^      static inline const bool P2CMapON()  { return _extVerbosity & 8ul;  }$/;"	f	class:V3NtkHandler
PDR	pdr/pdrMgr.cpp	/^bool PDRMgr::PDR(const V3NetId& monitor, SatProofRes& pRes) {$/;"	f	class:PDRMgr
PDRDEF_H	pdr/PDRDef.h	14;"	d
PDRMgr	pdr/pdrMgr.h	/^    PDRMgr(): _ntk(NULL) { reset(); }$/;"	f	class:PDRMgr
PDRMgr	pdr/pdrMgr.h	/^class PDRMgr {$/;"	c
PDR_CMD_H_	pdr/pdrCmd.h	10;"	d
PDR_MGR_H_	pdr/pdrMgr.h	10;"	d
PROVE_CMD_H_	prove/proveCmd.h	10;"	d
Proof	pdr/ProofV.cpp	/^Proof::Proof()$/;"	f	class:Proof
Proof	pdr/ProofV.cpp	/^Proof::Proof(ProofTraverser& t)$/;"	f	class:Proof
Proof	pdr/ProofV.h	/^class Proof {$/;"	c
ProofTraverser	pdr/ProofV.h	/^struct ProofTraverser {$/;"	s
Proof_h	pdr/ProofV.h	21;"	d
Queue	adt/v3Queue.h	/^   typedef std::queue<T> Queue;$/;"	t	struct:V3Queue
RDR_EOF	itp/reader.h	18;"	d
RDR_EOF	pdr/reader.h	18;"	d
READ	pdr/FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
Reader	itp/reader.h	/^	Reader():fd(-1)				{};$/;"	f	class:Reader
Reader	itp/reader.h	/^class Reader{$/;"	c
Reader	pdr/reader.h	/^	Reader():fd(-1)				{};$/;"	f	class:Reader
Reader	pdr/reader.h	/^class Reader{$/;"	c
SATMgr	itp/satMgr.h	/^    SATMgr():_ptrMinisat(NULL), _ntk(NULL) { reset(); }$/;"	f	class:SATMgr
SATMgr	itp/satMgr.h	/^class SATMgr {$/;"	c
SAT_C	itp/sat.cpp	10;"	d	file:
SAT_CMD_H_	itp/satCmd.h	10;"	d
SAT_H	itp/sat.h	10;"	d
SAT_MGR_H_	itp/satMgr.h	10;"	d
STATIC_ASSERTION_FAILURE	pdr/GlobalV.h	/^template <> struct STATIC_ASSERTION_FAILURE<true>{};$/;"	s
SatProofRes	itp/satMgr.h	/^    SatProofRes(SatSolver* s = 0):$/;"	f	class:SatProofRes
SatProofRes	itp/satMgr.h	/^class SatProofRes {$/;"	c
SatProofRes	pdr/pdrMgr.h	/^    SatProofRes(V3SvrPDRSat* s = 0):$/;"	f	class:SatProofRes
SatProofRes	pdr/pdrMgr.h	/^class SatProofRes {$/;"	c
SatSolver	itp/sat.cpp	/^SatSolver::SatSolver(const V3Ntk* const ntk ): _ntk(ntk)$/;"	f	class:SatSolver
SatSolver	itp/sat.h	/^class SatSolver$/;"	c
SearchParams	pdr/SolverV.h	/^    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }$/;"	f	struct:SearchParams
SearchParams	pdr/SolverV.h	/^struct SearchParams {$/;"	s
Set	adt/v3Set.h	/^   typedef std::set<Key, Compare, Alloc> Set;$/;"	t	struct:V3Set
SolverStats	pdr/SolverV.h	/^    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)$/;"	f	struct:SolverStats
SolverStats	pdr/SolverV.h	/^struct SolverStats {$/;"	s
SolverTypes_h	pdr/SolverTypesV.h	22;"	d
SolverV	pdr/SolverV.h	/^    SolverV() : ok               (true)$/;"	f	class:SolverV
SolverV	pdr/SolverV.h	/^class SolverV {$/;"	c
Solver_h	pdr/SolverV.h	21;"	d
Sort_h	pdr/SortV.h	21;"	d
Stack	adt/v3Stack.h	/^   typedef std::stack<T> Stack;$/;"	t	struct:V3Stack
StdEndLine	util/v3Msg.h	/^      typedef ostream& (*StdEndLine)(ostream&);  \/\/ overload operator << for std::endl$/;"	t	class:V3Msg
TCube	pdr/PDRDef.h	/^  TCube(): _cube(NULL), _frame(-1) {$/;"	f	class:TCube
TCube	pdr/PDRDef.h	/^  TCube(Cube* c, unsigned d): _cube(c), _frame((int)d) {$/;"	f	class:TCube
TCube	pdr/PDRDef.h	/^  TCube(const TCube& t) {$/;"	f	class:TCube
TCube	pdr/PDRDef.h	/^class TCube$/;"	c
TCubeCmp	pdr/pdrMgr.cpp	/^class TCubeCmp {$/;"	c	file:
TEMPLATE_FAIL	pdr/GlobalV.h	58;"	d
TempFiles	pdr/ProofV.cpp	/^class TempFiles {$/;"	c	file:
UNSATGeneralizationWithUNSATCore	pdr/v3SvrPDRSat.cpp	/^Cube* V3SvrPDRSat::UNSATGeneralizationWithUNSATCore(Cube* c, vector<Lit>& Lit_vec_origin) {$/;"	f	class:V3SvrPDRSat
V3AigNtk	ntk/v3Ntk.h	/^typedef V3Ntk     V3AigNtk;$/;"	t
V3AigParser	io/v3AigParser.cpp	/^V3NtkInput* const V3AigParser(const char* fileName, const bool& symbol) {$/;"	f
V3AigSDG	stg/v3StgSDG.cpp	/^V3AigSDG::V3AigSDG(V3NtkHandler* const handler) : V3SDG(handler) {$/;"	f	class:V3AigSDG
V3AigSDG	stg/v3StgSDG.h	/^class V3AigSDG : public V3SDG {$/;"	c
V3AigSimDataVec	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecS>::Vec             V3AigSimDataVec;$/;"	t
V3AigSimRecord	alg/v3AlgType.h	/^typedef pair<V3NetId, V3BitVecS>          V3AigSimRecord;$/;"	t
V3AigSimRecordVec	alg/v3AlgType.h	/^typedef V3Vec<V3AigSimRecord>::Vec        V3AigSimRecordVec;$/;"	t
V3AigSimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3AigSimDataVec>::Vec       V3AigSimTraceVec;$/;"	t
V3AigWriter	io/v3AigWriter.cpp	/^void V3AigWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol) {$/;"	f
V3AlgAigGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::V3AlgAigGeneralize(const V3NtkHandler* const handler) : V3AlgAigSimulate(handler), V3AlgGeneralize() {$/;"	f	class:V3AlgAigGeneralize
V3AlgAigGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgAigGeneralize : public V3AlgAigSimulate, public V3AlgGeneralize {$/;"	c
V3AlgAigSimulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::V3AlgAigSimulate(const V3NtkHandler* const handler) : V3AlgSimulate(handler) {$/;"	f	class:V3AlgAigSimulate
V3AlgAigSimulate	alg/v3AlgSimulate.h	/^class V3AlgAigSimulate : public V3AlgSimulate$/;"	c
V3AlgBvGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::V3AlgBvGeneralize(const V3NtkHandler* const handler) : V3AlgBvSimulate(handler), V3AlgGeneralize() {$/;"	f	class:V3AlgBvGeneralize
V3AlgBvGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgBvGeneralize : public V3AlgBvSimulate, public V3AlgGeneralize {$/;"	c
V3AlgBvSimulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::V3AlgBvSimulate(const V3NtkHandler* const handler) : V3AlgSimulate(handler) {$/;"	f	class:V3AlgBvSimulate
V3AlgBvSimulate	alg/v3AlgSimulate.h	/^class V3AlgBvSimulate : public V3AlgSimulate$/;"	c
V3AlgGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::V3AlgGeneralize() {$/;"	f	class:V3AlgGeneralize
V3AlgGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgGeneralize {$/;"	c
V3AlgSimulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::V3AlgSimulate(const V3NtkHandler* const handler) : _handler(handler) {$/;"	f	class:V3AlgSimulate
V3AlgSimulate	alg/v3AlgSimulate.h	/^class V3AlgSimulate$/;"	c
V3AsyncDFFName	ntk/v3Type.h	/^const string V3AsyncDFFName   = "v3_Async_FF_Net_";$/;"	v
V3AsyncMuxName	ntk/v3Type.h	/^const string V3AsyncMuxName   = "v3_Async_MUX_Net_";$/;"	v
V3AuxExpansionName	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxExpansionName   = V3ExpansionName;$/;"	m	class:V3NtkHandler	file:
V3AuxExpansionName	ntk/v3NtkHandler.h	/^      static string        V3AuxExpansionName;$/;"	m	class:V3NtkHandler
V3AuxHierSeparator	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxHierSeparator   = V3HierSeparator;$/;"	m	class:V3NtkHandler	file:
V3AuxHierSeparator	ntk/v3NtkHandler.h	/^      static string        V3AuxHierSeparator;$/;"	m	class:V3NtkHandler
V3AuxNameBitPrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameBitPrefix   = V3NameBitPrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameBitPrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameBitPrefix;$/;"	m	class:V3NtkHandler
V3AuxNameBitSuffix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameBitSuffix   = V3NameBitSuffix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameBitSuffix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameBitSuffix;$/;"	m	class:V3NtkHandler
V3AuxNameInvPrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameInvPrefix   = V3NameInvPrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameInvPrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameInvPrefix;$/;"	m	class:V3NtkHandler
V3AuxNetNamePrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNetNamePrefix   = V3NetNamePrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNetNamePrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNetNamePrefix;$/;"	m	class:V3NtkHandler
V3BVXId	ntk/v3Ntk.h	/^typedef uint32_t     V3BVXId;$/;"	t
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const V3BitVec& b) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const char* exp) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const unsigned& s) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.h	/^class V3BitVec$/;"	c
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS() { clear(); }$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const V3BitVecS& v) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const V3BitVecX& v) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const uint64_t& zeros, const uint64_t& ones) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.h	/^class V3BitVecS$/;"	c
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVec& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVecS& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVecX& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const unsigned& s) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.h	/^class V3BitVecX$/;"	c
V3BitVecXVec	ntk/v3Ntk.h	/^typedef V3Vec<V3BitVecX*   >::Vec   V3BitVecXVec;$/;"	t
V3BoolTable	adt/v3Misc.h	/^typedef V3Vec<V3BoolVec >::Vec   V3BoolTable;$/;"	t
V3BoolVec	adt/v3Misc.h	/^typedef V3Vec<bool      >::Vec   V3BoolVec;$/;"	t
V3BtorExpTable	svr/v3SvrType.h	/^typedef V3Vec<V3BtorExpVec>::Vec    V3BtorExpTable;$/;"	t
V3BtorExpVec	svr/v3SvrType.h	/^typedef V3Vec<BtorExp*>::Vec        V3BtorExpVec;$/;"	t
V3BtorLexVec	io/v3BtorParser.cpp	/^typedef V3Vec<string>::Vec    V3BtorLexVec;$/;"	t	file:
V3BtorParser	io/v3BtorParser.cpp	/^V3NtkInput* const V3BtorParser(const char* fileName, const bool& symbol) {$/;"	f
V3BtorWriter	io/v3BtorWriter.cpp	/^void V3BtorWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol) {$/;"	f
V3BucketList	adt/v3Bucket.h	/^      V3BucketList(const uint32_t& size = 0) { _size = 0; _bestIndex = 0; _elements.clear(); init(size); }$/;"	f	class:V3BucketList
V3BucketList	adt/v3Bucket.h	/^class V3BucketList {$/;"	c
V3BusId	ntk/v3Ntk.h	/^typedef uint32_t     V3BusId;$/;"	t
V3BusIdHash	ntk/v3Ntk.h	/^typedef V3HashMap<uint64_t,   V3BusId>::Hash V3BusIdHash;$/;"	t
V3BusPair	ntk/v3Ntk.h	/^typedef V3PairType   V3BusPair;$/;"	t
V3BusPairVec	ntk/v3Ntk.h	/^typedef V3Vec<V3BusPair    >::Vec   V3BusPairVec;$/;"	t
V3BvBlastAig	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::V3BvBlastAig(V3NtkHandler* const p) $/;"	f	class:V3BvBlastAig
V3BvBlastAig	trans/v3BvBlastAig.h	/^class V3BvBlastAig : public V3NtkHandler$/;"	c
V3BvBlastBv	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::V3BvBlastBv(V3NtkHandler* const p) : V3NtkHandler(p) {$/;"	f	class:V3BvBlastBv
V3BvBlastBv	trans/v3BvBlastBv.h	/^class V3BvBlastBv : public V3NtkHandler$/;"	c
V3BvBlastBvMap	trans/v3BvBlastBv.h	/^typedef V3Map<uint32_t, uint32_t>::Map    V3BvBlastBvMap;$/;"	t
V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::V3BvNtk() : V3Ntk() {$/;"	f	class:V3BvNtk
V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::V3BvNtk(const V3BvNtk& ntk) : V3Ntk(ntk) {$/;"	f	class:V3BvNtk
V3BvNtk	ntk/v3Ntk.h	/^class V3BvNtk : public V3Ntk$/;"	c
V3BvSimDataVec	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecX>::Vec             V3BvSimDataVec;$/;"	t
V3BvSimNetId	alg/v3AlgType.h	/^typedef pair<V3NetId, uint32_t>           V3BvSimNetId;$/;"	t
V3BvSimNetVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimNetId>::Vec          V3BvSimNetVec;$/;"	t
V3BvSimRecord	alg/v3AlgType.h	/^typedef pair<V3NetId, V3BitVecX>          V3BvSimRecord;$/;"	t
V3BvSimRecordVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimRecord>::Vec         V3BvSimRecordVec;$/;"	t
V3BvSimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimDataVec>::Vec        V3BvSimTraceVec;$/;"	t
V3CITPCube	vrf/v3VrfCITP.h	/^      V3CITPCube(const V3CITPCube& c) : _nextCube(0) { _stateId = c._stateId; _signature = c._signature; }$/;"	f	class:V3CITPCube
V3CITPCube	vrf/v3VrfCITP.h	/^      V3CITPCube(const V3CITPCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3CITPCube
V3CITPCube	vrf/v3VrfCITP.h	/^class V3CITPCube$/;"	c
V3CITPCubeCompare	vrf/v3VrfCITP.h	/^struct V3CITPCubeCompare {$/;"	s
V3CITPCubeList	vrf/v3VrfCITP.h	/^typedef V3Set<V3CITPCube*, V3CITPCubeCompare>::Set   V3CITPCubeList;$/;"	t
V3CITPFrame	vrf/v3VrfCITP.cpp	/^V3CITPFrame::V3CITPFrame() {$/;"	f	class:V3CITPFrame
V3CITPFrame	vrf/v3VrfCITP.h	/^class V3CITPFrame$/;"	c
V3CITPFrameVec	vrf/v3VrfCITP.h	/^typedef V3Vec<V3CITPFrame*>::Vec          V3CITPFrameVec;$/;"	t
V3CexTrace	ext/v3Property.h	/^      V3CexTrace(const uint32_t& s) : _size(s) { _init = 0; _data.clear(); _data.reserve(s); }$/;"	f	class:V3CexTrace
V3CexTrace	ext/v3Property.h	/^class V3CexTrace$/;"	c
V3CexTraceParser	ext/v3ExtIO.cpp	/^V3CexTrace* const V3CexTraceParser(const V3NtkHandler* const handler, const string& fileName) {$/;"	f
V3CexTraceVisualizer	ext/v3ExtIO.cpp	/^void V3CexTraceVisualizer(const V3NtkHandler* const handler, const V3CexTrace* const cex, const string& fileName) {$/;"	f
V3CexTraceWriter	ext/v3ExtIO.cpp	/^void V3CexTraceWriter(const V3NtkHandler* const handler, const V3CexTrace* const cex, const string& fileName) {$/;"	f
V3CmdCompare	cmd/v3CmdMgr.h	/^struct V3CmdCompare { bool operator() (const V3CmdExec* a, const V3CmdExec* b) const { return (*a < *b); } };$/;"	s
V3CmdExec	cmd/v3CmdMgr.h	/^      V3CmdExec(V3CmdType t) : _cmdType(t) {}$/;"	f	class:V3CmdExec
V3CmdExec	cmd/v3CmdMgr.h	/^class V3CmdExec$/;"	c
V3CmdExecSet	cmd/v3CmdMgr.h	/^typedef map<V3CmdType, V3CmdExecSubSet*>  V3CmdExecSet;$/;"	t
V3CmdExecStatus	cmd/v3CmdMgr.h	/^enum V3CmdExecStatus$/;"	g
V3CmdExecSubSet	cmd/v3CmdMgr.h	/^typedef set<V3CmdExec*, V3CmdCompare>     V3CmdExecSubSet;$/;"	t
V3CmdMgr	cmd/v3CmdMgr.cpp	/^V3CmdMgr::V3CmdMgr(const string& p) : _defaultPrompt(p) {$/;"	f	class:V3CmdMgr
V3CmdMgr	cmd/v3CmdMgr.h	/^class V3CmdMgr $/;"	c
V3CmdOptionError	cmd/v3CmdMgr.h	/^enum V3CmdOptionError$/;"	g
V3CmdType	cmd/v3CmdMgr.h	/^enum V3CmdType$/;"	g
V3CmdTypeString	cmd/v3CmdMgr.h	/^const string V3CmdTypeString[] = {$/;"	v
V3ConstHash	ntk/v3Ntk.h	/^typedef V3HashMap<string,     V3BVXId>::Hash V3ConstHash;$/;"	t
V3Constraint	ext/v3Property.cpp	/^V3Constraint::V3Constraint(V3NtkHandler* const handler, V3FSM* const fsm) $/;"	f	class:V3Constraint
V3Constraint	ext/v3Property.cpp	/^V3Constraint::V3Constraint(V3NtkHandler* const handler, const uint32_t& start, const uint32_t& end) $/;"	f	class:V3Constraint
V3Constraint	ext/v3Property.h	/^class V3Constraint$/;"	c
V3ConstraintVec	ext/v3Property.h	/^typedef V3Vec<V3Constraint*>::Vec   V3ConstraintVec;$/;"	t
V3DblMAX	util/v3IntType.h	/^const double   V3DblMAX    = DBL_MAX;$/;"	v
V3DblVec	adt/v3Misc.h	/^typedef V3Vec<double    >::Vec   V3DblVec;$/;"	t
V3DfxCube	dfx/v3DfxTrace.h	/^      V3DfxCube(const uint32_t& f) : _frameId(f) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3DfxCube
V3DfxCube	dfx/v3DfxTrace.h	/^class V3DfxCube$/;"	c
V3DfxCubeCompare	dfx/v3DfxTrace.h	/^struct V3DfxCubeCompare {$/;"	s
V3DfxCubeList	dfx/v3DfxTrace.h	/^typedef V3Set<V3DfxCube*, V3DfxCubeCompare>::Set      V3DfxCubeList;$/;"	t
V3DirectedEdge	adt/v3Graph.h	/^   typedef pair<V3UI32Set, V3UI32Set>              V3DirectedEdge;$/;"	t	class:V3Graph
V3DirectedNode	adt/v3Graph.h	/^   typedef pair<T, V3DirectedEdge>                 V3DirectedNode;$/;"	t	class:V3Graph
V3ExpansionName	ntk/v3Type.h	/^const string V3ExpansionName  = "@";$/;"	v
V3FITPCube	vrf/v3VrfFITP.h	/^      V3FITPCube(const V3FITPCube& c) : _nextCube(0) { _stateId = c._stateId; _signature = c._signature; }$/;"	f	class:V3FITPCube
V3FITPCube	vrf/v3VrfFITP.h	/^      V3FITPCube(const V3FITPCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3FITPCube
V3FITPCube	vrf/v3VrfFITP.h	/^class V3FITPCube$/;"	c
V3FITPCubeCompare	vrf/v3VrfFITP.h	/^struct V3FITPCubeCompare {$/;"	s
V3FITPCubeList	vrf/v3VrfFITP.h	/^typedef V3Set<V3FITPCube*, V3FITPCubeCompare>::Set   V3FITPCubeList;$/;"	t
V3FITPFrame	vrf/v3VrfFITP.cpp	/^V3FITPFrame::V3FITPFrame() {$/;"	f	class:V3FITPFrame
V3FITPFrame	vrf/v3VrfFITP.h	/^class V3FITPFrame$/;"	c
V3FITPFrameVec	vrf/v3VrfFITP.h	/^typedef V3Vec<V3FITPFrame*>::Vec          V3FITPFrameVec;$/;"	t
V3FITPSvrData	vrf/v3VrfFITP.h	/^typedef V3Vec<size_t>::Vec                V3FITPSvrData;$/;"	t
V3FSM	stg/v3StgFSM.cpp	/^V3FSM::V3FSM(V3FSMSDGDB* const sdgDB, V3SvrBase* const solver) $/;"	f	class:V3FSM
V3FSM	stg/v3StgFSM.h	/^class V3FSM {$/;"	c
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const V3NetVec& outputs, const V3NetVec& targets) $/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const V3NetVec& targets) : _handler(handler),$/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const string& fileName, const V3NetVec& targets) $/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.h	/^class V3FSMExtract {$/;"	c
V3FSMMap	ntk/v3NtkHandler.h	/^typedef V3Map<string, V3FSMExtract*>::Map V3FSMMap;$/;"	t
V3FSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::V3FSMSDG(const V3NetId& id) : _netId(id) {$/;"	f	class:V3FSMSDG
V3FSMSDG	stg/v3StgFSM.h	/^class V3FSMSDG {$/;"	c
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3NtkHandler* const handler, const V3StrTable& sdgSpec)$/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3SDG* const sdgMain, const V3NetVec& depVarList, V3SvrBase* const solver) $/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3SDG* const sdgMain, const V3NetVec& depVarList, const V3SolverType& solverType) $/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.h	/^class V3FSMSDGDB {$/;"	c
V3FSMSDGDBList	stg/v3StgExtract.h	/^typedef V3Vec<V3FSMSDGDB*>::Vec     V3FSMSDGDBList;$/;"	t
V3FSMSDGList	stg/v3StgFSM.h	/^typedef V3Vec<V3FSMSDG*>::Vec             V3FSMSDGList;$/;"	t
V3FSMSDGMap	stg/v3StgFSM.h	/^typedef V3Map<uint32_t, V3FSMSDG*>::Map   V3FSMSDGMap;$/;"	t
V3FSMSDGSet	stg/v3StgFSM.h	/^typedef V3Set<V3FSMSDG*>::Set             V3FSMSDGSet;$/;"	t
V3FSMVec	stg/v3StgExtract.h	/^typedef V3Vec<V3FSM*>::Vec          V3FSMVec;$/;"	t
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const V3NetId& id) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const V3SimTraceVec& cexTrace, const double& strength) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const string& formulaExp) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const uint32_t& constrSize, const uint32_t& maxCard, const V3GateType& gateType, const uint32_t& noPIorFF) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(const V3Formula& formula) : _handler(formula._handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.h	/^class V3Formula$/;"	c
V3FormulaList	ext/v3Formula.h	/^      typedef V3Vec<V3FormulaNode>::Vec      V3FormulaList;$/;"	t	class:V3Formula
V3FormulaNode	ext/v3Formula.h	/^      typedef pair<V3GateType, V3InputVec>   V3FormulaNode;$/;"	t	class:V3Formula
V3GateType	ntk/v3Type.h	/^enum V3GateType {$/;"	g
V3GateTypeStr	ntk/v3Type.h	/^const string V3GateTypeStr[] = {$/;"	v
V3GenBucket	alg/v3AlgGeneralize.cpp	/^V3GenBucket::V3GenBucket(const uint32_t& maxBucket, const uint32_t& maxData) {$/;"	f	class:V3GenBucket
V3GenBucket	alg/v3AlgGeneralize.h	/^class V3GenBucket {$/;"	c
V3GenComp	alg/v3AlgGeneralize.h	/^      struct V3GenComp {$/;"	s	class:V3GenStruct
V3GenCubeList	alg/v3AlgGeneralize.h	/^      typedef V3Vec<V3UI32Set>::Vec                V3GenCubeList;$/;"	t	class:V3GenStruct
V3GenStruct	alg/v3AlgGeneralize.cpp	/^V3GenStruct::V3GenStruct(const uint32_t& varSize, const V3NetVec& baseCube) {$/;"	f	class:V3GenStruct
V3GenStruct	alg/v3AlgGeneralize.h	/^class V3GenStruct {$/;"	c
V3GenVarOrder	alg/v3AlgGeneralize.h	/^      typedef V3Set<V3GenVarPair, V3GenComp>::Set  V3GenVarOrder;$/;"	t	class:V3GenStruct
V3GenVarPair	alg/v3AlgGeneralize.h	/^      typedef pair<V3NetId, uint32_t>              V3GenVarPair;$/;"	t	class:V3GenStruct
V3Graph	adt/v3Graph.h	/^V3Graph<T>::V3Graph() { clearGraph(); }$/;"	f	class:V3Graph
V3Graph	adt/v3Graph.h	/^class V3Graph {$/;"	c
V3Handler	ntk/v3NtkHandler.cpp	/^V3Handler::V3Handler() {$/;"	f	class:V3Handler
V3Handler	ntk/v3NtkHandler.h	/^class V3Handler$/;"	c
V3HandlerVec	ntk/v3NtkHandler.h	/^typedef V3Vec<V3NtkHandler*>::Vec         V3HandlerVec;$/;"	t
V3HashMap	adt/v3Hash.h	/^struct V3HashMap {$/;"	s
V3HashSet	adt/v3Hash.h	/^struct V3HashSet {$/;"	s
V3HierSeparator	ntk/v3Type.h	/^const string V3HierSeparator  = ".";$/;"	v
V3IPDRCube	vrf/v3VrfIPDR.h	/^      V3IPDRCube(const V3IPDRCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3IPDRCube
V3IPDRCube	vrf/v3VrfIPDR.h	/^class V3IPDRCube$/;"	c
V3IPDRCubeCompare	vrf/v3VrfIPDR.h	/^struct V3IPDRCubeCompare {$/;"	s
V3IPDRCubeList	vrf/v3VrfIPDR.h	/^typedef V3Set<V3IPDRCube*, V3IPDRCubeCompare>::Set   V3IPDRCubeList;$/;"	t
V3IPDRFrame	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::V3IPDRFrame() {$/;"	f	class:V3IPDRFrame
V3IPDRFrame	vrf/v3VrfIPDR.h	/^class V3IPDRFrame$/;"	c
V3IPDRFrameVec	vrf/v3VrfIPDR.h	/^typedef V3Vec<V3IPDRFrame*>::Vec             V3IPDRFrameVec;$/;"	t
V3IPDRSvrList	vrf/v3VrfIPDR.h	/^typedef V3Vec<V3SvrBase*>::Vec               V3IPDRSvrList;$/;"	t
V3IPDRTimedCube	vrf/v3VrfIPDR.h	/^typedef pair<uint32_t, V3IPDRCube*>          V3IPDRTimedCube;$/;"	t
V3IdxStrHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<uint32_t, string>::Hash V3IdxStrHash;$/;"	t
V3IncBucketList	adt/v3Bucket.h	/^      V3IncBucketList(const uint32_t& size = 0) { _size = 0; _bestIndex = 0; _elements.clear(); init(size); }$/;"	f	class:V3IncBucketList
V3IncBucketList	adt/v3Bucket.h	/^class V3IncBucketList {$/;"	c
V3IndexField	adt/v3Graph.h	/^   typedef typename V3Vec<V3UI32Set>::Vec          V3IndexField;$/;"	t	class:V3Graph
V3IndexFlow	adt/v3Graph.h	/^   typedef typename V3Queue<V3UI32Queue>::Queue    V3IndexFlow;$/;"	t	class:V3Graph
V3InputTable	ntk/v3Ntk.h	/^typedef V3Vec<V3InputVec   >::Vec   V3InputTable;$/;"	t
V3InputVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NetType    >::Vec   V3InputVec;$/;"	t
V3IntMAX	util/v3IntType.h	/^const uint32_t V3IntMAX    = UINT_MAX;$/;"	v
V3IntVec	adt/v3Misc.h	/^typedef V3Vec<int       >::Vec   V3IntVec;$/;"	t
V3L2SAssertName	ext/v3ExtType.h	/^const string V3L2SAssertName  = V3L2SPrefix + "Assertion_";$/;"	v
V3L2SGeneralID	ext/v3ExtType.h	/^const string V3L2SGeneralID   = V3L2SPrefix + v3Int2Str(time(NULL));$/;"	v
V3L2SInLoopName	ext/v3ExtType.h	/^const string V3L2SInLoopName  = V3L2SGeneralID + "_InLoop_Latch";$/;"	v
V3L2SLatchONName	ext/v3ExtType.h	/^const string V3L2SLatchONName = V3L2SGeneralID + "_Shadow_Latch_ON";$/;"	v
V3L2SLoopedName	ext/v3ExtType.h	/^const string V3L2SLoopedName  = V3L2SGeneralID + "_Looped";$/;"	v
V3L2SOracleName	ext/v3ExtType.h	/^const string V3L2SOracleName  = V3L2SGeneralID + "_Loop_Oracle";$/;"	v
V3L2SPCheckName	ext/v3ExtType.h	/^const string V3L2SPCheckName  = V3L2SPrefix + "F_not_P_Latch_";$/;"	v
V3L2SPrefix	ext/v3ExtType.h	/^const string V3L2SPrefix      = "v3_L2S_";$/;"	v
V3L2SShadowName	ext/v3ExtType.h	/^const string V3L2SShadowName  = V3L2SPrefix + "Shadow_Latch_";$/;"	v
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(V3NtkHandler* const handler, const V3NetId& id, const bool& safe, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(V3NtkHandler* const handler, const string& ltlFormulaExp, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(const V3LTLFormula& ltlFormula, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.h	/^class V3LTLFormula$/;"	c
V3LTLFormulaList	ext/v3LTLFormula.h	/^      typedef V3Vec<V3LTLFormulaNode>::Vec   V3LTLFormulaList;$/;"	t	class:V3LTLFormula
V3LTLFormulaNode	ext/v3LTLFormula.h	/^      typedef pair<V3LTLOpType, V3PtrVec>    V3LTLFormulaNode;$/;"	t	class:V3LTLFormula
V3LTLFormulaVec	ext/v3NtkElaborate.h	/^      typedef V3Vec<V3LTLFormula*>::Vec   V3LTLFormulaVec;$/;"	t	class:V3NtkElaborate
V3LTLOpType	ext/v3LTLFormula.h	/^enum V3LTLOpType {$/;"	g
V3List	adt/v3List.h	/^struct V3List {$/;"	s
V3LivenessPrefix	ext/v3ExtType.h	/^const string V3LivenessPrefix = "v3_Liveness_";$/;"	v
V3MCEngineList	v3mc/v3MCMain.h	/^typedef V3Vec<V3MCEngineType>::Vec        V3MCEngineList;$/;"	t
V3MCEngineType	v3mc/v3MCEngine.h	/^enum V3MCEngineType$/;"	g
V3MCEngineTypeStr	v3mc/v3MCEngine.h	/^const string V3MCEngineTypeStr[] = $/;"	v
V3MCMainParam	v3mc/v3MCMain.h	/^struct V3MCMainParam$/;"	s
V3MCMainType	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	g
V3MCMainTypeStr	v3mc/v3MCMain.h	/^const string V3MCMainTypeStr[] = { "V3MC_SAFE", "V3MC_LIVE", "V3MC_L2S", "V3MC_TYPE_TOTAL" };$/;"	v
V3MCParam	v3mc/v3MCMain.h	/^struct V3MCParam$/;"	s
V3MCResource	v3mc/v3MCMain.cpp	/^V3MCResource::V3MCResource(const V3UI32Vec& c, const V3UI32Vec& p) : V3VrfShared() {$/;"	f	class:V3MCResource
V3MCResource	v3mc/v3MCMain.h	/^class V3MCResource : public V3VrfShared$/;"	c
V3MCResult	v3mc/v3MCMain.cpp	/^V3MCResult::V3MCResult(const uint32_t& size) {$/;"	f	class:V3MCResult
V3MCResult	v3mc/v3MCMain.h	/^class V3MCResult : public V3VrfShared$/;"	c
V3MC_BMC	v3mc/v3MCEngine.h	/^   V3MC_BMC,$/;"	e	enum:V3MCEngineType
V3MC_CITP	v3mc/v3MCEngine.h	/^   V3MC_CITP,$/;"	e	enum:V3MCEngineType
V3MC_CITP_F_I	v3mc/v3MCEngine.h	/^   V3MC_CITP_F_I,$/;"	e	enum:V3MCEngineType
V3MC_CITP_I	v3mc/v3MCEngine.h	/^   V3MC_CITP_I,$/;"	e	enum:V3MCEngineType
V3MC_CITP_REC	v3mc/v3MCEngine.h	/^   V3MC_CITP_REC,$/;"	e	enum:V3MCEngineType
V3MC_FITP	v3mc/v3MCEngine.h	/^   V3MC_FITP,$/;"	e	enum:V3MCEngineType
V3MC_IDLE	v3mc/v3MCEngine.h	/^   V3MC_IDLE = 0,$/;"	e	enum:V3MCEngineType
V3MC_IND	v3mc/v3MCEngine.h	/^   V3MC_IND,$/;"	e	enum:V3MCEngineType
V3MC_IPDR	v3mc/v3MCEngine.h	/^   V3MC_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_CITP	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_CITP,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_CITP_REC	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_CITP_REC,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_FITP	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_FITP,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_IPDR	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_MPDR	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_L2S	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_LIVE	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_MPDR	v3mc/v3MCEngine.h	/^   V3MC_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SAFE	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_SEC_BMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_BMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_IPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_MPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_BMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_BMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_IPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_MPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_UMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_UMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_UMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_UMC,$/;"	e	enum:V3MCEngineType
V3MC_SIM	v3mc/v3MCEngine.h	/^   V3MC_SIM,$/;"	e	enum:V3MCEngineType
V3MC_TOTAL	v3mc/v3MCEngine.h	/^   V3MC_TOTAL$/;"	e	enum:V3MCEngineType
V3MC_TYPE_TOTAL	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_UBC	v3mc/v3MCEngine.h	/^   V3MC_UBC,$/;"	e	enum:V3MCEngineType
V3MC_UMC	v3mc/v3MCEngine.h	/^   V3MC_UMC,$/;"	e	enum:V3MCEngineType
V3MPDRCube	vrf/v3VrfMPDR.h	/^      V3MPDRCube(const V3MPDRCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3MPDRCube
V3MPDRCube	vrf/v3VrfMPDR.h	/^class V3MPDRCube$/;"	c
V3MPDRCubeCompare	vrf/v3VrfMPDR.h	/^struct V3MPDRCubeCompare {$/;"	s
V3MPDRCubeList	vrf/v3VrfMPDR.h	/^typedef V3Set<V3MPDRCube*, V3MPDRCubeCompare>::Set   V3MPDRCubeList;$/;"	t
V3MPDRFrame	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::V3MPDRFrame(const V3SvrData& a) : _activator(a) {$/;"	f	class:V3MPDRFrame
V3MPDRFrame	vrf/v3VrfMPDR.h	/^class V3MPDRFrame$/;"	c
V3MPDRFrameVec	vrf/v3VrfMPDR.h	/^typedef V3Vec<V3MPDRFrame*>::Vec          V3MPDRFrameVec;$/;"	t
V3MPDRTimedCube	vrf/v3VrfMPDR.h	/^typedef pair<uint32_t, V3MPDRCube*>       V3MPDRTimedCube;$/;"	t
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(const size_t a, const size_t b) {$/;"	f
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(const string& s) {$/;"	f
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(size_t a) {$/;"	f
V3Map	adt/v3Map.h	/^struct V3Map {$/;"	s
V3MiscType	ntk/v3Type.h	/^   V3MiscType(uint32_t t = 0, uint32_t m = 0) { type = t; misc = m; }$/;"	f	struct:V3MiscType
V3MiscType	ntk/v3Type.h	/^struct V3MiscType {  \/\/ 4 Bytes$/;"	s
V3Msg	util/v3Msg.h	/^      V3Msg(ostream& os) : _default(os) { _defaultON = true; _filename = ""; }$/;"	f	class:V3Msg
V3Msg	util/v3Msg.h	/^class V3Msg$/;"	c
V3MsgMgr	util/v3Msg.h	/^      V3MsgMgr() {$/;"	f	class:V3MsgMgr
V3MsgMgr	util/v3Msg.h	/^class V3MsgMgr$/;"	c
V3MsgType	util/v3Msg.h	/^enum V3MsgType$/;"	g
V3MuxEqual	ntk/v3NtkHash.h	/^typedef V3PairHashEqual<uint64_t, uint32_t>  V3MuxEqual;$/;"	t
V3MuxFcn	ntk/v3NtkHash.h	/^typedef V3PairHashFcn<uint64_t, uint32_t>    V3MuxFcn;$/;"	t
V3MuxHash	ntk/v3NtkHash.h	/^typedef V3HashMap<V3MuxKey,   V3NetId, V3MuxFcn, V3MuxEqual>::Hash   V3MuxHash;$/;"	t
V3MuxKey	ntk/v3NtkHash.h	/^typedef pair<uint64_t, uint32_t>             V3MuxKey;$/;"	t
V3MuxNetType2HashKey	ntk/v3NtkHash.h	/^inline const V3MuxKey V3MuxNetType2HashKey(const V3NetType& fId, const V3NetType& tId, const V3NetType& sId) {$/;"	f
V3NameBitPrefix	ntk/v3Type.h	/^const string V3NameBitPrefix  = "[";$/;"	v
V3NameBitSuffix	ntk/v3Type.h	/^const string V3NameBitSuffix  = "]";$/;"	v
V3NameInvPrefix	ntk/v3Type.h	/^const string V3NameInvPrefix  = "~";$/;"	v
V3NetId	ntk/v3Type.h	/^struct V3NetId {  \/\/ 4 Bytes$/;"	s
V3NetList	alg/v3AlgGeneralize.h	/^typedef V3List<V3NetId>::List    V3NetList;$/;"	t
V3NetNamePrefix	ntk/v3Type.h	/^const string V3NetNamePrefix  = "v3_Internal_Net_";$/;"	v
V3NetStrHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<uint32_t, string>::Hash V3NetStrHash;$/;"	t
V3NetTable	ntk/v3Ntk.h	/^typedef V3Vec<V3NetVec     >::Vec   V3NetTable;$/;"	t
V3NetType	ntk/v3Type.h	/^   V3NetType(const V3NetId& i) { id = i; }$/;"	f	union:V3NetType
V3NetType	ntk/v3Type.h	/^   V3NetType(uint32_t i = V3NtkUD) { value = i; }$/;"	f	union:V3NetType
V3NetType	ntk/v3Type.h	/^union V3NetType {  \/\/ 4 Bytes$/;"	u
V3NetType2HashKey	ntk/v3NtkHash.h	/^inline const uint32_t V3NetType2HashKey(const V3NetType& id) { return id.value; }$/;"	f
V3NetUD	ntk/v3Ntk.h	/^const V3NetId        V3NetUD = V3NetId::makeNetId();$/;"	v
V3NetVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NetId      >::Vec   V3NetVec;$/;"	t
V3NodeField	adt/v3Graph.h	/^   typedef typename V3Vec<V3NodeSet>::Vec          V3NodeField;$/;"	t	class:V3Graph
V3NodeFlow	adt/v3Graph.h	/^   typedef typename V3Stack<V3NodeLayer>::Stack    V3NodeFlow;$/;"	t	class:V3Graph
V3NodeIndexMap	adt/v3Graph.h	/^   typedef typename V3HashMap<T, uint32_t>::Hash   V3NodeIndexMap;$/;"	t	class:V3Graph
V3NodeLayer	adt/v3Graph.h	/^   typedef typename V3Queue<T>::Queue              V3NodeLayer;$/;"	t	class:V3Graph
V3NodeSet	adt/v3Graph.h	/^   typedef typename V3Set<T>::Set                  V3NodeSet;$/;"	t	class:V3Graph
V3NodeStack	adt/v3Graph.h	/^   typedef typename V3Stack<T>::Stack              V3NodeStack;$/;"	t	class:V3Graph
V3NodeVec	adt/v3Graph.h	/^   typedef typename V3Vec<V3DirectedNode>::Vec     V3NodeVec;$/;"	t	class:V3Graph
V3Ntk	ntk/v3Ntk.cpp	/^V3Ntk::V3Ntk() {$/;"	f	class:V3Ntk
V3Ntk	ntk/v3Ntk.h	/^class V3Ntk$/;"	c
V3NtkElaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::V3NtkElaborate(V3NtkHandler* const handler, const V3NetVec& targetNets)$/;"	f	class:V3NtkElaborate
V3NtkElaborate	ext/v3NtkElaborate.h	/^class V3NtkElaborate : public V3NtkHandler$/;"	c
V3NtkExpand	trans/v3NtkExpand.cpp	/^V3NtkExpand::V3NtkExpand(V3NtkHandler* const p, const uint32_t& cycle, const bool& init)$/;"	f	class:V3NtkExpand
V3NtkExpand	trans/v3NtkExpand.h	/^class V3NtkExpand : public V3NtkHandler$/;"	c
V3NtkFlatten	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::V3NtkFlatten(V3NtkHandler* const handler, const uint32_t& level) : V3NtkHandler(handler) {$/;"	f	class:V3NtkFlatten
V3NtkFlatten	trans/v3NtkFlatten.h	/^class V3NtkFlatten : public V3NtkHandler$/;"	c
V3NtkFromQuteRTL	io/v3NtkQuteRTL.cpp	/^V3NtkInput* const V3NtkFromQuteRTL(const char* fileName, const bool& isFileList, const bool& toFlatten, const bool& async2sync) {$/;"	f
V3NtkHandler	ntk/v3NtkHandler.cpp	/^V3NtkHandler::V3NtkHandler(V3NtkHandler* const p, V3Ntk* const ntk) : _handler(p) {$/;"	f	class:V3NtkHandler
V3NtkHandler	ntk/v3NtkHandler.h	/^class V3NtkHandler$/;"	c
V3NtkHierData	ntk/v3NtkHandler.h	/^            V3NtkHierData(V3NtkHandler* const n, const uint32_t& p) : _handler(n), _parentId(p) { _p2cMap.clear(); }$/;"	f	class:V3NtkHierInfo::V3NtkHierData
V3NtkHierData	ntk/v3NtkHandler.h	/^      class V3NtkHierData {$/;"	c	class:V3NtkHierInfo
V3NtkHierInfo	ntk/v3NtkHandler.h	/^      V3NtkHierInfo() { _hierInfo.clear(); _refIdMap.clear(); }$/;"	f	class:V3NtkHierInfo
V3NtkHierInfo	ntk/v3NtkHandler.h	/^class V3NtkHierInfo {$/;"	c
V3NtkInput	ntk/v3NtkInput.cpp	/^V3NtkInput::V3NtkInput(const bool& isAig, const string& name) : V3NtkHandler(0, createV3Ntk(!isAig)) {$/;"	f	class:V3NtkInput
V3NtkInput	ntk/v3NtkInput.h	/^class V3NtkInput : public V3NtkHandler$/;"	c
V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::V3NtkMiter(V3NtkHandler* const p1, V3NtkHandler* const p2, const V3UI32Vec& latchMap, const bool& merge, const string& n) $/;"	f	class:V3NtkMiter
V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::V3NtkMiter(V3NtkHandler* const p1, V3NtkHandler* const p2, const bool& merge, const string& n) $/;"	f	class:V3NtkMiter
V3NtkMiter	trans/v3NtkMiter.h	/^class V3NtkMiter : public V3NtkHandler$/;"	c
V3NtkModule	ntk/v3Ntk.h	/^      V3NtkModule(const V3NetVec& i, const V3NetVec& o) { _ref = 0; _inputs = i; _outputs = o; }$/;"	f	class:V3NtkModule
V3NtkModule	ntk/v3Ntk.h	/^class V3NtkModule$/;"	c
V3NtkModuleVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NtkModule* >::Vec   V3NtkModuleVec;$/;"	t
V3NtkSimplify	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::V3NtkSimplify(V3NtkHandler* const handler) : V3NtkHandler(handler) {$/;"	f	class:V3NtkSimplify
V3NtkSimplify	ntk/v3NtkSimplify.h	/^class V3NtkSimplify : public V3NtkHandler$/;"	c
V3NtkUD	ntk/v3Type.h	/^const uint32_t V3NtkUD     = V3IntMAX;$/;"	v
V3OperatorMap	ext/v3Formula.h	/^typedef V3Map<string, pair<uint32_t, V3GateType> >::Map  V3OperatorMap;$/;"	t
V3OrderedNetType2HashKey	ntk/v3NtkHash.h	/^inline const uint64_t V3OrderedNetType2HashKey(const V3NetType& id1, const V3NetType& id2) {$/;"	f
V3PairHashEqual	adt/v3Hash.h	/^struct V3PairHashEqual {$/;"	s
V3PairHashFcn	adt/v3Hash.h	/^struct V3PairHashFcn {$/;"	s
V3PairType	ntk/v3Type.h	/^   V3PairType(uint32_t m, uint32_t l) { bus[0] = m; bus[1] = l; }$/;"	f	struct:V3PairType
V3PairType	ntk/v3Type.h	/^   V3PairType(uint64_t p) { pair = p; }$/;"	f	struct:V3PairType
V3PairType	ntk/v3Type.h	/^struct V3PairType {  \/\/ 8 Bytes$/;"	s
V3PlotNtkByDepth	io/v3NtkWriter.cpp	/^void V3PlotNtkByDepth(const V3NtkHandler* const handler, const char* fileName, const uint32_t& maxDepth, const V3NetVec& rootNets, const bool& monoChrome) {$/;"	f
V3PlotNtkByLevel	io/v3NtkWriter.cpp	/^void V3PlotNtkByLevel(const V3NtkHandler* const handler, const char* fileName, const uint32_t& maxLevel, const V3NetVec& rootNets, const bool& monoChrome) {$/;"	f
V3PortableType	adt/v3Misc.h	/^      V3PortableType(const uint32_t& s = 0, const uint32_t& f = 0) : _size(s), _shift(f) {$/;"	f	class:V3PortableType
V3PortableType	adt/v3Misc.h	/^class V3PortableType {$/;"	c
V3Property	ext/v3Property.cpp	/^V3Property::V3Property(V3LTLFormula* const formula) : _formula(formula) {$/;"	f	class:V3Property
V3Property	ext/v3Property.h	/^class V3Property$/;"	c
V3PropertyMap	ntk/v3NtkHandler.h	/^typedef V3Map<string, V3Property*>::Map   V3PropertyMap;$/;"	t
V3PropertyPrefix	ext/v3ExtType.h	/^const string V3PropertyPrefix = "P_";$/;"	v
V3PtrVec	adt/v3Misc.h	/^typedef V3Vec<size_t    >::Vec   V3PtrVec;$/;"	t
V3Queue	adt/v3Queue.h	/^struct V3Queue {$/;"	s
V3QuteRTLClockHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLClockHandler(V3NtkInput* const quteHandler, const V3NetVec& piList, V3NetVec& inputs) {$/;"	f
V3QuteRTLFFHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLFFHandler(V3NtkInput* const quteHandler, CktModule* const module, const bool& async2sync, V3NetVec& inputs) {$/;"	f
V3QuteRTLHandler	io/v3NtkQuteRTL.cpp	/^V3NtkInput* const V3QuteRTLHandler(CktModule* const& module, const bool& async2sync, V3NetVec& inputs, const string& instName) {$/;"	f
V3QuteRTLInputHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLInputHandler(V3NtkInput* const quteHandler, CktModule* const module, V3NetVec& piList) {$/;"	f
V3QuteRTLOutputHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLOutputHandler(V3NtkInput* const quteHandler, CktModule* const module, const bool& async2sync) {$/;"	f
V3RTLName	io/v3NtkWriter.h	18;"	d
V3RTLNameBase	io/v3NtkWriter.h	19;"	d
V3RTLNameById	io/v3NtkWriter.h	21;"	d
V3RTLNameOrId	io/v3NtkWriter.h	20;"	d
V3RTLParser	io/v3RTLParser.cpp	/^V3NtkInput* const V3RTLParser(const char* fileName) {$/;"	f
V3RTLSplitToken	io/v3RTLParser.cpp	/^typedef V3Vec<char>::Vec      V3RTLSplitToken;$/;"	t	file:
V3RTLWriter	io/v3RTLWriter.cpp	/^const bool V3RTLWriter(const V3NtkHandler* const handler, ofstream& output, const bool& symbol, const bool& initial, string prefix, V3StrVec& ioName) {$/;"	f
V3RTLWriter	io/v3RTLWriter.cpp	/^void V3RTLWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol, const bool& initial) {$/;"	f
V3RepIdHash	ntk/v3Ntk.h	/^typedef V3HashMap<uint32_t,   V3NetId>::Hash V3RepIdHash;$/;"	t
V3SDG	stg/v3StgSDG.cpp	/^V3SDG::V3SDG(V3NtkHandler* const handler) : _handler(handler) {$/;"	f	class:V3SDG
V3SDG	stg/v3StgSDG.h	/^class V3SDG {$/;"	c
V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::V3SDGBase() {$/;"	f	class:V3SDGBase
V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::V3SDGBase(const V3SDGBase& node) {$/;"	f	class:V3SDGBase
V3SDGBase	stg/v3StgSDG.h	/^class V3SDGBase {$/;"	c
V3SDGClusters	stg/v3StgExtract.h	/^      typedef V3Vec<V3UI32Set>::Vec    V3SDGClusters;$/;"	t	class:V3FSMExtract
V3SDGMUX	stg/v3StgSDG.cpp	/^V3SDGMUX::V3SDGMUX(const V3NetId& id) : V3SDGNode(id), _tBase(new V3SDGBase()), _fBase(new V3SDGBase()) {$/;"	f	class:V3SDGMUX
V3SDGMUX	stg/v3StgSDG.h	/^class V3SDGMUX : public V3SDGNode {$/;"	c
V3SDGNode	stg/v3StgSDG.cpp	/^V3SDGNode::V3SDGNode(const V3NetId& id) : _netId(id), _base(new V3SDGBase()) {$/;"	f	class:V3SDGNode
V3SDGNode	stg/v3StgSDG.h	/^class V3SDGNode {$/;"	c
V3SDGNodeList	stg/v3StgSDG.h	/^typedef V3Vec<V3SDGNode*>::Vec   V3SDGNodeList;$/;"	t
V3SafeAdd	util/v3NumUtil.h	/^inline bool V3SafeAdd(T& a, const T b) {$/;"	f
V3SafeAdd	util/v3NumUtil.h	/^inline bool V3SafeAdd(const T a, const T b, T& c) {$/;"	f
V3SafeMult	util/v3NumUtil.h	/^inline bool V3SafeMult(T& a, const T b) {$/;"	f
V3SafeMult	util/v3NumUtil.h	/^inline bool V3SafeMult(const T a, const T b, T& c) {$/;"	f
V3SafetyPrefix	ext/v3ExtType.h	/^const string V3SafetyPrefix   = "v3_Safety_";$/;"	v
V3Set	adt/v3Set.h	/^struct V3Set {$/;"	s
V3SimTrace	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecX>::Vec             V3SimTrace;$/;"	t
V3SimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3SimTrace>::Vec            V3SimTraceVec;$/;"	t
V3SolverType	svr/v3SvrHandler.h	/^enum V3SolverType$/;"	g
V3SolverTypeStr	svr/v3SvrHandler.h	/^const string V3SolverTypeStr[] = $/;"	v
V3Stack	adt/v3Stack.h	/^struct V3Stack {$/;"	s
V3Stat	util/v3Usage.h	/^      V3Stat(const string& name, V3Stat* const ref = 0) : _statName(name), _refStat(ref) {$/;"	f	class:V3Stat
V3Stat	util/v3Usage.h	/^class V3Stat$/;"	c
V3Str2BoolFuncPtr	ntk/v3NtkInput.h	/^typedef const bool(*V3Str2BoolFuncPtr) (const string&);$/;"	t
V3StrIdxHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<string, uint32_t>::Hash V3StrIdxHash;$/;"	t
V3StrNetHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<string, V3NetId>::Hash  V3StrNetHash;$/;"	t
V3StrSet	adt/v3Misc.h	/^typedef V3Set<string    >::Set   V3StrSet;$/;"	t
V3StrTable	adt/v3Misc.h	/^typedef V3Vec<V3StrVec  >::Vec   V3StrTable;$/;"	t
V3StrVec	adt/v3Misc.h	/^typedef V3Vec<string    >::Vec   V3StrVec;$/;"	t
V3StringVec	ntk/v3NtkInput.h	/^typedef V3Vec<string     >::Vec  V3StringVec;$/;"	t
V3SvrBase	svr/v3SvrBase.cpp	/^V3SvrBase::V3SvrBase(const V3Ntk* const ntk, const bool& freeBound) : _ntk(ntk), _freeBound(freeBound) {$/;"	f	class:V3SvrBase
V3SvrBase	svr/v3SvrBase.h	/^class V3SvrBase$/;"	c
V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::V3SvrBoolector(const V3Ntk* const ntk, const bool& freeBound) : V3SvrBase(ntk, freeBound) {$/;"	f	class:V3SvrBoolector
V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::V3SvrBoolector(const V3SvrBoolector& solver) : V3SvrBase(solver._ntk, solver._freeBound) {$/;"	f	class:V3SvrBoolector
V3SvrBoolector	svr/v3SvrBoolector.h	/^class V3SvrBoolector : public V3SvrBase$/;"	c
V3SvrData	svr/v3SvrType.h	/^typedef size_t                      V3SvrData;$/;"	t
V3SvrDataSet	svr/v3SvrType.h	/^typedef V3Set<V3SvrData>::Set       V3SvrDataSet;$/;"	t
V3SvrDataTable	svr/v3SvrType.h	/^typedef V3Vec<V3SvrDataVec>::Vec    V3SvrDataTable;$/;"	t
V3SvrDataVec	pdr/v3SvrPDRSat.h	/^typedef V3Vec<size_t>::Vec      V3SvrDataVec;$/;"	t
V3SvrDataVec	svr/v3SvrType.h	/^typedef V3Vec<V3SvrData>::Vec       V3SvrDataVec;$/;"	t
V3SvrMLitData	pdr/v3SvrPDRSat.h	/^typedef V3Vec<Lit>::Vec         V3SvrMLitData;$/;"	t
V3SvrMLitData	svr/v3SvrType.h	/^typedef V3Vec<Lit>::Vec             V3SvrMLitData;$/;"	t
V3SvrMVarData	pdr/v3SvrPDRSat.h	/^typedef V3Vec<Var>::Vec         V3SvrMVarData;$/;"	t
V3SvrMVarData	svr/v3SvrType.h	/^typedef V3Vec<Var>::Vec             V3SvrMVarData;$/;"	t
V3SvrMVarTable	svr/v3SvrType.h	/^typedef V3Vec<V3SvrMVarData>::Vec   V3SvrMVarTable;$/;"	t
V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::V3SvrMiniSat(const V3Ntk* const ntk, const bool& freeBound) : V3SvrBase(ntk, freeBound) {$/;"	f	class:V3SvrMiniSat
V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::V3SvrMiniSat(const V3SvrMiniSat& solver) : V3SvrBase(solver._ntk, solver._freeBound) {$/;"	f	class:V3SvrMiniSat
V3SvrMiniSat	svr/v3SvrMiniSat.h	/^class V3SvrMiniSat : public V3SvrBase$/;"	c
V3SvrPDRSat	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::V3SvrPDRSat(V3Ntk* ntk, const bool& freeBound, const bool& proofLog) $/;"	f	class:V3SvrPDRSat
V3SvrPDRSat	pdr/v3SvrPDRSat.h	/^class V3SvrPDRSat$/;"	c
V3TraceSimplify	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::V3TraceSimplify(V3NtkHandler* const handler, const V3CexTrace& cex) : _handler(handler) {$/;"	f	class:V3TraceSimplify
V3TraceSimplify	dfx/v3DfxSimplify.h	/^class V3TraceSimplify$/;"	c
V3TypeBTOR	io/v3BtorWriter.cpp	/^const string V3TypeBTOR[] = {$/;"	v
V3TypeRTL	io/v3RTLWriter.cpp	/^const string V3TypeRTL[] = {$/;"	v
V3TypeVec	ntk/v3Ntk.h	/^typedef V3Vec<V3MiscType   >::Vec   V3TypeVec;$/;"	t
V3UI32Hash	ntk/v3NtkHash.h	/^typedef V3HashMap<uint32_t,   V3NetId                      >::Hash   V3UI32Hash;$/;"	t
V3UI32LessOrEq	adt/v3Misc.h	/^struct V3UI32LessOrEq { const bool operator() (const T& i, const T& j) const { return i <= j; } };$/;"	s
V3UI32Queue	adt/v3Misc.h	/^typedef V3Queue<uint32_t>::Queue V3UI32Queue;$/;"	t
V3UI32Set	adt/v3Misc.h	/^typedef V3Set<uint32_t  >::Set   V3UI32Set;$/;"	t
V3UI32Stack	adt/v3Misc.h	/^typedef V3Stack<uint32_t>::Stack V3UI32Stack;$/;"	t
V3UI32Table	adt/v3Misc.h	/^typedef V3Vec<V3UI32Vec >::Vec   V3UI32Table;$/;"	t
V3UI32Vec	adt/v3Misc.h	/^typedef V3Vec<uint32_t  >::Vec   V3UI32Vec;$/;"	t
V3UI64Hash	ntk/v3NtkHash.h	/^typedef V3HashMap<uint64_t,   V3NetId                      >::Hash   V3UI64Hash;$/;"	t
V3UI64LSB	ntk/v3Type.h	24;"	d
V3UI64MSB	ntk/v3Type.h	23;"	d
V3UI64Pair	ntk/v3Type.h	22;"	d
V3UI64Type	ntk/v3Type.h	21;"	d
V3UI64Vec	adt/v3Misc.h	/^typedef V3Vec<uint64_t  >::Vec   V3UI64Vec;$/;"	t
V3UnorderedNetType2HashKey	ntk/v3NtkHash.h	/^inline const uint64_t V3UnorderedNetType2HashKey(const V3NetType& id1, const V3NetType& id2) {$/;"	f
V3Usage	util/v3Usage.h	/^      V3Usage() {$/;"	f	class:V3Usage
V3Usage	util/v3Usage.h	/^class V3Usage $/;"	c
V3Vec	adt/v3Vec.h	/^struct V3Vec {$/;"	s
V3VrfBMC	vrf/v3VrfBMC.cpp	/^V3VrfBMC::V3VrfBMC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfBMC
V3VrfBMC	vrf/v3VrfBMC.h	/^class V3VrfBMC : public V3VrfBase$/;"	c
V3VrfBase	vrf/v3VrfBase.cpp	/^V3VrfBase::V3VrfBase(const V3NtkHandler* const handler) {$/;"	f	class:V3VrfBase
V3VrfBase	vrf/v3VrfBase.h	/^class V3VrfBase$/;"	c
V3VrfCITP	vrf/v3VrfCITP.cpp	/^V3VrfCITP::V3VrfCITP(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfCITP
V3VrfCITP	vrf/v3VrfCITP.h	/^class V3VrfCITP : public V3VrfBase$/;"	c
V3VrfFITP	vrf/v3VrfFITP.cpp	/^V3VrfFITP::V3VrfFITP(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfFITP
V3VrfFITP	vrf/v3VrfFITP.h	/^class V3VrfFITP : public V3VrfBase$/;"	c
V3VrfIPDR	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::V3VrfIPDR(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfIPDR
V3VrfIPDR	vrf/v3VrfIPDR.h	/^class V3VrfIPDR : public V3VrfBase$/;"	c
V3VrfKLive	vrf/v3VrfKLive.cpp	/^V3VrfKLive::V3VrfKLive(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfKLive
V3VrfKLive	vrf/v3VrfKLive.h	/^class V3VrfKLive : public V3VrfBase$/;"	c
V3VrfMPDR	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::V3VrfMPDR(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfMPDR
V3VrfMPDR	vrf/v3VrfMPDR.h	/^class V3VrfMPDR : public V3VrfBase$/;"	c
V3VrfResult	ext/v3Property.h	/^      V3VrfResult() { _cexOrInv = 0; }$/;"	f	class:V3VrfResult
V3VrfResult	ext/v3Property.h	/^class V3VrfResult$/;"	c
V3VrfResultVec	vrf/v3VrfShared.h	/^typedef V3Vec<V3VrfResult>::Vec  V3VrfResultVec;$/;"	t
V3VrfSEC	vrf/v3VrfSEC.cpp	/^V3VrfSEC::V3VrfSEC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfSEC
V3VrfSEC	vrf/v3VrfSEC.h	/^class V3VrfSEC : public V3VrfBase$/;"	c
V3VrfSIM	vrf/v3VrfSIM.cpp	/^V3VrfSIM::V3VrfSIM(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfSIM
V3VrfSIM	vrf/v3VrfSIM.h	/^class V3VrfSIM : public V3VrfBase$/;"	c
V3VrfShared	vrf/v3VrfShared.h	/^      V3VrfShared() { pthread_mutex_init(&_mutex, NULL); }$/;"	f	class:V3VrfShared
V3VrfShared	vrf/v3VrfShared.h	/^class V3VrfShared$/;"	c
V3VrfSharedBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::V3VrfSharedBound(const uint32_t& size, const bool& print) : _print(print) {$/;"	f	class:V3VrfSharedBound
V3VrfSharedBound	vrf/v3VrfShared.h	/^class V3VrfSharedBound : public V3VrfShared$/;"	c
V3VrfSharedInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::V3VrfSharedInv() {$/;"	f	class:V3VrfSharedInv
V3VrfSharedInv	vrf/v3VrfShared.h	/^class V3VrfSharedInv : public V3VrfShared$/;"	c
V3VrfSharedMem	vrf/v3VrfShared.h	/^      V3VrfSharedMem(const double& m) : V3VrfShared() { _maxMemory = m; }$/;"	f	class:V3VrfSharedMem
V3VrfSharedMem	vrf/v3VrfShared.h	/^class V3VrfSharedMem : public V3VrfShared$/;"	c
V3VrfSharedNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::V3VrfSharedNtk() {$/;"	f	class:V3VrfSharedNtk
V3VrfSharedNtk	vrf/v3VrfShared.h	/^class V3VrfSharedNtk : public V3VrfShared$/;"	c
V3VrfSharedNtkData	vrf/v3VrfShared.h	/^      struct V3VrfSharedNtkData$/;"	s	class:V3VrfSharedNtk
V3VrfSimTraceVec	vrf/v3VrfSEC.h	/^typedef V3Vec<V3SimTrace>::Vec   V3VrfSimTraceVec;$/;"	t
V3VrfUMC	vrf/v3VrfUMC.cpp	/^V3VrfUMC::V3VrfUMC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfUMC
V3VrfUMC	vrf/v3VrfUMC.h	/^class V3VrfUMC : public V3VrfBase$/;"	c
V3_ADT_HASH_H	adt/v3Hash.h	10;"	d
V3_ADT_LIST_H	adt/v3List.h	10;"	d
V3_ADT_MAP_H	adt/v3Map.h	10;"	d
V3_ADT_QUEUE_H	adt/v3Queue.h	10;"	d
V3_ADT_SET_H	adt/v3Set.h	10;"	d
V3_ADT_STACK_H	adt/v3Stack.h	10;"	d
V3_ADT_VEC_H	adt/v3Vec.h	10;"	d
V3_AIG_PARSER_C	io/v3AigParser.cpp	10;"	d	file:
V3_AIG_WRITER_H	io/v3AigWriter.cpp	10;"	d	file:
V3_ALG_CMD_C	alg/v3AlgCmd.cpp	10;"	d	file:
V3_ALG_CMD_H	alg/v3AlgCmd.h	10;"	d
V3_ALG_GENERALIZE_C	alg/v3AlgGeneralize.cpp	10;"	d	file:
V3_ALG_GENERALIZE_H	alg/v3AlgGeneralize.h	10;"	d
V3_ALG_SIMULATE_C	alg/v3AlgSimulate.cpp	10;"	d	file:
V3_ALG_SIMULATE_H	alg/v3AlgSimulate.h	10;"	d
V3_ALG_SIM_C	alg/v3AlgSim.cpp	10;"	d	file:
V3_ALG_SIM_H	alg/v3AlgSim.h	10;"	d
V3_ALG_TYPE_H	alg/v3AlgType.h	10;"	d
V3_BIT_VEC_C	adt/v3BitVec.cpp	10;"	d	file:
V3_BIT_VEC_H	adt/v3BitVec.h	10;"	d
V3_BTOR_PARSER_C	io/v3BtorParser.cpp	10;"	d	file:
V3_BTOR_WRITER_H	io/v3BtorWriter.cpp	10;"	d	file:
V3_BUCKET_H	adt/v3Bucket.h	10;"	d
V3_BV0	adt/v3BitVec.cpp	/^static const unsigned char V3_BV0   = '0';$/;"	v	file:
V3_BV1	adt/v3BitVec.cpp	/^static const unsigned char V3_BV1   = '1';$/;"	v	file:
V3_BVX	adt/v3BitVec.cpp	/^static const unsigned char V3_BVX   = 'X';$/;"	v	file:
V3_BV_BLAST_AIG_C	trans/v3BvBlastAig.cpp	10;"	d	file:
V3_BV_BLAST_AIG_H	trans/v3BvBlastAig.h	10;"	d
V3_BV_BLAST_AIG_HELPER_H	trans/v3BvBlastAigHelper.h	10;"	d
V3_BV_BLAST_BV_C	trans/v3BvBlastBv.cpp	10;"	d	file:
V3_BV_BLAST_BV_H	trans/v3BvBlastBv.h	10;"	d
V3_CITP_IMPROVED_RECYCLE	vrf/v3VrfCITP.cpp	25;"	d	file:
V3_CMD_COMM_C	cmd/v3CmdComm.cpp	10;"	d	file:
V3_CMD_COMM_H	cmd/v3CmdComm.h	10;"	d
V3_CMD_MGR_C	cmd/v3CmdMgr.cpp	10;"	d	file:
V3_CMD_MGR_H	cmd/v3CmdMgr.h	10;"	d
V3_COMMAND	cmd/v3CmdMgr.h	86;"	d
V3_DFX_CMD_C	dfx/v3DfxCmd.cpp	10;"	d	file:
V3_DFX_CMD_H	dfx/v3DfxCmd.h	10;"	d
V3_DFX_SIMPLIFY_C	dfx/v3DfxSimplify.cpp	10;"	d	file:
V3_DFX_SIMPLIFY_H	dfx/v3DfxSimplify.h	10;"	d
V3_DFX_TRACE_C	dfx/v3DfxTrace.cpp	10;"	d	file:
V3_DFX_TRACE_H	dfx/v3DfxTrace.h	10;"	d
V3_DFX_TRACE_RESTRICT_X	dfx/v3DfxTrace.cpp	19;"	d	file:
V3_EXT_ELABORATE_C	ext/v3ExtElaborate.cpp	10;"	d	file:
V3_EXT_IO_C	ext/v3ExtIO.cpp	10;"	d	file:
V3_EXT_TYPE_H	ext/v3ExtType.h	10;"	d
V3_EXT_UTIL_H	ext/v3ExtUtil.h	10;"	d
V3_FF	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_FILE_UTIL_H	util/v3FileUtil.h	10;"	d
V3_FITP_IMPROVED_RECYCLE	vrf/v3VrfFITP.cpp	26;"	d	file:
V3_FORMULA_C	ext/v3Formula.cpp	10;"	d	file:
V3_FORMULA_H	ext/v3Formula.h	10;"	d
V3_GATE_TOTAL	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
V3_GRAPH_H	adt/v3Graph.h	10;"	d
V3_HASH_H	util/v3HashUtil.h	10;"	d
V3_INDENT	ntk/v3Type.h	/^const string   V3_INDENT   = "   ";$/;"	v
V3_INT_TYPE_H	util/v3IntType.h	10;"	d
V3_IPDR_USE_PROPAGATE_LOW_COST	vrf/v3VrfIPDR.cpp	19;"	d	file:
V3_LTL_FORMULA_C	ext/v3LTLFormula.cpp	10;"	d	file:
V3_LTL_FORMULA_H	ext/v3LTLFormula.h	10;"	d
V3_LTL_L_AND	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_L_IMPLY	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_L_NEG	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_P	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_TOTAL	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_T_F	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_G	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_R	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_U	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_X	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_MAIN_C	main/main.cpp	10;"	d	file:
V3_MC_AIGER_C	v3mc/v3MCAiger.cpp	10;"	d	file:
V3_MC_CMD_C	v3mc/v3MCCmd.cpp	10;"	d	file:
V3_MC_CMD_H	v3mc/v3MCCmd.h	10;"	d
V3_MC_ELABORATE_C	v3mc/v3MCElaborate.cpp	10;"	d	file:
V3_MC_ENGINE_C	v3mc/v3MCEngine.cpp	10;"	d	file:
V3_MC_ENGINE_H	v3mc/v3MCEngine.h	10;"	d
V3_MC_MAIN_C	v3mc/v3MCMain.cpp	10;"	d	file:
V3_MC_MAIN_H	v3mc/v3MCMain.h	10;"	d
V3_MC_PROP_C	v3mc/v3MCProp.cpp	10;"	d	file:
V3_MC_REORDER_C	v3mc/v3MCReorder.cpp	10;"	d	file:
V3_MC_REPORT_C	v3mc/v3MCReport.cpp	10;"	d	file:
V3_MISC_H	adt/v3Misc.h	10;"	d
V3_MODULE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_MPDR_USE_PROPAGATE_LOW_COST	vrf/v3VrfMPDR.cpp	21;"	d	file:
V3_MSG_H	util/v3Msg.h	10;"	d
V3_NTK_C	ntk/v3Ntk.cpp	10;"	d	file:
V3_NTK_C	ntk/v3NtkBdd.cpp	10;"	d	file:
V3_NTK_CMD_C	ntk/v3NtkCmd.cpp	10;"	d	file:
V3_NTK_CMD_H	ntk/v3NtkCmd.h	10;"	d
V3_NTK_CONSTRUCT_C	ntk/v3NtkConstruct.cpp	10;"	d	file:
V3_NTK_DUPLICATE_C	ntk/v3NtkDuplicate.cpp	10;"	d	file:
V3_NTK_ELABORATE_C	ext/v3NtkElaborate.cpp	10;"	d	file:
V3_NTK_ELABORATE_H	ext/v3NtkElaborate.h	10;"	d
V3_NTK_EXPAND_C	trans/v3NtkExpand.cpp	10;"	d	file:
V3_NTK_EXPAND_H	trans/v3NtkExpand.h	10;"	d
V3_NTK_FLATTEN_C	trans/v3NtkFlatten.cpp	10;"	d	file:
V3_NTK_FLATTEN_H	trans/v3NtkFlatten.h	10;"	d
V3_NTK_H	ntk/v3Ntk.h	10;"	d
V3_NTK_HANDLER_C	ntk/v3NtkHandler.cpp	10;"	d	file:
V3_NTK_HANDLER_H	ntk/v3NtkHandler.h	10;"	d
V3_NTK_HASH_H	ntk/v3NtkHash.h	10;"	d
V3_NTK_INPUT_C	ntk/v3NtkInput.cpp	10;"	d	file:
V3_NTK_INPUT_H	ntk/v3NtkInput.h	10;"	d
V3_NTK_MITER_C	trans/v3NtkMiter.cpp	10;"	d	file:
V3_NTK_MITER_H	trans/v3NtkMiter.h	10;"	d
V3_NTK_PARSER_H	io/v3NtkParser.h	10;"	d
V3_NTK_QUTERTL_C	io/v3NtkQuteRTL.cpp	10;"	d	file:
V3_NTK_REWRITE_C	ntk/v3NtkRewrite.cpp	10;"	d	file:
V3_NTK_REWRITE_H	ntk/v3NtkRewrite.h	10;"	d
V3_NTK_SIMPLIFY_C	ntk/v3NtkSimplify.cpp	10;"	d	file:
V3_NTK_SIMPLIFY_H	ntk/v3NtkSimplify.h	10;"	d
V3_NTK_STRASH_C	ntk/v3NtkStrash.cpp	10;"	d	file:
V3_NTK_STRASH_H	ntk/v3NtkStrash.h	10;"	d
V3_NTK_TRAVERSE_C	ntk/v3NtkTraverse.cpp	10;"	d	file:
V3_NTK_UTIL_H	ntk/v3NtkUtil.h	10;"	d
V3_NTK_WRITER_C	io/v3NtkWriter.cpp	10;"	d	file:
V3_NTK_WRITER_H	io/v3NtkWriter.h	10;"	d
V3_NUM_UTIL_H	util/v3NumUtil.h	10;"	d
V3_PI	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_PIO	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_PROPERTY_C	ext/v3Property.cpp	10;"	d	file:
V3_PROPERTY_H	ext/v3Property.h	10;"	d
V3_REWRITE_CONST_PROP_ENABLED	ntk/v3NtkRewrite.cpp	18;"	d	file:
V3_REWRITE_STRASH_DUAL_REPR	ntk/v3NtkRewrite.cpp	17;"	d	file:
V3_RTL_PARSER_C	io/v3RTLParser.cpp	10;"	d	file:
V3_RTL_WRITER_H	io/v3RTLWriter.cpp	10;"	d	file:
V3_SIM_GENERALIZATION_EARLY_QUIT	alg/v3AlgGeneralize.cpp	17;"	d	file:
V3_STG_CMD_C	stg/v3StgCmd.cpp	10;"	d	file:
V3_STG_CMD_H	stg/v3StgCmd.h	10;"	d
V3_STG_EXTRACT_C	stg/v3StgExtract.cpp	10;"	d	file:
V3_STG_EXTRACT_H	stg/v3StgExtract.h	10;"	d
V3_STG_FSM_C	stg/v3StgFSM.cpp	10;"	d	file:
V3_STG_FSM_H	stg/v3StgFSM.h	10;"	d
V3_STG_SDG_C	stg/v3StgSDG.cpp	10;"	d	file:
V3_STG_SDG_H	stg/v3StgSDG.h	10;"	d
V3_STR_UTIL_C	util/v3StrUtil.cpp	10;"	d	file:
V3_STR_UTIL_H	util/v3StrUtil.h	10;"	d
V3_SVR_BASE_C	svr/v3SvrBase.cpp	10;"	d	file:
V3_SVR_BASE_H	svr/v3SvrBase.h	10;"	d
V3_SVR_BOOLECTOR	svr/v3SvrHandler.h	/^   V3_SVR_BOOLECTOR  = 1,$/;"	e	enum:V3SolverType
V3_SVR_BOOLECTOR_H	svr/v3SvrBoolector.h	10;"	d
V3_SVR_HANDLER_C	svr/v3SvrHandler.cpp	10;"	d	file:
V3_SVR_HANDLER_H	svr/v3SvrHandler.h	10;"	d
V3_SVR_MINISAT	svr/v3SvrHandler.h	/^   V3_SVR_MINISAT    = 0,$/;"	e	enum:V3SolverType
V3_SVR_MSAT_C	svr/v3SvrMiniSat.cpp	10;"	d	file:
V3_SVR_MSAT_H	pdr/v3SvrPDRSat.h	12;"	d
V3_SVR_MSAT_H	svr/v3SvrMiniSat.h	10;"	d
V3_SVR_PDRSAT_C	pdr/v3SvrPDRSat.cpp	10;"	d	file:
V3_SVR_SAT_HELPER_C	svr/v3SvrSatHelper.h	11;"	d
V3_SVR_TOTAL	svr/v3SvrHandler.h	/^   V3_SVR_TOTAL      = 2$/;"	e	enum:V3SolverType
V3_SVR_TYPE_H	svr/v3SvrType.h	10;"	d
V3_TRANS_CMD_C	trans/v3TransCmd.cpp	10;"	d	file:
V3_TRANS_CMD_H	trans/v3TransCmd.h	10;"	d
V3_TYPE_H	ntk/v3Type.h	10;"	d
V3_USAGE_H	util/v3Usage.h	10;"	d
V3_USE_BOOST_HASH	adt/v3Hash.h	13;"	d
V3_USE_NEW_SIM_GENERALIZATION	alg/v3AlgGeneralize.cpp	16;"	d	file:
V3_VRF_BASE_C	vrf/v3VrfBase.cpp	10;"	d	file:
V3_VRF_BASE_H	vrf/v3VrfBase.h	10;"	d
V3_VRF_BMC_C	vrf/v3VrfBMC.cpp	10;"	d	file:
V3_VRF_BMC_H	vrf/v3VrfBMC.h	10;"	d
V3_VRF_CITP_C	vrf/v3VrfCITP.cpp	11;"	d	file:
V3_VRF_CITP_H	vrf/v3VrfCITP.h	11;"	d
V3_VRF_CMD_C	vrf/v3VrfCmd.cpp	10;"	d	file:
V3_VRF_CMD_H	vrf/v3VrfCmd.h	10;"	d
V3_VRF_FITP_C	vrf/v3VrfFITP.cpp	11;"	d	file:
V3_VRF_FITP_H	vrf/v3VrfFITP.h	11;"	d
V3_VRF_IPDR_C	vrf/v3VrfIPDR.cpp	10;"	d	file:
V3_VRF_IPDR_H	vrf/v3VrfIPDR.h	10;"	d
V3_VRF_KLIVE_C	vrf/v3VrfKLive.cpp	10;"	d	file:
V3_VRF_KLIVE_H	vrf/v3VrfKLive.h	10;"	d
V3_VRF_MPDR_C	vrf/v3VrfMPDR.cpp	10;"	d	file:
V3_VRF_MPDR_H	vrf/v3VrfMPDR.h	10;"	d
V3_VRF_RESULT_C	vrf/v3VrfResult.cpp	10;"	d	file:
V3_VRF_RESULT_H	vrf/v3VrfResult.h	10;"	d
V3_VRF_SEC_C	vrf/v3VrfSEC.cpp	10;"	d	file:
V3_VRF_SEC_H	vrf/v3VrfSEC.h	10;"	d
V3_VRF_SHARED_C	vrf/v3VrfShared.cpp	10;"	d	file:
V3_VRF_SHARED_H	vrf/v3VrfShared.h	10;"	d
V3_VRF_SIM_C	vrf/v3VrfSIM.cpp	10;"	d	file:
V3_VRF_SIM_H	vrf/v3VrfSIM.h	10;"	d
V3_VRF_UMC_C	vrf/v3VrfUMC.cpp	10;"	d	file:
V3_VRF_UMC_H	vrf/v3VrfUMC.h	10;"	d
V3_XD	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
VAR_GROUP	itp/satMgr.h	/^enum VAR_GROUP {$/;"	g
Value3	pdr/PDRDef.h	/^  Value3() : _bit(0), _dontCare(1) {}$/;"	f	class:Value3
Value3	pdr/PDRDef.h	/^  Value3(bool b, bool d): _bit(b), _dontCare(d) {}$/;"	f	class:Value3
Value3	pdr/PDRDef.h	/^  Value3(const Value3& a) {$/;"	f	class:Value3
Value3	pdr/PDRDef.h	/^class Value3 {$/;"	c
Value3Changed	pdr/v3SvrPDRSat.cpp	/^bool V3SvrPDRSat::Value3Changed(bool b, Cube* s) {$/;"	f	class:V3SvrPDRSat
Var	pdr/SolverTypesV.h	/^typedef int Var;$/;"	t
VarOrder	pdr/VarOrderV.h	/^    VarOrder(const vec<char>& ass, const vec<double>& act) :$/;"	f	class:VarOrder
VarOrder	pdr/VarOrderV.h	/^class VarOrder {$/;"	c
VarOrder_h	pdr/VarOrderV.h	21;"	d
VarOrder_lt	pdr/VarOrderV.h	/^    VarOrder_lt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:VarOrder_lt
VarOrder_lt	pdr/VarOrderV.h	/^struct VarOrder_lt {$/;"	s
Vec	adt/v3Vec.h	/^   typedef std::vector<T> Vec;$/;"	t	struct:V3Vec
WRITE	pdr/FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
Z	pdr/pdrMgr.h	/^    V3SvrPDRSat*              Z;         \/\/ PDR Sat interface$/;"	m	class:PDRMgr
_1stSave	ext/v3NtkElaborate.h	/^      V3NetId           _1stSave;   \/\/ V3NetId of First Time Oracle ON for L2S$/;"	m	class:V3NtkElaborate
_BddMgrV	bdd/bddNodeV.cpp	/^BddMgrV* BddNodeV::_BddMgrV = 0;$/;"	m	class:BddNodeV	file:
_BddMgrV	bdd/bddNodeV.h	/^   static BddMgrV*          _BddMgrV;$/;"	m	class:BddNodeV
_ConstList	ntk/v3Ntk.h	/^      V3NetVec       _ConstList;    \/\/ V3NetId of BV_CONST (AIG_FALSE)$/;"	m	class:V3Ntk
_F	pdr/v3SvrPDRSat.h	/^      vector<vector<Cube*>*>*   _F;         \/\/ PDR Frames$/;"	m	class:V3SvrPDRSat
_FFList	ntk/v3Ntk.h	/^      V3NetVec       _FFList;       \/\/ V3NetId of FF$/;"	m	class:V3Ntk
_I	pdr/v3SvrPDRSat.h	/^      const size_t              _I;         \/\/ Input size$/;"	m	class:V3SvrPDRSat
_IOList	ntk/v3Ntk.h	/^      V3NetVec       _IOList[3];    \/\/ V3NetId of PI \/ PO \/ PIO$/;"	m	class:V3Ntk
_L	pdr/PDRDef.h	/^  static unsigned _L;               \/\/ latch size$/;"	m	class:Cube
_L	pdr/pdrMgr.cpp	/^unsigned Cube::_L = 0;$/;"	m	class:Cube	file:
_L	pdr/v3SvrPDRSat.h	/^      const size_t              _L;         \/\/ Latch size$/;"	m	class:V3SvrPDRSat
_READER_H_	itp/reader.h	10;"	d
_READER_H_	pdr/reader.h	10;"	d
_Solver	pdr/v3SvrPDRSat.h	/^      SolverV*                  _Solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:V3SvrPDRSat
_Solver	svr/v3SvrBoolector.h	/^      Btor*          _Solver;    \/\/ Pointer to a Boolector solver$/;"	m	class:V3SvrBoolector
_Solver	svr/v3SvrMiniSat.h	/^      MSolver*       _Solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:V3SvrMiniSat
_V3BusIdHash	ntk/v3Ntk.cpp	/^V3BusIdHash  V3BvNtk::_V3BusIdHash = V3BusIdHash();$/;"	m	class:V3BvNtk	file:
_V3BusIdHash	ntk/v3Ntk.h	/^      static V3BusIdHash   _V3BusIdHash;  \/\/ Global Hash for V3BusId of V3Slice for All V3BvNtk$/;"	m	class:V3BvNtk
_V3BusIdVec	ntk/v3Ntk.cpp	/^V3BusPairVec V3BvNtk::_V3BusIdVec  = V3BusPairVec();$/;"	m	class:V3BvNtk	file:
_V3BusIdVec	ntk/v3Ntk.h	/^      static V3BusPairVec  _V3BusIdVec;   \/\/ Global Vec for V3BusId to (MSB, LSB) Mapping$/;"	m	class:V3BvNtk
_V3ConstHash	ntk/v3Ntk.cpp	/^V3ConstHash  V3BvNtk::_V3ConstHash = V3ConstHash();$/;"	m	class:V3BvNtk	file:
_V3ConstHash	ntk/v3Ntk.h	/^      static V3ConstHash   _V3ConstHash;  \/\/ Global Hash for V3BitVecX of V3Const for All V3BvNtk$/;"	m	class:V3BvNtk
_V3ValueVec	ntk/v3Ntk.cpp	/^V3BitVecXVec V3BvNtk::_V3ValueVec  = V3BitVecXVec();$/;"	m	class:V3BvNtk	file:
_V3ValueVec	ntk/v3Ntk.h	/^      static V3BitVecXVec  _V3ValueVec;   \/\/ Global Vec for V3BVXId to V3BitVecX  Mapping$/;"	m	class:V3BvNtk
_Value3List	pdr/v3SvrPDRSat.h	/^      V3Vec<Value3>::Vec        _Value3List;\/\/ Mapping between V3NetId and Value3, used for simulation$/;"	m	class:V3SvrPDRSat
__SGI_STL_INTERNAL_RELOPS	pdr/GlobalV.h	276;"	d
_aborted	pdr/SolverV.h	/^   bool     _aborted;$/;"	m	class:SolverV
_actVars	pdr/v3SvrPDRSat.h	/^      vector<Var>               _actVars;   \/\/ Activation Vars$/;"	m	class:V3SvrPDRSat
_activator	vrf/v3VrfMPDR.h	/^      V3SvrData      _activator;    \/\/ Activation Variable for Clause Indication$/;"	m	class:V3MPDRFrame
_allName	main/main.cpp	/^string V3Msg::_allName = "";$/;"	m	class:V3Msg	file:
_allName	util/v3Msg.h	/^      static string     _allName;$/;"	m	class:V3Msg
_allout	main/main.cpp	/^ofstream V3Msg::_allout;$/;"	m	class:V3Msg	file:
_allout	util/v3Msg.h	/^      static ofstream   _allout;$/;"	m	class:V3Msg
_assump	itp/sat.h	/^      vec<Lit>            _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:SatSolver
_assump	pdr/v3SvrPDRSat.h	/^      vec<Lit>                  _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:V3SvrPDRSat
_assump	svr/v3SvrBoolector.h	/^      V3BtorExpVec   _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:V3SvrBoolector
_assump	svr/v3SvrMiniSat.h	/^      vec<Lit>       _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:V3SvrMiniSat
_bId	bdd/myHash.h	/^      size_t                     _bId;$/;"	m	class:Hash::iterator
_base	stg/v3StgSDG.h	/^      V3SDGBase* const  _base;         \/\/ Base Dependency Structure$/;"	m	class:V3SDGNode
_baseCube	alg/v3AlgGeneralize.h	/^      V3NetVec          _baseCube;$/;"	m	class:V3GenStruct
_baseNtk	v3mc/v3MCMain.h	/^   V3NtkHandler*        _baseNtk;      \/\/ The Very Base Network Handler$/;"	m	struct:V3MCMainParam
_bddArr	bdd/bddMgrV.h	/^   BddArr           _bddArr;$/;"	m	class:BddMgrV
_bddMap	bdd/bddMgrV.h	/^   BddMap           _bddMap;$/;"	m	class:BddMgrV
_bestIndex	adt/v3Bucket.h	/^      uint32_t       _bestIndex;$/;"	m	class:V3BucketList
_bestIndex	adt/v3Bucket.h	/^      uint32_t       _bestIndex;$/;"	m	class:V3IncBucketList
_bestIndex	alg/v3AlgGeneralize.h	/^      uint32_t          _bestIndex; \/\/ The Lowest Non-empty Bucket$/;"	m	class:V3GenBucket
_bit	pdr/PDRDef.h	/^  bool _bit;$/;"	m	class:Value3
_bnId	bdd/myHash.h	/^      size_t                     _bnId;$/;"	m	class:Hash::iterator
_bound	vrf/v3VrfShared.h	/^      V3UI32Vec         _bound;     \/\/ The Deep Bound of Each Property (V3NtkUD for Verified)$/;"	m	class:V3VrfSharedBound
_bucketIdx	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _bucketIdx; \/\/ The Index for Element Storage$/;"	m	class:V3GenBucket
_buckets	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _buckets;   \/\/ The First Element in the Bucket$/;"	m	class:V3GenBucket
_buckets	bdd/myHash.h	/^   vector<HashNode>*        _buckets;$/;"	m	class:Hash
_c2pMap	ext/v3NtkElaborate.h	/^      V3NetVec          _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkElaborate
_c2pMap	ntk/v3NtkSimplify.h	/^      V3NetVec    _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkSimplify
_c2pMap	trans/v3BvBlastAig.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3BvBlastAig
_c2pMap	trans/v3BvBlastBv.h	/^      V3UI32Vec         _c2pMap;       \/\/ Net Index Mapping From Current to Parent Ntk$/;"	m	class:V3BvBlastBv
_c2pMap	trans/v3NtkExpand.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkExpand
_c2pMap	trans/v3NtkFlatten.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkFlatten
_c2pMap	vrf/v3VrfSEC.h	/^      V3NetVec          _c2pMap;             \/\/ Mapping from new to old$/;"	m	class:V3VrfSEC
_cache	bdd/myHash.h	/^   CacheNode*     _cache;$/;"	m	class:Cache
_cexOrInv	ext/v3Property.h	/^      size_t         _cexOrInv;$/;"	m	class:V3VrfResult
_checkStat	vrf/v3VrfKLive.h	/^      V3Stat*           _checkStat;       \/\/ Formal Checking$/;"	m	class:V3VrfKLive
_checkStat	vrf/v3VrfSEC.h	/^      V3Stat*           _checkStat;          \/\/ Formal Checking$/;"	m	class:V3VrfSEC
_clusters	stg/v3StgExtract.h	/^      V3SDGClusters        _clusters;  \/\/ Variable Cluster Results$/;"	m	class:V3FSMExtract
_cmdLen	cmd/v3CmdMgr.h	/^      unsigned          _cmdLen;$/;"	m	class:V3CmdExec
_cmdLib	cmd/v3CmdMgr.h	/^      V3CmdExecSet   _cmdLib;                \/\/ All Available Commands$/;"	m	class:V3CmdMgr
_cmdType	cmd/v3CmdMgr.h	/^      V3CmdType         _cmdType;$/;"	m	class:V3CmdExec
_computedTable	bdd/bddMgrV.h	/^   BddCache         _computedTable;$/;"	m	class:BddMgrV
_configs	stg/v3StgExtract.h	/^      unsigned short       _configs;   \/\/ Configurations$/;"	m	class:V3FSMExtract
_configs	stg/v3StgFSM.h	/^      unsigned char           _configs;   \/\/ Configurations$/;"	m	class:V3FSM
_configs	stg/v3StgFSM.h	/^      unsigned char           _configs;   \/\/ FSMSDG Construction Configurations  (2 Leading MSBs are reserved)$/;"	m	class:V3FSMSDGDB
_conflictNum	pdr/SolverV.h	/^   int      _conflictNum;$/;"	m	class:SolverV
_constr	v3mc/v3MCMain.h	/^   V3NetTable           _constr;       \/\/ Table of Constraints$/;"	m	struct:V3MCMainParam
_constr	vrf/v3VrfBase.h	/^      V3NetTable                 _constr;$/;"	m	class:V3VrfBase
_constr	vrf/v3VrfShared.h	/^         V3NetTable        _constr;       \/\/ Constraints$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_constrInfo	ext/v3Property.h	/^      const uint64_t       _constrInfo;$/;"	m	class:V3Constraint
_cpRatio	v3mc/v3MCMain.h	/^      V3DblVec                _cpRatio;      \/\/ Ratio of Cores to Property Size$/;"	m	class:V3MCResource
_cube	pdr/PDRDef.h	/^  Cube* _cube;$/;"	m	class:TCube
_cube2Var	alg/v3AlgGeneralize.h	/^      V3GenCubeList     _cube2Var;$/;"	m	class:V3GenStruct
_cubeList	vrf/v3VrfCITP.h	/^      V3CITPCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3CITPFrame
_cubeList	vrf/v3VrfFITP.h	/^      V3FITPCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3FITPFrame
_cubeList	vrf/v3VrfIPDR.h	/^      V3IPDRCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3IPDRFrame
_cubeList	vrf/v3VrfMPDR.h	/^      V3MPDRCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3MPDRFrame
_curHandlerId	ntk/v3NtkHandler.h	/^      uint32_t       _curHandlerId;    \/\/ Id of Current Ntk Handler $/;"	m	class:V3Handler
_curRefIdVec	ntk/v3NtkHandler.h	/^      V3UI32Vec      _curRefIdVec;     \/\/ Current Ref Indices from Base Ntk$/;"	m	class:V3Handler
_curTime	stg/v3StgExtract.h	/^      double               _curTime;   \/\/ Time Used Currently on FSM Extraction$/;"	m	class:V3FSMExtract
_curVar	itp/sat.h	/^      Var                 _curVar;    \/\/ Variable currently$/;"	m	class:SatSolver
_curVar	pdr/v3SvrPDRSat.h	/^      Var                       _curVar;    \/\/ Latest Fresh Variable$/;"	m	class:V3SvrPDRSat
_curVar	svr/v3SvrMiniSat.h	/^      Var            _curVar;    \/\/ Latest Fresh Variable$/;"	m	class:V3SvrMiniSat
_currentMem	util/v3Usage.h	/^      double   _currentMem;$/;"	m	class:V3Usage
_currentTick	util/v3Usage.h	/^      double   _currentTick;$/;"	m	class:V3Usage
_cutSignals	ntk/v3Ntk.h	/^      V3NetVec       _cutSignals;   \/\/ Signals on Current Cut$/;"	m	class:V3Ntk
_cutSize	stg/v3StgFSM.h	/^      uint32_t                _cutSize;   \/\/ Number of Cut Signals in terms of Total Bit Width$/;"	m	class:V3FSM
_cycle	alg/v3AlgSimulate.h	/^      uint32_t                   _cycle;$/;"	m	class:V3AlgSimulate
_cycle	trans/v3NtkExpand.h	/^      const uint32_t _cycle;     \/\/ Number of Cycles for Expansion$/;"	m	class:V3NtkExpand
_data	adt/v3BitVec.h	/^      unsigned char*    _data;$/;"	m	class:V3BitVec
_data	ext/v3Property.h	/^      V3SimTrace        _data;$/;"	m	class:V3CexTrace
_data	vrf/v3VrfShared.h	/^      V3Vec<V3VrfSharedNtkData>::Vec   _data;   \/\/ Verification Data for Optimized Networks$/;"	m	class:V3VrfSharedNtk
_data0	adt/v3BitVec.h	/^      uint64_t    _data0;$/;"	m	class:V3BitVecS
_data0	adt/v3BitVec.h	/^      unsigned char*    _data0;$/;"	m	class:V3BitVecX
_data1	adt/v3BitVec.h	/^      uint64_t    _data1;$/;"	m	class:V3BitVecS
_data1	adt/v3BitVec.h	/^      unsigned char*    _data1;$/;"	m	class:V3BitVecX
_debugBddAddr	bdd/bddNodeV.cpp	/^bool BddNodeV::_debugBddAddr = false;$/;"	m	class:BddNodeV	file:
_debugBddAddr	bdd/bddNodeV.h	/^   static bool             _debugBddAddr;$/;"	m	class:BddNodeV
_debugRefCount	bdd/bddNodeV.cpp	/^bool BddNodeV::_debugRefCount = false;$/;"	m	class:BddNodeV	file:
_debugRefCount	bdd/bddNodeV.h	/^   static bool             _debugRefCount;$/;"	m	class:BddNodeV
_default	util/v3Msg.h	/^      ostream&          _default;$/;"	m	class:V3Msg
_defaultON	util/v3Msg.h	/^      bool              _defaultON;$/;"	m	class:V3Msg
_defaultPrompt	cmd/v3CmdMgr.h	/^      const string   _defaultPrompt;         \/\/ Default Command Prompt$/;"	m	class:V3CmdMgr
_depFFCone	stg/v3StgSDG.h	/^      V3SDGBase*        _depFFCone;    \/\/ V3SDGBase of Dependent FaninFF Nodes$/;"	m	class:V3SDGBase
_depFFSet	stg/v3StgSDG.h	/^      V3UI32Set         _depFFSet;     \/\/ Dependent FF Nodes$/;"	m	class:V3SDGBase
_depGraph	stg/v3StgExtract.h	/^      V3Graph<uint32_t>    _depGraph;  \/\/ Variable Dependency Graph$/;"	m	class:V3FSMExtract
_depMuxCone	stg/v3StgSDG.h	/^      V3SDGBase*        _depMuxCone;   \/\/ V3SDGBase of Dependent FaninMuxFF Nodes$/;"	m	class:V3SDGBase
_depMuxSet	stg/v3StgSDG.h	/^      V3UI32Set         _depMuxSet;    \/\/ Dependent MUX Nodes$/;"	m	class:V3SDGBase
_depRetain	stg/v3StgExtract.h	/^      V3BoolVec            _depRetain; \/\/ Retained Depdendent Variables$/;"	m	class:V3FSMExtract
_depVars	stg/v3StgFSM.h	/^      V3UI32Set               _depVars;   \/\/ Dependent Variables of the FSM$/;"	m	class:V3FSMSDGDB
_dffValue	alg/v3AlgSimulate.h	/^      V3AigSimDataVec   _dffValue;     \/\/ Next State Simulation Value$/;"	m	class:V3AlgAigSimulate
_dffValue	alg/v3AlgSimulate.h	/^      V3BvSimDataVec    _dffValue;     \/\/ Next State Simulation Value$/;"	m	class:V3AlgBvSimulate
_distInit	stg/v3StgFSM.h	/^      V3UI32Vec               _distInit;  \/\/ The Shortest Step that the Node Id is Reachable from Initial States$/;"	m	class:V3FSM
_distTerm	stg/v3StgFSM.h	/^      V3UI32Vec               _distTerm;  \/\/ The Shortest Step that the Node Id is Reachable to Terminal States$/;"	m	class:V3FSM
_dofile	cmd/v3CmdMgr.h	/^      ifstream       _dofile;                \/\/ For Script Parsing$/;"	m	class:V3CmdMgr
_dontCare	pdr/PDRDef.h	/^  bool _dontCare;$/;"	m	class:Value3
_elements	adt/v3Bucket.h	/^      BucketList     _elements;$/;"	m	class:V3BucketList
_elements	adt/v3Bucket.h	/^      BucketList     _elements;$/;"	m	class:V3IncBucketList
_emptyCores	v3mc/v3MCMain.h	/^      uint32_t                _emptyCores;   \/\/ Number of Empty Cores$/;"	m	class:V3MCResource
_engineType	v3mc/v3MCMain.h	/^   V3MCEngineType       _engineType;   \/\/ Type of Verification Engine$/;"	m	struct:V3MCParam
_eventList	alg/v3AlgSimulate.h	/^      V3IncBucketList<V3NetId>   _eventList;$/;"	m	class:V3AlgSimulate
_extSolverType	vrf/v3VrfBase.cpp	/^V3SolverType    V3VrfBase::_extSolverType       = V3_SVR_TOTAL;$/;"	m	class:V3VrfBase	file:
_extSolverType	vrf/v3VrfBase.h	/^      static V3SolverType        _extSolverType;$/;"	m	class:V3VrfBase
_extVerbosity	ntk/v3NtkHandler.cpp	/^unsigned char V3NtkHandler::_extVerbosity = 0;$/;"	m	class:V3NtkHandler	file:
_extVerbosity	ntk/v3NtkHandler.h	/^      static unsigned char _extVerbosity;$/;"	m	class:V3NtkHandler
_extVerbosity	vrf/v3VrfBase.cpp	/^unsigned char   V3VrfBase::_extVerbosity        = 0;$/;"	m	class:V3VrfBase	file:
_extVerbosity	vrf/v3VrfBase.h	/^      static unsigned char       _extVerbosity;$/;"	m	class:V3VrfBase
_f	bdd/bddMgrV.h	/^   size_t       _f;$/;"	m	class:BddCacheKeyV
_fBase	stg/v3StgSDG.h	/^      V3SDGBase* const  _fBase;        \/\/ Base Structure for False Part of MUX$/;"	m	class:V3SDGMUX
_fairConstrs	ext/v3Property.h	/^      V3ConstraintVec      _fairConstrs;$/;"	m	class:V3Property
_falseSDG	stg/v3StgFSM.h	/^      V3FSMSDGSet             _falseSDG;  \/\/ Set of SDG for the FALSE Part$/;"	m	class:V3FSMSDG
_falseSize	stg/v3StgFSM.h	/^      uint32_t                _falseSize; \/\/ Size of the False States$/;"	m	class:V3FSMSDG
_fanoutVec	alg/v3AlgSimulate.h	/^      V3NetTable                 _fanoutVec;$/;"	m	class:V3AlgSimulate
_ffGenStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _ffGenStat;$/;"	m	class:V3TraceSimplify
_ffUnrollStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _ffUnrollStat;$/;"	m	class:V3TraceSimplify
_ffValue	dfx/v3DfxSimplify.h	/^      V3SimTraceVec        _ffValue;$/;"	m	class:V3TraceSimplify
_filename	util/v3Msg.h	/^      string            _filename;$/;"	m	class:V3Msg
_fired	itp/satMgr.h	/^    uint32_t      _fired;$/;"	m	class:SatProofRes
_fired	pdr/pdrMgr.h	/^    uint32_t      _fired;$/;"	m	class:SatProofRes
_formula	ext/v3Formula.h	/^      V3FormulaList           _formula;$/;"	m	class:V3Formula
_formula	ext/v3LTLFormula.h	/^      V3LTLFormulaList     _formula;$/;"	m	class:V3LTLFormula
_formula	ext/v3Property.h	/^      V3LTLFormula* const  _formula;$/;"	m	class:V3Property
_frame	pdr/PDRDef.h	/^  int   _frame; \/\/ -1 = frame_null, INT_MAX = INF$/;"	m	class:TCube
_frameId	dfx/v3DfxTrace.h	/^      const uint32_t          _frameId;      \/\/ Counterexample Frame of the Cube$/;"	m	class:V3DfxCube
_freeBound	pdr/v3SvrPDRSat.h	/^      const bool                _freeBound; \/\/ Set FF Bounds Free$/;"	m	class:V3SvrPDRSat
_freeBound	svr/v3SvrBase.h	/^      const bool           _freeBound; \/\/ Set FF Bounds Free$/;"	m	class:V3SvrBase
_fsm	ntk/v3NtkHandler.h	/^      V3FSMMap             _fsm;          \/\/ FSM List$/;"	m	class:V3NtkHandler
_fsmList	stg/v3StgExtract.h	/^      V3FSMVec             _fsmList;   \/\/ List Extracted FSMs from Each Cluster$/;"	m	class:V3FSMExtract
_g	bdd/bddMgrV.h	/^   size_t       _g;$/;"	m	class:BddCacheKeyV
_genResult	alg/v3AlgGeneralize.h	/^      V3NetList            _genResult; \/\/ Generalization Result$/;"	m	class:V3AlgGeneralize
_generalStat	vrf/v3VrfCITP.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfCITP
_generalStat	vrf/v3VrfFITP.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfFITP
_generalStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfIPDR
_generalStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfMPDR
_globalClk	ntk/v3Ntk.h	/^      V3NetId        _globalClk;    \/\/ Global Clock Signal (Specified in RTL)$/;"	m	class:V3Ntk
_globalMisc	ntk/v3Ntk.h	/^      uint32_t       _globalMisc;   \/\/ Global Misc Data for V3NetId in Ntk$/;"	m	class:V3Ntk
_h	bdd/bddMgrV.h	/^   size_t       _h;$/;"	m	class:BddCacheKeyV
_handler	alg/v3AlgSimulate.h	/^      const V3NtkHandler* const  _handler;$/;"	m	class:V3AlgSimulate
_handler	dfx/v3DfxSimplify.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3TraceSimplify
_handler	ext/v3Formula.h	/^      V3NtkHandler* const     _handler;$/;"	m	class:V3Formula
_handler	ext/v3LTLFormula.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3LTLFormula
_handler	ext/v3Property.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3Constraint
_handler	ntk/v3NtkHandler.h	/^            V3NtkHandler* const  _handler;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_handler	ntk/v3NtkHandler.h	/^      V3NtkHandler* const  _handler;      \/\/ Parent Ntk Handler$/;"	m	class:V3NtkHandler
_handler	stg/v3StgExtract.h	/^      V3NtkHandler* const  _handler;   \/\/ Network that Extraction Works on$/;"	m	class:V3FSMExtract
_handler	stg/v3StgFSM.h	/^      V3NtkHandler* const     _handler;   \/\/ Network that FSMSDG Extracted From$/;"	m	class:V3FSMSDGDB
_handler	stg/v3StgSDG.h	/^      V3NtkHandler* const  _handler;   \/\/ Ntk Handler$/;"	m	class:V3SDG
_handler	v3mc/v3MCMain.h	/^   V3NtkHandler*        _handler;      \/\/ Base Elaborated Network Handler$/;"	m	struct:V3MCMainParam
_handler	vrf/v3VrfBase.h	/^      V3NtkHandler*              _handler;$/;"	m	class:V3VrfBase
_handler	vrf/v3VrfShared.h	/^         V3NtkHandler*     _handler;      \/\/ Network Handler$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_hasEvent	alg/v3AlgSimulate.h	/^      V3BoolVec                  _hasEvent;$/;"	m	class:V3AlgSimulate
_hash	bdd/myHash.h	/^      Hash<HashKey, HashData>*   _hash;$/;"	m	class:Hash::iterator
_hierInfo	ntk/v3NtkHandler.h	/^      V3Vec<V3NtkHierData*>::Vec _hierInfo;$/;"	m	class:V3NtkHierInfo
_hierInfo	trans/v3NtkFlatten.h	/^      V3NtkHierInfo  _hierInfo;  \/\/ Hierarchical Information for Flattened Ntk$/;"	m	class:V3NtkFlatten
_history	cmd/v3CmdMgr.h	/^      vector<string> _history;               \/\/ Command History Copy$/;"	m	class:V3CmdMgr
_i	bdd/bddMgrV.h	/^   unsigned   _i;$/;"	m	class:BddHashKeyV
_inLoop	ext/v3NtkElaborate.h	/^      V3NetId           _inLoop;    \/\/ V3NetId for the Formula "_1stSave || _saved"$/;"	m	class:V3NtkElaborate
_incDepth	vrf/v3VrfBMC.h	/^      uint32_t       _incDepth;     \/\/ Increment Depth (default = 1)$/;"	m	class:V3VrfBMC
_incDepth	vrf/v3VrfKLive.h	/^      uint32_t          _incDepth;        \/\/ Increment Depth$/;"	m	class:V3VrfKLive
_incDepth	vrf/v3VrfUMC.h	/^      uint32_t       _incDepth;     \/\/ Increment Depth (default = 1)$/;"	m	class:V3VrfUMC
_index	adt/v3Misc.h	/^      V3UI32Vec            _index;$/;"	m	class:V3PortableType
_init	alg/v3AlgSimulate.h	/^      uint32_t                   _init[2];$/;"	m	class:V3AlgSimulate
_init	ext/v3Property.h	/^      V3BitVecX*        _init;$/;"	m	class:V3CexTrace
_init	pdr/v3SvrPDRSat.h	/^      V3SvrMLitData             _init;      \/\/ Initial state Var storage$/;"	m	class:V3SvrPDRSat
_init	svr/v3SvrBoolector.h	/^      V3BtorExpVec   _init;      \/\/ Initial state Var storage$/;"	m	class:V3SvrBoolector
_init	svr/v3SvrMiniSat.h	/^      V3SvrMLitData  _init;      \/\/ Initial state Var storage$/;"	m	class:V3SvrMiniSat
_initMem	util/v3Usage.h	/^      double   _initMem;$/;"	m	class:V3Usage
_initState	bdd/bddMgrV.h	/^   BddNodeV         _initState;$/;"	m	class:BddMgrV
_initSvrStat	vrf/v3VrfCITP.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfCITP
_initSvrStat	vrf/v3VrfFITP.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfFITP
_initSvrStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfIPDR
_initSvrStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfMPDR
_initTime	v3mc/v3MCMain.h	/^   struct timeval       _initTime;     \/\/ Initial Time$/;"	m	struct:V3MCMainParam	typeref:struct:V3MCMainParam::timeval
_inputData	ntk/v3Ntk.h	/^      V3InputTable   _inputData;    \/\/ Fanin Table for V3NetId   (V3NetId, V3BVXId, V3BusId)$/;"	m	class:V3Ntk
_inputData	vrf/v3VrfIPDR.h	/^      V3BitVecX               _inputData;    \/\/ Primary Input \/ Inout Values$/;"	m	class:V3IPDRCube
_inputData	vrf/v3VrfMPDR.h	/^      V3BitVecX               _inputData;    \/\/ Primary Input \/ Inout Values$/;"	m	class:V3MPDRCube
_inputSize	v3mc/v3MCMain.h	/^   uint32_t             _inputSize;    \/\/ Number of Inputs in the Original Network$/;"	m	struct:V3MCMainParam
_inputs	ntk/v3Ntk.h	/^      V3NetVec    _inputs;$/;"	m	class:V3NtkModule
_instRef	ntk/v3NtkHandler.h	/^      uint32_t             _instRef;$/;"	m	class:V3NtkHandler
_intVerbosity	ntk/v3NtkHandler.cpp	/^unsigned char V3NtkHandler::_intVerbosity = 0;$/;"	m	class:V3NtkHandler	file:
_intVerbosity	ntk/v3NtkHandler.h	/^      static unsigned char _intVerbosity;$/;"	m	class:V3NtkHandler
_inv	vrf/v3VrfShared.h	/^      V3NetTable        _inv;       \/\/ Cube Invariants (in terms of latch indices)$/;"	m	class:V3VrfSharedInv
_invConstrs	ext/v3Property.h	/^      V3ConstraintVec      _invConstrs;$/;"	m	class:V3Property
_invariants	ext/v3Property.h	/^      V3ConstraintVec      _invariants;$/;"	m	class:V3Property
_isBddBuilt	ntk/v3Ntk.h	/^      bool           _isBddBuilt;   \/\/ MODIFICATION FOR SoCV BDD$/;"	m	class:V3Ntk
_isClaOnDup	itp/satMgr.h	/^    mutable vector<bool>      _isClaOnDup; \/\/ duplication & extension of _isClauseOn$/;"	m	class:SATMgr
_isClauseOn	itp/satMgr.h	/^    vector<bool>      _isClauseOn; \/\/ record onset clauses$/;"	m	class:SATMgr
_isFixed	bdd/bddMgrV.h	/^   bool             _isFixed;$/;"	m	class:BddMgrV
_isFrozen	alg/v3AlgGeneralize.h	/^      V3BoolVec            _isFrozen;  \/\/ Frozen Net Table$/;"	m	class:V3AlgAigGeneralize
_itpAttr	vrf/v3VrfCITP.h	/^      unsigned char     _itpAttr;         \/\/ Specific Attributes for CITP$/;"	m	class:V3VrfCITP
_itpAttr	vrf/v3VrfFITP.h	/^      unsigned char     _itpAttr;         \/\/ Specific Attributes for FITP$/;"	m	class:V3VrfFITP
_itpBMCDepth	vrf/v3VrfCITP.h	/^      uint32_t          _itpBMCDepth;     \/\/ The Number of Unrolled Frames in BMC Solver$/;"	m	class:V3VrfCITP
_itpBMCDepth	vrf/v3VrfFITP.h	/^      uint32_t          _itpBMCDepth;     \/\/ The Number of Unrolled Frames in BMC Solver$/;"	m	class:V3VrfFITP
_itpBMCSvr	vrf/v3VrfCITP.h	/^      V3SvrBase*        _itpBMCSvr;       \/\/ The BMC SAT Solver (Counterexample Confirm)$/;"	m	class:V3VrfCITP
_itpBMCSvr	vrf/v3VrfFITP.h	/^      V3SvrBase*        _itpBMCSvr;       \/\/ The BMC SAT Solver (Counterexample Confirm)$/;"	m	class:V3VrfFITP
_itpBad	vrf/v3VrfCITP.h	/^      V3CITPCube*       _itpBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfCITP
_itpBad	vrf/v3VrfFITP.h	/^      V3FITPCube*       _itpBad;          \/\/ Cube for the Bad State (I0)$/;"	m	class:V3VrfFITP
_itpBadCount	vrf/v3VrfCITP.h	/^      uint32_t          _itpBadCount;     \/\/ Max Bad Cubes to be Blocked for a Given Cube$/;"	m	class:V3VrfCITP
_itpBadCount	vrf/v3VrfFITP.h	/^      uint32_t          _itpBadCount;     \/\/ Max Bad Cubes to be Blocked for a Given Cube$/;"	m	class:V3VrfFITP
_itpBadCubeStr	vrf/v3VrfCITP.h	/^      V3StrSet          _itpBadCubeStr;   \/\/ Expressions for Pending Bad Cubes$/;"	m	class:V3VrfCITP
_itpBadCubeStr	vrf/v3VrfFITP.h	/^      V3StrSet          _itpBadCubeStr;   \/\/ Expressions for Pending Bad Cubes$/;"	m	class:V3VrfFITP
_itpBlockCubes	vrf/v3VrfCITP.h	/^      V3NetTable        _itpBlockCubes;   \/\/ Blocking Cubes for Interpolants$/;"	m	class:V3VrfCITP
_itpBlockCubes	vrf/v3VrfFITP.h	/^      V3NetTable        _itpBlockCubes;   \/\/ Blocking Cubes for Interpolants$/;"	m	class:V3VrfFITP
_itpForceUAct	vrf/v3VrfCITP.h	/^      V3SvrData         _itpForceUAct;    \/\/ Activation Variable to Force Unreachability$/;"	m	class:V3VrfCITP
_itpForceUAct	vrf/v3VrfFITP.h	/^      V3SvrData         _itpForceUAct;    \/\/ Activation Variable to Force Unreachability$/;"	m	class:V3VrfFITP
_itpFrame	vrf/v3VrfCITP.h	/^      V3CITPFrameVec    _itpFrame;        \/\/ List of Frames (Ri') in CITP$/;"	m	class:V3VrfCITP
_itpFrame	vrf/v3VrfFITP.h	/^      V3FITPFrameVec    _itpFrame;        \/\/ List of Frames (Ri') in FITP$/;"	m	class:V3VrfFITP
_itpGSt	vrf/v3VrfCITP.h	/^      V3GenStruct*      _itpGSt;          \/\/ Generalization Struct$/;"	m	class:V3VrfCITP
_itpGSt	vrf/v3VrfFITP.h	/^      V3GenStruct*      _itpGSt;          \/\/ Generalization Struct$/;"	m	class:V3VrfFITP
_itpGen	vrf/v3VrfCITP.h	/^      V3AlgGeneralize*  _itpGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfCITP
_itpGen	vrf/v3VrfFITP.h	/^      V3AlgGeneralize*  _itpGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfFITP
_itpITPSvr	vrf/v3VrfCITP.h	/^      V3SvrBase*        _itpITPSvr;       \/\/ The ITP SAT Solver (Reachability Containment)$/;"	m	class:V3VrfCITP
_itpITPSvr	vrf/v3VrfFITP.h	/^      V3SvrBase*        _itpITPSvr;       \/\/ The ITP SAT Solver (Reachability Containment)$/;"	m	class:V3VrfFITP
_itpPriority	vrf/v3VrfCITP.h	/^      V3UI32Vec         _itpPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfCITP
_itpPriority	vrf/v3VrfFITP.h	/^      V3UI32Vec         _itpPriority;     \/\/ Priority List for Cut Signals$/;"	m	class:V3VrfFITP
_itpReuse	vrf/v3VrfCITP.h	/^      V3CITPFrameVec    _itpReuse;        \/\/ List of Frames Computed Before$/;"	m	class:V3VrfCITP
_itpReuse	vrf/v3VrfFITP.h	/^      V3FITPFrameVec    _itpReuse;        \/\/ List of Frames Computed Before$/;"	m	class:V3VrfFITP
_itpSim	vrf/v3VrfCITP.h	/^      V3AlgSimulate*    _itpSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfCITP
_itpSim	vrf/v3VrfFITP.h	/^      V3AlgSimulate*    _itpSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfFITP
_klChecker	vrf/v3VrfKLive.h	/^      V3VrfBase*        _klChecker;       \/\/ Formal Engine for KLiveness$/;"	m	class:V3VrfKLive
_klHandler	vrf/v3VrfKLive.h	/^      V3NtkHandler*     _klHandler;       \/\/ KLiveness Network Handler$/;"	m	class:V3VrfKLive
_klNetList	vrf/v3VrfKLive.h	/^      V3NetVec          _klNetList;       \/\/ List of V3NetId for K-Liveness Signals$/;"	m	class:V3VrfKLive
_klNtk	vrf/v3VrfKLive.h	/^      V3Ntk*            _klNtk;           \/\/ KLiveness Network$/;"	m	class:V3VrfKLive
_l	bdd/bddMgrV.h	/^   size_t     _l;$/;"	m	class:BddHashKeyV
_lastHandlerId	ntk/v3NtkHandler.h	/^      uint32_t       _lastHandlerId;   \/\/ Id of Last Ntk Handler $/;"	m	class:V3Handler
_lastRefIdVec	ntk/v3NtkHandler.h	/^      V3UI32Vec      _lastRefIdVec;    \/\/ Last Ref Indices from Base Ntk$/;"	m	class:V3Handler
_latchSize	v3mc/v3MCMain.h	/^   uint32_t             _latchSize;    \/\/ Number of Latches in the Original Network$/;"	m	struct:V3MCMainParam
_latchValues	pdr/PDRDef.h	/^  Value3*         _latchValues;     \/\/ latch values$/;"	m	class:Cube
_left	bdd/bddNodeV.h	/^   BddNodeV              _left;$/;"	m	class:BddNodeVInt
_level	alg/v3AlgSimulate.h	/^      uint32_t                   _level;$/;"	m	class:V3AlgSimulate
_levelData	alg/v3AlgSimulate.h	/^      V3UI32Vec                  _levelData;$/;"	m	class:V3AlgSimulate
_list	adt/v3Misc.h	/^      V3PtrVec             _list;$/;"	m	class:V3PortableType
_looped	ext/v3NtkElaborate.h	/^      V3NetId           _looped;    \/\/ V3NetId for Loop Found in L2S$/;"	m	class:V3NtkElaborate
_mainParam	v3mc/v3MCMain.h	/^   V3MCMainParam*       _mainParam;    \/\/ Parameter of the Main Thread$/;"	m	struct:V3MCParam
_mandCmd	cmd/v3CmdMgr.h	/^      vector<string>    _mandCmd;$/;"	m	class:V3CmdExec
_maxDepth	itp/satMgr.h	/^    uint32_t      _maxDepth;  \/\/ maximum proof depth$/;"	m	class:SatProofRes
_maxDepth	pdr/pdrMgr.h	/^    uint32_t      _maxDepth;  \/\/ maximum proof depth$/;"	m	class:SatProofRes
_maxDepth	vrf/v3VrfBase.h	/^      uint32_t                   _maxDepth;$/;"	m	class:V3VrfBase
_maxMemory	v3mc/v3MCMain.h	/^   double               _maxMemory;    \/\/ Total Available Memory$/;"	m	struct:V3MCMainParam
_maxMemory	vrf/v3VrfShared.h	/^      double               _maxMemory;    \/\/ Memory Bound$/;"	m	class:V3VrfSharedMem
_maxSize	stg/v3StgExtract.h	/^      uint32_t             _maxSize;   \/\/ Max Allowed State Size for Each FSM$/;"	m	class:V3FSMExtract
_maxSize	stg/v3StgFSM.h	/^      uint32_t                _maxSize;   \/\/ Maximum Allowed Number of States$/;"	m	class:V3FSMSDGDB
_maxTime	stg/v3StgExtract.h	/^      double               _maxTime;   \/\/ Maximum Time Usage on FSM Extraction$/;"	m	class:V3FSMExtract
_maxTime	v3mc/v3MCMain.h	/^   double               _maxTime;      \/\/ Runtime Limit$/;"	m	struct:V3MCMainParam
_maxTime	vrf/v3VrfBase.h	/^      double                     _maxTime;$/;"	m	class:V3VrfBase
_mexCandidate	stg/v3StgSDG.h	/^      V3BoolVec         _mexCandidate; \/\/ Mutex Candidates for MUX Candidates$/;"	m	class:V3AigSDG
_mirror	ext/v3NtkElaborate.h	/^      V3UI32Hash        _mirror;    \/\/ Mirror V3NetId for the Delay Operator$/;"	m	class:V3NtkElaborate
_mirrorBound	v3mc/v3MCMain.h	/^   V3VrfSharedBound*    _mirrorBound;  \/\/ Mirror Bound of Checkers$/;"	m	struct:V3MCMainParam
_monitor	pdr/v3SvrPDRSat.h	/^      V3NetId                   _monitor;   \/\/ The Bad Output$/;"	m	class:V3SvrPDRSat
_mutex	vrf/v3VrfShared.h	/^      pthread_mutex_t         _mutex;        \/\/ Mutex for a Specific Type of Shared Data$/;"	m	class:V3VrfShared
_muxCandidate	stg/v3StgSDG.h	/^      V3UI32Vec         _muxCandidate; \/\/ MUX Candidates on AIG Network$/;"	m	class:V3AigSDG
_name	ext/v3LTLFormula.h	/^      const string         _name;$/;"	m	class:V3LTLFormula
_nameHash	ntk/v3NtkHandler.h	/^      V3StrNetHash         _nameHash;     \/\/ Hash Table for V3NetId from External Signal Name$/;"	m	class:V3NtkHandler
_netHash	ext/v3NtkElaborate.h	/^      V3PortableType    _netHash;   \/\/ Hash Table for Ntk Elaboration$/;"	m	class:V3NtkElaborate
_netHash	ntk/v3NtkHandler.h	/^      V3NetStrHash         _netHash;      \/\/ Hash Table for External Signal Name from V3NetId$/;"	m	class:V3NtkHandler
_netId	stg/v3StgFSM.h	/^      const V3NetId           _netId;     \/\/ Embraced NetId in V3SDGBase$/;"	m	class:V3FSMSDG
_netId	stg/v3StgSDG.h	/^      const V3NetId     _netId;        \/\/ NetId Corresponding to Ntk$/;"	m	class:V3SDGNode
_netWidth	ntk/v3Ntk.h	/^      V3UI32Vec            _netWidth;     \/\/ Width of Bit-Vector V3NetId$/;"	m	class:V3BvNtk
_nextCube	vrf/v3VrfCITP.h	/^      const V3CITPCube* const _nextCube;     \/\/ Successor State in the Successor Interpolant$/;"	m	class:V3CITPCube
_nextCube	vrf/v3VrfFITP.h	/^      const V3FITPCube* const _nextCube;     \/\/ Successor State in the Successor Interpolant$/;"	m	class:V3FITPCube
_nextCube	vrf/v3VrfIPDR.h	/^      const V3IPDRCube* const _nextCube;     \/\/ Successor Proof Obligation$/;"	m	class:V3IPDRCube
_nextCube	vrf/v3VrfMPDR.h	/^      const V3MPDRCube* const _nextCube;     \/\/ Successor Proof Obligation$/;"	m	class:V3MPDRCube
_nextData	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _nextData;  \/\/ The Next (bwd pointer) Element$/;"	m	class:V3GenBucket
_nextOpId	ext/v3NtkElaborate.h	/^      V3NetId           _nextOpId;  \/\/ Delay NetId for the Delay Operator$/;"	m	class:V3NtkElaborate
_nodeIndexMap	adt/v3Graph.h	/^      V3NodeIndexMap       _nodeIndexMap;$/;"	m	class:V3Graph
_nodeList	adt/v3Graph.h	/^      V3NodeVec            _nodeList;$/;"	m	class:V3Graph
_nodeList	stg/v3StgSDG.h	/^      V3SDGNodeList        _nodeList;  \/\/ List of SDG Nodes for Care Signals$/;"	m	class:V3SDG
_nodeV	bdd/bddNodeV.h	/^   size_t                  _nodeV;$/;"	m	class:BddNodeV
_ntk	itp/sat.h	/^      const V3Ntk* const  _ntk;       \/\/ Network Under Verification$/;"	m	class:SatSolver
_ntk	itp/satMgr.h	/^    V3Ntk* _ntk;$/;"	m	class:SATMgr
_ntk	ntk/v3NtkHandler.h	/^      V3Ntk*               _ntk;          \/\/ Ntk Derived From Parent$/;"	m	class:V3NtkHandler
_ntk	pdr/pdrMgr.h	/^    V3Ntk*                    _ntk;$/;"	m	class:PDRMgr
_ntk	pdr/v3SvrPDRSat.h	/^      V3Ntk*                    _ntk;       \/\/ Network Under Verification$/;"	m	class:V3SvrPDRSat
_ntk	svr/v3SvrBase.h	/^      const V3Ntk* const   _ntk;       \/\/ Network Under Verification$/;"	m	class:V3SvrBase
_ntkData	itp/sat.h	/^      vector<Var>*        _ntkData;   \/\/ Mapping between V3NetId and Solver Data$/;"	m	class:SatSolver
_ntkData	pdr/v3SvrPDRSat.h	/^      V3SvrMVarData*            _ntkData;   \/\/ Mapping between V3NetId and Solver Data (Vars)$/;"	m	class:V3SvrPDRSat
_ntkData	svr/v3SvrBoolector.h	/^      V3BtorExpTable _ntkData;   \/\/ Mapping between V3NetId and Solver Data$/;"	m	class:V3SvrBoolector
_ntkData	svr/v3SvrMiniSat.h	/^      V3SvrMVarTable _ntkData;   \/\/ Mapping between V3NetId and Solver Data$/;"	m	class:V3SvrMiniSat
_ntkGenStat	vrf/v3VrfKLive.h	/^      V3Stat*           _ntkGenStat;      \/\/ Network Generation$/;"	m	class:V3VrfKLive
_ntkHandlerList	ntk/v3NtkHandler.h	/^      V3HandlerVec   _ntkHandlerList;  \/\/ Ntk Handler List$/;"	m	class:V3Handler
_ntkModule	ntk/v3Ntk.h	/^      V3NtkModuleVec _ntkModule;    \/\/ Module Instance for Hierarchical Ntk$/;"	m	class:V3Ntk
_ntkName	ntk/v3NtkHandler.h	/^      string               _ntkName;      \/\/ Name of Input Ntk  (Need not to be unique)$/;"	m	class:V3NtkHandler
_ntkName	trans/v3NtkMiter.h	/^      const string   _ntkName;$/;"	m	class:V3NtkMiter
_numBuckets	bdd/myHash.h	/^   size_t                   _numBuckets;$/;"	m	class:Hash
_numOfCores	v3mc/v3MCMain.h	/^      V3UI32Vec               _numOfCores;   \/\/ Total Available Cores$/;"	m	class:V3MCResource
_one	bdd/bddNodeV.cpp	/^BddNodeV BddNodeV::_one;$/;"	m	class:BddNodeV	file:
_one	bdd/bddNodeV.h	/^   static BddNodeV          _one;$/;"	m	class:BddNodeV
_opTable	ext/v3Formula.cpp	/^V3OperatorMap V3Formula::_opTable   = V3Formula::initializeOperatorMap();$/;"	m	class:V3Formula	file:
_opTable	ext/v3Formula.h	/^      static V3OperatorMap    _opTable;$/;"	m	class:V3Formula
_optCmd	cmd/v3CmdMgr.h	/^      vector<string>    _optCmd;$/;"	m	class:V3CmdExec
_orderMap	alg/v3AlgSimulate.h	/^      V3NetVec                   _orderMap;$/;"	m	class:V3AlgSimulate
_outIndexHash	ntk/v3NtkHandler.h	/^      V3IdxStrHash         _outIndexHash; \/\/ Hash Table for Output Names from Output Indices$/;"	m	class:V3NtkHandler
_outNameHash	ntk/v3NtkHandler.h	/^      V3StrIdxHash         _outNameHash;  \/\/ Hash Table for Primary Outputs from Output Names$/;"	m	class:V3NtkHandler
_outfile	util/v3Msg.h	/^      ofstream          _outfile;$/;"	m	class:V3Msg
_outputs	ntk/v3Ntk.h	/^      V3NetVec    _outputs;$/;"	m	class:V3NtkModule
_p2cMap	ext/v3NtkElaborate.h	/^      V3NetVec          _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkElaborate
_p2cMap	ntk/v3NtkHandler.h	/^            V3NetVec             _p2cMap;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_p2cMap	ntk/v3NtkSimplify.h	/^      V3NetVec    _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkSimplify
_p2cMap	trans/v3BvBlastAig.h	/^      V3NetTable     _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3BvBlastAig
_p2cMap	trans/v3BvBlastBv.h	/^      V3BvBlastBvMap    _p2cMap;       \/\/ Net Index Mapping From Parent to Current Ntk$/;"	m	class:V3BvBlastBv
_p2cMap	trans/v3NtkExpand.h	/^      V3NetTable     _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkExpand
_p2cMap	vrf/v3VrfSEC.h	/^      V3NetVec          _p2cMap;             \/\/ Mapping from old to new$/;"	m	class:V3VrfSEC
_pOutput	ext/v3NtkElaborate.h	/^      V3LTLFormulaVec   _pOutput;   \/\/ List of V3LTLFormula* for Corresponding Elaborated Output$/;"	m	class:V3NtkElaborate
_parentId	ntk/v3NtkHandler.h	/^            const uint32_t       _parentId;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_pdrActBackup	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrActBackup;    \/\/ Incremental Backup of _pdrActCount$/;"	m	class:V3VrfIPDR
_pdrActCount	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrActCount;     \/\/ List of Activation Variable Counts$/;"	m	class:V3VrfIPDR
_pdrActCount	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrActCount;     \/\/ Activation Variable Count$/;"	m	class:V3VrfMPDR
_pdrAttr	vrf/v3VrfIPDR.h	/^      unsigned char     _pdrAttr;         \/\/ Specific Attributes for MPDR$/;"	m	class:V3VrfIPDR
_pdrAttr	vrf/v3VrfMPDR.h	/^      unsigned char     _pdrAttr;         \/\/ Specific Attributes for MPDR$/;"	m	class:V3VrfMPDR
_pdrBackup	vrf/v3VrfIPDR.h	/^      V3IPDRFrameVec    _pdrBackup;       \/\/ Incremental Backup of _pdrFrame$/;"	m	class:V3VrfIPDR
_pdrBackup	vrf/v3VrfMPDR.h	/^      V3MPDRFrameVec    _pdrBackup;       \/\/ Backup Frames for Reachability Reuse$/;"	m	class:V3VrfMPDR
_pdrBad	vrf/v3VrfIPDR.h	/^      V3IPDRCube*       _pdrBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfIPDR
_pdrBad	vrf/v3VrfMPDR.h	/^      V3MPDRCube*       _pdrBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfMPDR
_pdrFrame	vrf/v3VrfIPDR.h	/^      V3IPDRFrameVec    _pdrFrame;        \/\/ List of Frames (Ri) in Incremental PDR$/;"	m	class:V3VrfIPDR
_pdrFrame	vrf/v3VrfMPDR.h	/^      V3MPDRFrameVec    _pdrFrame;        \/\/ List of Frames (Ri) in Monolithic PDR$/;"	m	class:V3VrfMPDR
_pdrGen	vrf/v3VrfIPDR.h	/^      V3AlgGeneralize*  _pdrGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfIPDR
_pdrGen	vrf/v3VrfMPDR.h	/^      V3AlgGeneralize*  _pdrGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfMPDR
_pdrInitConst	vrf/v3VrfIPDR.h	/^      V3BoolVec         _pdrInitConst;    \/\/ Initial State of a State Variable (whether it is a const)$/;"	m	class:V3VrfIPDR
_pdrInitConst	vrf/v3VrfMPDR.h	/^      V3BoolVec         _pdrInitConst;    \/\/ Initial State of a State Variable (whether it is a const)$/;"	m	class:V3VrfMPDR
_pdrInitValue	vrf/v3VrfIPDR.h	/^      V3BoolVec         _pdrInitValue;    \/\/ Initial State of a State Variable (value of the const)$/;"	m	class:V3VrfIPDR
_pdrInitValue	vrf/v3VrfMPDR.h	/^      V3BoolVec         _pdrInitValue;    \/\/ Initial State of a State Variable (value of the const)$/;"	m	class:V3VrfMPDR
_pdrPriority	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfIPDR
_pdrPriority	vrf/v3VrfMPDR.h	/^      V3UI32Vec         _pdrPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfMPDR
_pdrRecycle	vrf/v3VrfIPDR.h	/^      uint32_t          _pdrRecycle;      \/\/ Upper Bound to Recycle$/;"	m	class:V3VrfIPDR
_pdrRecycle	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrRecycle;      \/\/ Upper Bound to Recycle$/;"	m	class:V3VrfMPDR
_pdrSim	vrf/v3VrfIPDR.h	/^      V3AlgSimulate*    _pdrSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfIPDR
_pdrSim	vrf/v3VrfMPDR.h	/^      V3AlgSimulate*    _pdrSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfMPDR
_pdrSize	vrf/v3VrfIPDR.h	/^      uint32_t          _pdrSize;         \/\/ Input Size for the Instance$/;"	m	class:V3VrfIPDR
_pdrSize	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrSize;         \/\/ Input Size for the Instance$/;"	m	class:V3VrfMPDR
_pdrSvr	vrf/v3VrfIPDR.h	/^      V3IPDRSvrList     _pdrSvr;          \/\/ List of Incremental SAT Solvers$/;"	m	class:V3VrfIPDR
_pdrSvr	vrf/v3VrfMPDR.h	/^      V3SvrBase*        _pdrSvr;          \/\/ The Monolithic SAT Solver$/;"	m	class:V3VrfMPDR
_pdrSvrBackup	vrf/v3VrfIPDR.h	/^      V3IPDRSvrList     _pdrSvrBackup;    \/\/ Incremental Backup of _pdrSvr$/;"	m	class:V3VrfIPDR
_pdrSvrData	vrf/v3VrfIPDR.h	/^      V3SvrData         _pdrSvrData;      \/\/ Solver Data of the Latest Activation Variable$/;"	m	class:V3VrfIPDR
_pdrSvrData	vrf/v3VrfMPDR.h	/^      V3SvrData         _pdrSvrData;      \/\/ Solver Data of the Latest Activation Variable$/;"	m	class:V3VrfMPDR
_peakMem	util/v3Usage.h	/^      double   _peakMem;$/;"	m	class:V3Usage
_periodUsedTime	util/v3Usage.h	/^      double   _periodUsedTime;$/;"	m	class:V3Usage
_piGenStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _piGenStat;$/;"	m	class:V3TraceSimplify
_piUnrollStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _piUnrollStat;$/;"	m	class:V3TraceSimplify
_piValue	dfx/v3DfxSimplify.h	/^      V3SimTraceVec        _piValue;$/;"	m	class:V3TraceSimplify
_preDepth	vrf/v3VrfBMC.h	/^      uint32_t       _preDepth;     \/\/ Pre-Run Depth (default = 0)$/;"	m	class:V3VrfBMC
_preDepth	vrf/v3VrfUMC.h	/^      uint32_t       _preDepth;     \/\/ Pre-Run Depth (default = 0)$/;"	m	class:V3VrfUMC
_prevData	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _prevData;  \/\/ The Prev (fwd pointer) Element$/;"	m	class:V3GenBucket
_print	vrf/v3VrfShared.h	/^      const bool        _print;     \/\/ Enable Deep Bound Printing (Only Valid for Single Property)$/;"	m	class:V3VrfSharedBound
_printMutex	vrf/v3VrfShared.cpp	/^pthread_mutex_t V3VrfShared::_printMutex  = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:V3VrfShared	file:
_printMutex	vrf/v3VrfShared.h	/^      static pthread_mutex_t  _printMutex;   \/\/ Mutex for Output Messages$/;"	m	class:V3VrfShared
_prompt	cmd/v3CmdMgr.h	/^      string         _prompt;                \/\/ Current Command Prompt$/;"	m	class:V3CmdMgr
_propagateStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _propagateStat;   \/\/ Propagation$/;"	m	class:V3VrfIPDR
_propagateStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _propagateStat;   \/\/ Propagation$/;"	m	class:V3VrfMPDR
_property	ntk/v3NtkHandler.h	/^      V3PropertyMap        _property;     \/\/ Property List$/;"	m	class:V3NtkHandler
_proved	itp/satMgr.h	/^    uint32_t      _proved;$/;"	m	class:SatProofRes
_proved	pdr/pdrMgr.h	/^    uint32_t      _proved;$/;"	m	class:SatProofRes
_ptrMinisat	itp/satMgr.h	/^    SatSolver* _ptrMinisat;$/;"	m	class:SATMgr
_r	bdd/bddMgrV.h	/^   size_t     _r;$/;"	m	class:BddHashKeyV
_reachFail	stg/v3StgFSM.h	/^      V3BoolTable             _reachFail; \/\/ Transition Relation Table from Node Id to Node Id that are Unreachable$/;"	m	class:V3FSM
_reachStates	bdd/bddMgrV.h	/^   vector<BddNodeV> _reachStates;$/;"	m	class:BddMgrV
_reachSucc	stg/v3StgFSM.h	/^      V3BoolTable             _reachSucc; \/\/ Transition Relation Table from Node Id to Node Id that are Reachable$/;"	m	class:V3FSM
_ref	ntk/v3Ntk.h	/^      size_t      _ref;$/;"	m	class:V3NtkModule
_refCount	ntk/v3NtkHandler.h	/^      uint32_t             _refCount;$/;"	m	class:V3NtkHandler
_refCount	vrf/v3VrfShared.h	/^         uint32_t          _refCount;     \/\/ Reference Count$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_refIdMap	ntk/v3NtkHandler.h	/^      V3Vec<V3PairType>::Vec     _refIdMap;$/;"	m	class:V3NtkHierInfo
_refStat	util/v3Usage.h	/^      V3Stat* const  _refStat;$/;"	m	class:V3Stat
_remaining	v3mc/v3MCMain.h	/^      V3UI32Vec               _remaining;    \/\/ Remaining Properties$/;"	m	class:V3MCResource
_res	v3mc/v3MCMain.h	/^   V3MCResource*        _res;          \/\/ Resource Data$/;"	m	struct:V3MCMainParam
_result	ext/v3Property.h	/^      V3VrfResult          _result;$/;"	m	class:V3Property
_result	v3mc/v3MCMain.h	/^      V3VrfResultVec    _result;    \/\/ Verification results (i.e. cex or inv, will be deleted after output)$/;"	m	class:V3MCResult
_result	v3mc/v3MCMain.h	/^   V3MCResult*          _result;       \/\/ Verification Results$/;"	m	struct:V3MCMainParam
_result	vrf/v3VrfBase.h	/^      V3VrfResultVec             _result;$/;"	m	class:V3VrfBase
_right	bdd/bddNodeV.h	/^   BddNodeV              _right;$/;"	m	class:BddNodeVInt
_rootId	ext/v3Formula.h	/^      uint32_t                _rootId;$/;"	m	class:V3Formula
_rootId	ext/v3LTLFormula.h	/^      uint32_t             _rootId;$/;"	m	class:V3LTLFormula
_runTime	pdr/v3SvrPDRSat.h	/^      double                    _runTime;   \/\/ Total Runtime in Solving$/;"	m	class:V3SvrPDRSat
_runTime	svr/v3SvrBase.h	/^      double               _runTime;   \/\/ Total Runtime in Solving$/;"	m	class:V3SvrBase
_satSolver	itp/satMgr.h	/^    SatSolver*    _satSolver;$/;"	m	class:SatProofRes
_satSolver	pdr/pdrMgr.h	/^    V3SvrPDRSat*  _satSolver;$/;"	m	class:SatProofRes
_saved	ext/v3NtkElaborate.h	/^      V3NetId           _saved;     \/\/ V3NetId of State Recorded Latch$/;"	m	class:V3NtkElaborate
_sdgDB	stg/v3StgFSM.h	/^      V3FSMSDGDB* const       _sdgDB;     \/\/ Main FSMSDGDB for FSM Extraction$/;"	m	class:V3FSM
_sdgDBList	stg/v3StgExtract.h	/^      V3FSMSDGDBList       _sdgDBList; \/\/ List of FSMSDGDB from Each Cluster$/;"	m	class:V3FSMExtract
_sdgList	stg/v3StgFSM.h	/^      V3FSMSDGList            _sdgList;   \/\/ List of Computed FSMSDGs for V3FSM$/;"	m	class:V3FSMSDGDB
_sdgMain	stg/v3StgExtract.h	/^      V3SDG* const         _sdgMain;   \/\/ Main SDG for Variable Clustering$/;"	m	class:V3FSMExtract
_sdgMain	stg/v3StgFSM.h	/^      V3SDG* const            _sdgMain;   \/\/ Main SDG Extracted from the Network$/;"	m	class:V3FSMSDGDB
_secCandidate	vrf/v3VrfSEC.h	/^      V3NetTable        _secCandidate;       \/\/ List of SEC Candidates$/;"	m	class:V3VrfSEC
_secCheckFail	vrf/v3VrfSEC.h	/^      V3BoolVec         _secCheckFail;       \/\/ List of Undecided Candidates$/;"	m	class:V3VrfSEC
_secChecker	vrf/v3VrfSEC.h	/^      V3VrfBase*        _secChecker;         \/\/ Formal Engine for SEC$/;"	m	class:V3VrfSEC
_secEQSize	vrf/v3VrfSEC.h	/^      uint32_t          _secEQSize;          \/\/ Number of Proven EQ Sets$/;"	m	class:V3VrfSEC
_secHandler	vrf/v3VrfSEC.h	/^      V3NtkHandler*     _secHandler;         \/\/ SEC Network Handler$/;"	m	class:V3VrfSEC
_secNtk	vrf/v3VrfSEC.h	/^      V3Ntk*            _secNtk;             \/\/ SEC Network$/;"	m	class:V3VrfSEC
_secSim	vrf/v3VrfSEC.h	/^      V3AlgSimulate*    _secSim;             \/\/ Simulator for SEC$/;"	m	class:V3VrfSEC
_shadow	ext/v3NtkElaborate.h	/^      V3NetVec          _shadow;    \/\/ V3NetId of Shadow Latches$/;"	m	class:V3NtkElaborate
_sharedBound	v3mc/v3MCMain.h	/^   V3VrfSharedBound*    _sharedBound;  \/\/ Shared Bound of Checkers$/;"	m	struct:V3MCMainParam
_sharedBound	vrf/v3VrfBase.h	/^      V3VrfSharedBound*          _sharedBound;$/;"	m	class:V3VrfBase
_sharedInv	v3mc/v3MCMain.h	/^   V3VrfSharedInv*      _sharedInv;    \/\/ Shared Cube Invariants$/;"	m	struct:V3MCMainParam
_sharedInv	vrf/v3VrfBase.h	/^      V3VrfSharedInv*            _sharedInv;$/;"	m	class:V3VrfBase
_sharedMem	v3mc/v3MCMain.h	/^   V3VrfSharedMem*      _sharedMem;    \/\/ Shared Memory Usage$/;"	m	struct:V3MCMainParam
_sharedMem	vrf/v3VrfBase.h	/^      V3VrfSharedMem*            _sharedMem;$/;"	m	class:V3VrfBase
_sharedNtk	v3mc/v3MCMain.h	/^   V3VrfSharedNtk*      _sharedNtk;    \/\/ Shared Network Data$/;"	m	struct:V3MCMainParam
_sharedNtk	vrf/v3VrfBase.h	/^      V3VrfSharedNtk*            _sharedNtk;$/;"	m	class:V3VrfBase
_shift	adt/v3Misc.h	/^      const uint32_t       _shift;$/;"	m	class:V3PortableType
_signature	dfx/v3DfxTrace.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3DfxCube
_signature	vrf/v3VrfCITP.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3CITPCube
_signature	vrf/v3VrfFITP.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3FITPCube
_signature	vrf/v3VrfIPDR.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3IPDRCube
_signature	vrf/v3VrfMPDR.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3MPDRCube
_simRecord	alg/v3AlgSimulate.h	/^      V3AigSimRecordVec _simRecord;    \/\/ Simulation Value Record$/;"	m	class:V3AlgAigSimulate
_simRecord	alg/v3AlgSimulate.h	/^      V3BvSimRecordVec  _simRecord;    \/\/ Simulation Value Record$/;"	m	class:V3AlgBvSimulate
_simStat	vrf/v3VrfSEC.h	/^      V3Stat*           _simStat;            \/\/ Simulation$/;"	m	class:V3VrfSEC
_simValue	alg/v3AlgSimulate.h	/^      V3AigSimDataVec   _simValue;     \/\/ Simulation Value for Ntk$/;"	m	class:V3AlgAigSimulate
_simValue	alg/v3AlgSimulate.h	/^      V3BvSimDataVec    _simValue;     \/\/ Simulation Value for Ntk$/;"	m	class:V3AlgBvSimulate
_simpStat	vrf/v3VrfSEC.h	/^      V3Stat*           _simpStat;           \/\/ Simplification$/;"	m	class:V3VrfSEC
_simulator	stg/v3StgFSM.h	/^      V3AlgSimulate* const    _simulator; \/\/ Simulator for (Semi-) Random Reachability Analysis$/;"	m	class:V3FSM
_size	adt/v3BitVec.h	/^      unsigned          _size;$/;"	m	class:V3BitVec
_size	adt/v3BitVec.h	/^      unsigned          _size;$/;"	m	class:V3BitVecX
_size	adt/v3Bucket.h	/^      uint32_t       _size;$/;"	m	class:V3BucketList
_size	adt/v3Bucket.h	/^      uint32_t       _size;$/;"	m	class:V3IncBucketList
_size	adt/v3Misc.h	/^      const uint32_t       _size;$/;"	m	class:V3PortableType
_size	bdd/myHash.h	/^   size_t         _size;$/;"	m	class:Cache
_size	ext/v3Property.h	/^      const uint32_t    _size;$/;"	m	class:V3CexTrace
_solveStat	vrf/v3VrfCITP.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfCITP
_solveStat	vrf/v3VrfFITP.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfFITP
_solveStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfIPDR
_solveStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfMPDR
_solver	itp/sat.h	/^      SolverV            *_solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:SatSolver
_solver	stg/v3StgFSM.h	/^      V3SvrBase* const        _solver;    \/\/ SAT Solver for Formal Confirmation$/;"	m	class:V3FSM
_solver	stg/v3StgFSM.h	/^      V3SvrBase* const        _solver;    \/\/ SAT Solver for Formal Confirmation$/;"	m	class:V3FSMSDGDB
_solver	vrf/v3VrfUMC.h	/^      V3SvrBase*     _solver;       \/\/ Single Instance SAT Solver$/;"	m	class:V3VrfUMC
_solverType	vrf/v3VrfBase.h	/^      V3SolverType               _solverType;$/;"	m	class:V3VrfBase
_solves	pdr/v3SvrPDRSat.h	/^      uint32_t                  _solves;    \/\/ Number of Solve Called$/;"	m	class:V3SvrPDRSat
_solves	svr/v3SvrBase.h	/^      uint32_t             _solves;    \/\/ Number of Solve Called$/;"	m	class:V3SvrBase
_specuStat	vrf/v3VrfSEC.h	/^      V3Stat*           _specuStat;          \/\/ Speculative Reduction$/;"	m	class:V3VrfSEC
_startTime	util/v3Usage.h	/^      double         _startTime;$/;"	m	class:V3Stat
_statName	util/v3Usage.h	/^      const string   _statName;$/;"	m	class:V3Stat
_stateId	dfx/v3DfxTrace.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3DfxCube
_stateId	vrf/v3VrfCITP.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3CITPCube
_stateId	vrf/v3VrfFITP.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3FITPCube
_stateId	vrf/v3VrfIPDR.h	/^      V3NetVec                _stateId;      \/\/ State Variable Index (id) with Value (cp)$/;"	m	class:V3IPDRCube
_stateId	vrf/v3VrfMPDR.h	/^      V3NetVec                _stateId;      \/\/ State Variable Index (id) with Value (cp)$/;"	m	class:V3MPDRCube
_supports	bdd/bddMgrV.h	/^   vector<BddNodeV> _supports;$/;"	m	class:BddMgrV
_tBase	stg/v3StgSDG.h	/^      V3SDGBase* const  _tBase;        \/\/ Base Structure for True Part of MUX$/;"	m	class:V3SDGMUX
_target	dfx/v3DfxSimplify.h	/^      V3NetVec             _target;$/;"	m	class:V3TraceSimplify
_targetId	alg/v3AlgGeneralize.h	/^      V3NetVec             _targetId;  \/\/ Resolved Target NetId$/;"	m	class:V3AlgAigGeneralize
_targetId	alg/v3AlgGeneralize.h	/^      V3NetVec             _targetId;  \/\/ Resolved Target NetId$/;"	m	class:V3AlgBvGeneralize
_targets	alg/v3AlgSimulate.h	/^      V3NetVec                   _targets;$/;"	m	class:V3AlgSimulate
_terminal	bdd/bddNodeV.cpp	/^BddNodeVInt* BddNodeVInt::_terminal = 0;$/;"	m	class:BddNodeVInt	file:
_terminal	bdd/bddNodeV.h	/^   static BddNodeVInt*   _terminal;$/;"	m	class:BddNodeVInt
_terminal	stg/v3StgFSM.h	/^      V3NetVec                _terminal;  \/\/ Set of Terminal (or Bug) States for the FSM$/;"	m	class:V3FSM
_terminals	stg/v3StgExtract.h	/^      V3NetVec             _terminals; \/\/ List of Terminal (Bug) States$/;"	m	class:V3FSMExtract
_ternaryStat	vrf/v3VrfCITP.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfCITP
_ternaryStat	vrf/v3VrfFITP.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfFITP
_ternaryStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfIPDR
_ternaryStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfMPDR
_threadIdx	v3mc/v3MCMain.h	/^   uint32_t             _threadIdx;    \/\/ Index of the Checker Thread$/;"	m	struct:V3MCParam
_timeAccum	util/v3Usage.h	/^      double         _timeAccum;$/;"	m	class:V3Stat
_totalMem	util/v3Usage.h	/^      double   _totalMem;$/;"	m	class:V3Usage
_totalStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _totalStat;$/;"	m	class:V3TraceSimplify
_totalStat	vrf/v3VrfCITP.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfCITP
_totalStat	vrf/v3VrfFITP.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfFITP
_totalStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfIPDR
_totalStat	vrf/v3VrfKLive.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic$/;"	m	class:V3VrfKLive
_totalStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfMPDR
_totalStat	vrf/v3VrfSEC.h	/^      V3Stat*           _totalStat;          \/\/ Total Statistic$/;"	m	class:V3VrfSEC
_totalUsedTime	util/v3Usage.h	/^      double   _totalUsedTime;$/;"	m	class:V3Usage
_tr	bdd/bddMgrV.h	/^   BddNodeV         _tr;$/;"	m	class:BddMgrV
_traceData	alg/v3AlgSimulate.h	/^      V3AigSimTraceVec  _traceData;    \/\/ Simulation Input Sequence$/;"	m	class:V3AlgAigSimulate
_traceData	alg/v3AlgSimulate.h	/^      V3BvSimTraceVec   _traceData;    \/\/ Simulation Input Sequence$/;"	m	class:V3AlgBvSimulate
_traverse	alg/v3AlgGeneralize.h	/^      V3BoolVec            _traverse;  \/\/ Traversed Net Table$/;"	m	class:V3AlgAigGeneralize
_traverse	alg/v3AlgGeneralize.h	/^      V3BoolVec            _traverse;  \/\/ Traversed Net Table$/;"	m	class:V3AlgBvGeneralize
_tri	bdd/bddMgrV.h	/^   BddNodeV         _tri;$/;"	m	class:BddMgrV
_trueSDG	stg/v3StgFSM.h	/^      V3FSMSDGSet             _trueSDG;   \/\/ Set of SDG for the TRUE Part$/;"	m	class:V3FSMSDG
_trueSize	stg/v3StgFSM.h	/^      uint32_t                _trueSize;  \/\/ Size of the True States$/;"	m	class:V3FSMSDG
_type	v3mc/v3MCMain.h	/^   V3MCMainType         _type;         \/\/ Type of the Main Thread$/;"	m	struct:V3MCMainParam
_typeMisc	ntk/v3Ntk.h	/^      V3TypeVec      _typeMisc;     \/\/ GateType with Misc Data$/;"	m	class:V3Ntk
_umcAttr	vrf/v3VrfUMC.h	/^      unsigned char  _umcAttr;      \/\/ Special Settings for UMC$/;"	m	class:V3VrfUMC
_undecided	alg/v3AlgGeneralize.h	/^      V3NetList            _undecided; \/\/ Extensibility Records$/;"	m	class:V3AlgGeneralize
_uniAssump	vrf/v3VrfUMC.h	/^      V3SvrDataTable _uniAssump;    \/\/ Assumptions to Enable Uniqueness for Every Pair [depth][uniIndex]$/;"	m	class:V3VrfUMC
_uniLatch	vrf/v3VrfUMC.h	/^      V3UI32Vec      _uniLatch;     \/\/ Upper Bound of Depth for the Existence of Latch in the Solver$/;"	m	class:V3VrfUMC
_uniList	vrf/v3VrfUMC.h	/^      V3UI32Vec      _uniList;      \/\/ List of Uniqueness Bounds  (Indexed by uniIndex)$/;"	m	class:V3VrfUMC
_uniqueTable	bdd/bddMgrV.h	/^   BddHash          _uniqueTable;$/;"	m	class:BddMgrV
_unsvd	vrf/v3VrfShared.h	/^      uint32_t          _unsvd;     \/\/ Number of Unsolved Properties$/;"	m	class:V3VrfSharedBound
_usedCores	v3mc/v3MCMain.h	/^      V3UI32Vec               _usedCores;    \/\/ Occupied Core Numbers$/;"	m	class:V3MCResource
_var2Cube	alg/v3AlgGeneralize.h	/^      V3UI32Table       _var2Cube;$/;"	m	class:V3GenStruct
_var2Net	itp/satMgr.h	/^    map<Var, V3NetId> _var2Net;    \/\/ mapping common variables to net$/;"	m	class:SATMgr
_varGroup	itp/satMgr.h	/^    mutable vector<VAR_GROUP> _varGroup;   \/\/ mapping var to different groups$/;"	m	class:SATMgr
_varOrder	alg/v3AlgGeneralize.h	/^      V3GenVarOrder     _varOrder;$/;"	m	class:V3GenStruct
_varValue	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _varValue;$/;"	m	class:V3GenStruct
_vrfNtk	vrf/v3VrfBase.h	/^      V3Ntk*                     _vrfNtk;$/;"	m	class:V3VrfBase
_zero	bdd/bddNodeV.cpp	/^BddNodeV BddNodeV::_zero;$/;"	m	class:BddNodeV	file:
_zero	bdd/bddNodeV.h	/^   static BddNodeV          _zero;$/;"	m	class:BddNodeV
activity	pdr/SolverTypesV.h	/^    float&    activity    ()      const { return *((float*)&data[size()]); }$/;"	f	class:Clause
activity	pdr/SolverV.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:SolverV
activity	pdr/VarOrderV.h	/^    const vec<double>&  activity;    \/\/ var->act. Pointer to external activity table.$/;"	m	class:VarOrder
activity	pdr/VarOrderV.h	/^    const vec<double>&  activity;$/;"	m	struct:VarOrder_lt
add	adt/v3Bucket.h	/^V3BucketList<T>::add(const uint32_t& index, const T& t) {$/;"	f	class:V3BucketList
add	adt/v3Bucket.h	/^V3IncBucketList<T>::add(const V3UI32Vec& iList, const Bucket& tList) {$/;"	f	class:V3IncBucketList
add	adt/v3Bucket.h	/^V3IncBucketList<T>::add(const uint32_t& index, const T& t) {$/;"	f	class:V3IncBucketList
addBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::addBddNodeV(const string& str, size_t n)$/;"	f	class:BddMgrV
addBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::addBddNodeV(unsigned id, size_t n)$/;"	f	class:BddMgrV
addBinary	pdr/SolverV.h	/^    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }$/;"	f	class:SolverV
addBinary_tmp	pdr/SolverV.h	/^    vec<Lit>            addBinary_tmp;$/;"	m	class:SolverV
addBlockedCube	pdr/pdrMgr.cpp	/^void PDRMgr::addBlockedCube(TCube s) {$/;"	f	class:PDRMgr
addBlockedCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::addBlockedCube(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
addBlockedCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::addBlockedCube(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
addBlockedCube	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addBlockedCube(const V3IPDRTimedCube& cube) {$/;"	f	class:V3VrfIPDR
addBlockedCube	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addBlockedCube(const V3MPDRTimedCube& cube) {$/;"	f	class:V3VrfMPDR
addBoundedVerifyData	itp/sat.cpp	/^void SatSolver::addBoundedVerifyData(const V3NetId& id, uint32_t& depth)$/;"	f	class:SatSolver
addBoundedVerifyData	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::addBoundedVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
addBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addBoundedVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
addBoundedVerifyDataRecursively	itp/sat.cpp	/^void SatSolver::addBoundedVerifyDataRecursively(const V3NetId& id, uint32_t& depth)$/;"	f	class:SatSolver
addBoundedVerifyDataRecursively	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::addBoundedVerifyDataRecursively(const V3NetId& id, uint32_t& depth)$/;"	f	class:V3SvrPDRSat
addClause	pdr/SolverV.h	/^    void    addClause (const vec<Lit>& ps )  { if (okay()) newClause(ps); }  \/\/ (used to be a difference between internal and external method...)$/;"	f	class:SolverV
addCubeToSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addCubeToSolver(const uint32_t& frame, const V3NetVec& state, const uint32_t& d) {$/;"	f	class:V3VrfIPDR
addCubeToSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addCubeToSolver(const V3NetVec& state, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
addFalseSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::addFalseSDG(V3FSMSDG* const& s) {$/;"	f	class:V3FSMSDG
addFrameInfoToSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addFrameInfoToSolver(const uint32_t& f) {$/;"	f	class:V3VrfMPDR
addHistory	cmd/v3CmdMgr.cpp	/^V3CmdMgr::addHistory(char* cmd) {$/;"	f	class:V3CmdMgr
addInitiateState	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::addInitiateState() {$/;"	f	class:V3SvrPDRSat
addLastFrameInfoToSolvers	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addLastFrameInfoToSolvers() {$/;"	f	class:V3VrfIPDR
addNextStateSToSolver	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::addNextStateSToSolver(Cube* c, vector<Lit>& Lit_vec_origin) {$/;"	f	class:V3SvrPDRSat
addNotSToSolver	pdr/v3SvrPDRSat.cpp	/^Var V3SvrPDRSat::addNotSToSolver(Cube* c) {$/;"	f	class:V3SvrPDRSat
addRoot	pdr/ProofV.cpp	/^ClauseId Proof::addRoot(vec<Lit>& cl)$/;"	f	class:Proof
addSimpleBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addSimpleBoundedVerifyData(V3NetId id, uint32_t depth) {$/;"	f	class:V3SvrBase
addSimulationTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::addSimulationTrace(const V3CexTrace& cex, const bool& checkValid) {$/;"	f	class:V3VrfSEC
addSimulationTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::addSimulationTrace(const V3SimTrace& initData, const V3VrfSimTraceVec& traceData, const bool& checkValid) {$/;"	f	class:V3VrfSEC
addTernary	pdr/SolverV.h	/^    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }$/;"	f	class:SolverV
addTernary_tmp	pdr/SolverV.h	/^    vec<Lit>            addTernary_tmp;$/;"	m	class:SolverV
addTrueSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::addTrueSDG(V3FSMSDG* const& s) {$/;"	f	class:V3FSMSDG
addUniqueness	vrf/v3VrfUMC.cpp	/^V3VrfUMC::addUniqueness(const uint32_t& depth, const uint32_t& uIndex, const bool& force) {$/;"	f	class:V3VrfUMC
addUnit	pdr/SolverV.h	/^    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }$/;"	f	class:SolverV
addUnit_tmp	pdr/SolverV.h	/^    vec<Lit>            addUnit_tmp;$/;"	m	class:SolverV
addVerifyData	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::addVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
addVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_ADD_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_ADD_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_ADD_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_ADD_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_ADD_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_ADD_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_AND_Formula	itp/sat.cpp	/^void SatSolver::add_AND_Formula(const V3NetId& out, const uint32_t& depth)$/;"	f	class:SatSolver
add_AND_Formula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::add_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
add_AND_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_AND_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_AND_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_AND_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_CONST_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_CONST_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_CONST_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_CONST_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_CONST_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_CONST_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_DIV_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_DIV_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_DIV_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_DIV_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_DIV_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_DIV_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_EQUALITY_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_EQUALITY_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_EQUALITY_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_EQUALITY_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_EQUALITY_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_EQUALITY_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_FALSE_Formula	itp/sat.cpp	/^void SatSolver::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth)$/;"	f	class:SatSolver
add_FALSE_Formula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
add_FALSE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_FALSE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_FALSE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_FALSE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_FF_Formula	itp/sat.cpp	/^void SatSolver::add_FF_Formula(const V3NetId& out, const uint32_t& depth) $/;"	f	class:SatSolver
add_FF_Formula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::add_FF_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
add_FF_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_FF_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_FF_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_FF_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_FF_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_FF_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_GEQ_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_GEQ_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_GEQ_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_GEQ_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_GEQ_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_GEQ_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MERGE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MERGE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MERGE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MERGE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MERGE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MERGE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MODULO_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MODULO_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MODULO_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MODULO_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MODULO_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MODULO_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MULT_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MULT_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MULT_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MULT_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MULT_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MULT_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MUX_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MUX_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MUX_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MUX_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MUX_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MUX_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_PI_Formula	itp/sat.cpp	/^void SatSolver::add_PI_Formula(const V3NetId& out, const uint32_t& depth)$/;"	f	class:SatSolver
add_PI_Formula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::add_PI_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
add_PI_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_PI_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_PI_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_PI_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_PI_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_PI_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_AND_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_AND_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_AND_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_AND_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_OR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_OR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_OR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_OR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_OR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_OR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_XOR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_XOR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_XOR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_XOR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SHL_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SHL_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SHL_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SHL_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SHL_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SHL_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SHR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SHR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SHR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SHR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SHR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SHR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SLICE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SLICE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SLICE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SLICE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SLICE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SLICE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SUB_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SUB_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SUB_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SUB_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SUB_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SUB_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_XOR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_XOR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_XOR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_XOR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
aiger_decode	io/v3AigParser.cpp	/^unsigned aiger_decode(FILE* file) {$/;"	f
aiger_getnoneofch	io/v3AigParser.cpp	/^unsigned char aiger_getnoneofch(FILE* file) {$/;"	f
aiger_symbol	io/v3AigParser.cpp	/^bool aiger_symbol(FILE* file, unsigned char& c, uint32_t& index, string& name) {$/;"	f
all0	adt/v3BitVec.cpp	/^V3BitVec::all0() const {$/;"	f	class:V3BitVec
all0	adt/v3BitVec.cpp	/^V3BitVecX::all0() const {$/;"	f	class:V3BitVecX
all1	adt/v3BitVec.cpp	/^V3BitVec::all1() const {$/;"	f	class:V3BitVec
all1	adt/v3BitVec.cpp	/^V3BitVecX::all1() const {$/;"	f	class:V3BitVecX
allX	adt/v3BitVec.cpp	/^V3BitVecX::allX() const {$/;"	f	class:V3BitVecX
allX	adt/v3BitVec.h	/^      inline const bool allX() const { return !_data0 && !_data1; }$/;"	f	class:V3BitVecS
allocSolver	svr/v3SvrHandler.cpp	/^V3SvrBase* const allocSolver(const V3SolverType& type, const V3Ntk* const ntk, const bool& freeBound) {$/;"	f
analyze	pdr/SolverV.cpp	/^void SolverV::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:SolverV
analyzeFinal	pdr/SolverV.cpp	/^void SolverV::analyzeFinal(Clause* confl, bool skip_first)$/;"	f	class:SolverV
analyze_removable	pdr/SolverV.cpp	/^bool SolverV::analyze_removable(Lit p, uint min_level)$/;"	f	class:SolverV
analyze_seen	pdr/SolverV.h	/^    vec<char>           analyze_seen;$/;"	m	class:SolverV
analyze_stack	pdr/SolverV.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:SolverV
analyze_tmpbin	pdr/SolverV.h	/^    Clause*             analyze_tmpbin;$/;"	m	class:SolverV
analyze_toclear	pdr/SolverV.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:SolverV
and_2	pdr/v3SvrPDRSat.cpp	/^inline void and_2(SolverV* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
and_2	svr/v3SvrSatHelper.h	/^inline void and_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
and_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId and_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
and_red	svr/v3SvrSatHelper.h	/^inline void and_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
and_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId and_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
applyAuxNetNamePrefix	ntk/v3NtkHandler.cpp	/^V3NtkHandler::applyAuxNetNamePrefix(const string& name) {$/;"	f	class:V3NtkHandler
assertBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::assertBoundedVerifyData(const V3NetVec& assertIdVec, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assertCubeUNSAT	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::assertCubeUNSAT(Cube*c, uint d) {$/;"	f	class:V3SvrPDRSat
assertImplyUnion	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assertImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrPDRSat
assertImplyUnion	svr/v3SvrBase.cpp	/^V3SvrBase::assertImplyUnion(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
assertImplyUnion	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertImplyUnion(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
assertImplyUnion	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
assertInit	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assertInit() {$/;"	f	class:V3SvrPDRSat
assertInit	svr/v3SvrBase.cpp	/^V3SvrBase::assertInit() {$/;"	f	class:V3SvrBase
assertInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertInit() {$/;"	f	class:V3SvrBoolector
assertInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertInit() {$/;"	f	class:V3SvrMiniSat
assertProperty	itp/sat.cpp	/^void SatSolver::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth)$/;"	f	class:SatSolver
assertProperty	itp/sat.cpp	/^void SatSolver::assertProperty(const size_t& var, const bool& invert)$/;"	f	class:SatSolver
assertProperty	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
assertProperty	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assertProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrPDRSat
assertProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assertProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assertProperty(const size_t& var_exp, const bool& invert) {$/;"	f	class:V3SvrBase
assertProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
assertProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertProperty(const size_t& exp, const bool& invert) {$/;"	f	class:V3SvrBoolector
assertProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
assertProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrMiniSat
assigns	pdr/SolverV.h	/^    vec<char>           assigns;          \/\/ The current assignments (lbool:s stored as char:s).$/;"	m	class:SolverV
assigns	pdr/VarOrderV.h	/^    const vec<char>&    assigns;     \/\/ var->val. Pointer to external assignment table.$/;"	m	class:VarOrder
assume	pdr/SolverV.cpp	/^bool SolverV::assume(Lit p) {$/;"	f	class:SolverV
assumeInit	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assumeInit() {$/;"	f	class:V3SvrPDRSat
assumeInit	svr/v3SvrBase.cpp	/^V3SvrBase::assumeInit() {$/;"	f	class:V3SvrBase
assumeInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeInit() {$/;"	f	class:V3SvrBoolector
assumeInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeInit() {$/;"	f	class:V3SvrMiniSat
assumeProperty	itp/sat.cpp	/^void SatSolver::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth)$/;"	f	class:SatSolver
assumeProperty	itp/sat.cpp	/^void SatSolver::assumeProperty(const size_t& var, const bool& invert)$/;"	f	class:SatSolver
assumeProperty	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
assumeProperty	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assumeProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrPDRSat
assumeProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assumeProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assumeProperty(const size_t& var_exp, const bool& invert) {$/;"	f	class:V3SvrBase
assumeProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
assumeProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeProperty(const size_t& exp, const bool& invert) {$/;"	f	class:V3SvrBoolector
assumeProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
assumeProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrMiniSat
assumeReachability	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::assumeReachability(const unsigned& k) {$/;"	f	class:V3VrfMPDR
assumeRelease	itp/sat.cpp	/^void SatSolver::assumeRelease() { _assump.clear(); }$/;"	f	class:SatSolver
assumeRelease	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assumeRelease() { _assump.clear(); }$/;"	f	class:V3SvrPDRSat
assumeRelease	svr/v3SvrBase.cpp	/^V3SvrBase::assumeRelease() {$/;"	f	class:V3SvrBase
assumeRelease	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeRelease() {$/;"	f	class:V3SvrBoolector
assumeRelease	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeRelease() { _assump.clear(); }$/;"	f	class:V3SvrMiniSat
assump_solve	itp/sat.cpp	/^const bool SatSolver::assump_solve()$/;"	f	class:SatSolver
assump_solve	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::assump_solve() {$/;"	f	class:V3SvrPDRSat
assump_solve	svr/v3SvrBase.cpp	/^V3SvrBase::assump_solve() {$/;"	f	class:V3SvrBase
assump_solve	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assump_solve() {$/;"	f	class:V3SvrBoolector
assump_solve	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assump_solve() {$/;"	f	class:V3SvrMiniSat
attachNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::attachNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
attachToNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const attachToNtk(V3NtkHandler* const handler, V3Ntk* const ntk, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& c2pMap, V3PortableType& netHash) {$/;"	f
begin	bdd/myHash.h	/^   iterator begin() const {$/;"	f	class:Hash
beginChain	pdr/ProofV.cpp	/^void Proof::beginChain(ClauseId start)$/;"	f	class:Proof
bfsIndexFaninConeFF	ntk/v3NtkTraverse.cpp	/^void bfsIndexFaninConeFF(V3Ntk* const ntk, V3NetVec& ffList, const V3NetId& pId, V3BoolVec& m) {$/;"	f
bfsIndexFaninConeFF	ntk/v3NtkTraverse.cpp	/^void bfsIndexFaninConeFF(V3Ntk* const ntk, V3NetVec& ffList, const V3NetVec& sourceNets) {$/;"	f
bfsUpdateBackwardReachability	stg/v3StgFSM.cpp	/^V3FSM::bfsUpdateBackwardReachability() {$/;"	f	class:V3FSM
bfsUpdateForwardReachability	stg/v3StgFSM.cpp	/^V3FSM::bfsUpdateForwardReachability() {$/;"	f	class:V3FSM
bind	itp/satMgr.cpp	/^void SATMgr::bind(SatSolver* ptrMinisat) {$/;"	f	class:SATMgr
bitBlast_ADD	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_ADD(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_AND	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_AND(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_CONST	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_CONST(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_DIV	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_DIV(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_DIV_MODULO	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_DIV_MODULO(const V3BvNtk* const ntk, const V3NetId& id, const bool& setRemainder) {$/;"	f	class:V3BvBlastAig
bitBlast_EQUALITY	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_EQUALITY(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_FF	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_FF(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_GEQ	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_GEQ(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MERGE	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MERGE(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MODULO	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MODULO(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MULT	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MULT(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MUX	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MUX(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_AND	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_AND(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_OR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_OR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_XOR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_XOR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SHL	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SHL(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SHR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SHR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SLICE	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SLICE(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SUB	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SUB(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_XOR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_XOR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
blockBadCubes	vrf/v3VrfCITP.cpp	/^V3VrfCITP::blockBadCubes(const uint32_t& index) {$/;"	f	class:V3VrfCITP
blockBadCubes	vrf/v3VrfFITP.cpp	/^V3VrfFITP::blockBadCubes(const uint32_t& index) {$/;"	f	class:V3VrfFITP
blockCubeInSolver	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::blockCubeInSolver(TCube s) {$/;"	f	class:V3SvrPDRSat
blockNewCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::blockNewCube() {$/;"	f	class:V3VrfCITP
blockNewCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::blockNewCube() {$/;"	f	class:V3VrfFITP
borrow_2	svr/v3SvrSatHelper.h	/^inline void borrow_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& B)$/;"	f
borrow_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId borrow_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& B)$/;"	f
borrow_2_woB	svr/v3SvrSatHelper.h	/^inline void borrow_2_woB(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
borrow_2_woB	trans/v3BvBlastAigHelper.h	/^inline const V3NetId borrow_2_woB(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
bucketNum	bdd/myHash.h	/^   size_t bucketNum(const HashKey& k) const {$/;"	f	class:Hash
buckets	adt/v3Bucket.h	/^      inline const uint32_t buckets() const { return _elements.size(); }$/;"	f	class:V3BucketList
buckets	adt/v3Bucket.h	/^      inline const uint32_t buckets() const { return _elements.size(); }$/;"	f	class:V3IncBucketList
buf	itp/reader.h	/^	unsigned char* 	buf;$/;"	m	class:Reader
buf	pdr/FileV.h	/^    uchar*      buf;        \/\/ Read or write buffer.$/;"	m	class:File
buf	pdr/reader.h	/^	unsigned char* 	buf;$/;"	m	class:Reader
buf	pdr/v3SvrPDRSat.cpp	/^inline void buf(SolverV* SS, const Lit& a, const Lit& b)$/;"	f
buf	svr/v3SvrSatHelper.h	/^inline void buf(Solver* SS, const Lit& a, const Lit& b)$/;"	f
buf	trans/v3BvBlastAigHelper.h	/^inline const V3NetId buf(V3Ntk* const ntk, const V3NetId& a)$/;"	f
buildAllNtkVerifyData	pdr/pdrMgr.cpp	/^void PDRMgr::buildAllNtkVerifyData(const V3NetId& monitor) {$/;"	f	class:PDRMgr
buildBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::buildBdd(const V3NetId& netId) {$/;"	f	class:V3Ntk
buildInitState	itp/satMgr.cpp	/^V3NetId SATMgr::buildInitState() const $/;"	f	class:SATMgr
buildItp	itp/satMgr.cpp	/^V3NetId SATMgr::buildItp(const string& proofName) const {$/;"	f	class:SATMgr
buildNtkBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::buildNtkBdd() {$/;"	f	class:V3Ntk
buildPImage	prove/proveBdd.cpp	/^BddMgrV::buildPImage( int level )$/;"	f	class:BddMgrV
buildPInitialState	prove/proveBdd.cpp	/^BddMgrV::buildPInitialState()$/;"	f	class:BddMgrV
buildPTransRelation	prove/proveBdd.cpp	/^BddMgrV::buildPTransRelation()$/;"	f	class:BddMgrV
bus	ntk/v3Type.h	/^      uint32_t    bus[2];$/;"	m	union:V3PairType::__anon1
bv_and	adt/v3BitVec.cpp	/^V3BitVecS::bv_and(const V3BitVecS& v1, const bool& inv1, const V3BitVecS& v2, const bool& inv2) {$/;"	f	class:V3BitVecS
bv_concat	adt/v3BitVec.cpp	/^V3BitVecX::bv_concat(const V3BitVecX& a) const {$/;"	f	class:V3BitVecX
bv_cover	adt/v3BitVec.cpp	/^V3BitVecX::bv_cover(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_cover	adt/v3BitVec.h	/^      inline const bool bv_cover(const V3BitVecS& v) const { return !((_data0 & ~v._data0) | (_data1 & ~v._data1)); }$/;"	f	class:V3BitVecS
bv_divided_by	adt/v3BitVec.cpp	/^V3BitVecX::bv_divided_by(const V3BitVecX& b, const bool& setRemainder) {$/;"	f	class:V3BitVecX
bv_equal	adt/v3BitVec.cpp	/^V3BitVecX::bv_equal(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_full	adt/v3BitVec.h	/^      inline const bool bv_full() const { return (_data0 == 0ul || _data0 == ~0ul) && (_data1 == 0ul || _data1 == ~0ul); }$/;"	f	class:V3BitVecS
bv_geq	adt/v3BitVec.cpp	/^V3BitVecX::bv_geq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_gt	adt/v3BitVec.cpp	/^V3BitVecX::bv_gt(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_intersect	adt/v3BitVec.cpp	/^V3BitVecX::bv_intersect(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_leq	adt/v3BitVec.cpp	/^V3BitVecX::bv_leq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_lt	adt/v3BitVec.cpp	/^V3BitVecX::bv_lt(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_red_and	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_and() const {$/;"	f	class:V3BitVecX
bv_red_or	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_or() const {$/;"	f	class:V3BitVecX
bv_red_xor	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_xor() const {$/;"	f	class:V3BitVecX
bv_select	adt/v3BitVec.cpp	/^V3BitVecX::bv_select(const V3BitVecX& f, const V3BitVecX& t) const {$/;"	f	class:V3BitVecX
bv_slice	adt/v3BitVec.cpp	/^V3BitVecX::bv_slice(const unsigned& msb, const unsigned& lsb) const {$/;"	f	class:V3BitVecX
callEmptyVirtual	util/v3Msg.h	/^static inline const int callEmptyVirtual(const string& functionName) {$/;"	f
cancelUntil	pdr/SolverV.cpp	/^void SolverV::cancelUntil(int level) {$/;"	f	class:SolverV
cap	pdr/GlobalV.h	/^    int cap;$/;"	m	class:vec
capacity	pdr/GlobalV.h	/^    void     capacity (int size) { grow(size); }$/;"	f	class:vec
carry_2	svr/v3SvrSatHelper.h	/^inline void carry_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& c)$/;"	f
carry_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId carry_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& c)$/;"	f
carry_2_woc	svr/v3SvrSatHelper.h	/^inline void carry_2_woc(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
carry_2_woc	trans/v3BvBlastAigHelper.h	/^inline const V3NetId carry_2_woc(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
cchar	pdr/GlobalV.h	/^typedef const char    cchar;$/;"	t
chain	pdr/ProofV.h	/^    virtual void chain  (const vec<ClauseId>& cs, const vec<Var>& xs) {}$/;"	f	struct:ProofTraverser
chain_id	pdr/ProofV.h	/^    vec<ClauseId>   chain_id;$/;"	m	class:Proof
chain_var	pdr/ProofV.h	/^    vec<Var>        chain_var;$/;"	m	class:Proof
check	bdd/myHash.h	/^   bool check(const HashKey& k, HashData& n) const {$/;"	f	class:Hash
check	pdr/SolverV.h	/^inline void check(bool expr) { assert(expr); }$/;"	f
check	stg/v3StgFSM.cpp	/^V3FSM::check(V3SvrBase* const solver) const {$/;"	f	class:V3FSM
checkBMCReachability	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkBMCReachability(const V3NetVec& state) {$/;"	f	class:V3VrfCITP
checkBMCReachability	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkBMCReachability(const V3NetVec& state) {$/;"	f	class:V3VrfFITP
checkCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkCmd(const string& check) const {$/;"	f	class:V3CmdExec
checkCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkCommonCounterexample	vrf/v3VrfBase.cpp	/^V3VrfBase::checkCommonCounterexample(const uint32_t& p, const V3CexTrace& cex) {$/;"	f	class:V3VrfBase
checkCommonProof	vrf/v3VrfBase.cpp	/^V3VrfBase::checkCommonProof(const uint32_t& p, const V3NetTable& invList, const bool& checkInitial) {$/;"	f	class:V3VrfBase
checkCompleteFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::checkCompleteFSMs() const {$/;"	f	class:V3FSMExtract
checkCounterExample	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkCounterExample() {$/;"	f	class:V3VrfCITP
checkCounterExample	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkCounterExample() {$/;"	f	class:V3VrfFITP
checkIteTerminal	bdd/bddMgrV.cpp	/^BddMgrV::checkIteTerminal$/;"	f	class:BddMgrV
checkMandCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkMandCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkMem	util/v3Usage.h	/^      const double checkMem() const {$/;"	f	class:V3Usage
checkOptCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkOptCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkReachability	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkReachability(V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
checkReachability	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkReachability(const V3NetVec& state) {$/;"	f	class:V3VrfFITP
checkReachability	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::checkReachability(const uint32_t& frame, const V3NetVec& cubeState, const bool& extend) {$/;"	f	class:V3VrfIPDR
checkReachability	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::checkReachability(const uint32_t& frame, const V3NetVec& cubeState, const bool& extend) {$/;"	f	class:V3VrfMPDR
checkTick	util/v3Usage.h	/^      const double checkTick() const {$/;"	f	class:V3Usage
claBumpActivity	pdr/SolverV.h	/^    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }$/;"	f	class:SolverV
claDecayActivity	pdr/SolverV.h	/^    void     claDecayActivity  () { cla_inc *= cla_decay; }$/;"	f	class:SolverV
claRescaleActivity	pdr/SolverV.cpp	/^void SolverV::claRescaleActivity()$/;"	f	class:SolverV
cla_decay	pdr/SolverV.h	/^    double              cla_decay;        \/\/ INVERSE decay factor for clause activity: stores 1\/decay.$/;"	m	class:SolverV
cla_inc	pdr/SolverV.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:SolverV
clause	pdr/ProofV.h	/^    vec<Lit>        clause;$/;"	m	class:Proof
clause	pdr/SolverTypesV.h	/^    Clause*     clause   () const { return (Clause*)data; }$/;"	f	class:GClause
clause_decay	pdr/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
clauses	pdr/SolverV.h	/^    vec<Clause*>        clauses;          \/\/ List of problem clauses.$/;"	m	class:SolverV
clauses_literals	pdr/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
clear	adt/v3BitVec.cpp	/^V3BitVec::clear() {$/;"	f	class:V3BitVec
clear	adt/v3BitVec.cpp	/^V3BitVecX::clear() {$/;"	f	class:V3BitVecX
clear	adt/v3BitVec.h	/^      inline void clear() { _data0 = _data1 = 0; }$/;"	f	class:V3BitVecS
clear	adt/v3Bucket.h	/^V3BucketList<T>::clear() {$/;"	f	class:V3BucketList
clear	adt/v3Bucket.h	/^V3IncBucketList<T>::clear() {$/;"	f	class:V3IncBucketList
clear	alg/v3AlgGeneralize.cpp	/^V3GenStruct::clear(const V3NetVec& baseCube) {$/;"	f	class:V3GenStruct
clear	ext/v3Property.h	/^      inline void clear() { if (isCex()) delete getCexTrace(); \/*else if (isInv()) delete getIndInv();*\/ _cexOrInv = 0; }$/;"	f	class:V3VrfResult
clear	ntk/v3NtkHandler.h	/^      inline void clear() { clearMap(); _hierInfo.clear(); clearRefId(); }$/;"	f	class:V3NtkHierInfo
clear	pdr/GlobalV.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
clearCubeList	vrf/v3VrfCITP.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3CITPFrame
clearCubeList	vrf/v3VrfIPDR.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3IPDRFrame
clearCubeList	vrf/v3VrfMPDR.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3MPDRFrame
clearCutSignals	ntk/v3Ntk.h	/^      inline void clearCutSignals() { _cutSignals.clear(); }$/;"	f	class:V3Ntk
clearDepFF	stg/v3StgSDG.h	/^      inline void clearDepFF() { _depFFSet.clear(); }$/;"	f	class:V3SDGBase
clearDepMux	stg/v3StgSDG.h	/^      inline void clearDepMux() { _depMuxSet.clear(); }$/;"	f	class:V3SDGBase
clearGraph	adt/v3Graph.h	/^V3Graph<T>::clearGraph() {$/;"	f	class:V3Graph
clearMap	ntk/v3NtkHandler.h	/^      inline void clearMap() { for (uint32_t i = 0; i < getNtkSize(); ++i) delete _hierInfo[i]; }$/;"	f	class:V3NtkHierInfo
clearRefId	ntk/v3NtkHandler.h	/^      inline void clearRefId() { _refIdMap.clear(); }$/;"	f	class:V3NtkHierInfo
clearResult	vrf/v3VrfBase.h	/^      inline void clearResult(const uint32_t& i) { assert (i < _result.size()); _result[i].clear(); }$/;"	f	class:V3VrfBase
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::clearSource(const V3NetId& id, const bool& random) {$/;"	f	class:V3AlgAigSimulate
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::clearSource(const V3NetId& id, const bool& random) {$/;"	f	class:V3AlgBvSimulate
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::clearSource(const V3NetId& id, const bool& random) {}$/;"	f	class:V3AlgSimulate
clearState	vrf/v3VrfCITP.h	/^      inline void clearState() { _signature = 0; }$/;"	f	class:V3CITPCube
clearState	vrf/v3VrfFITP.h	/^      inline void clearState() { _signature = 0; }$/;"	f	class:V3FITPCube
close	itp/reader.cpp	/^void Reader::close(){$/;"	f	class:Reader
close	pdr/FileV.cpp	/^void File::close(void)$/;"	f	class:File
close	pdr/reader.cpp	/^void Reader::close(){$/;"	f	class:Reader
closeDofile	cmd/v3CmdMgr.h	/^      void closeDofile() { _dofile.close(); _dofile.clear(); }$/;"	f	class:V3CmdMgr
collectFaninFF	stg/v3StgSDG.cpp	/^V3SDG::collectFaninFF(V3SDGBase* const node, V3SDGBase* const depNode) {$/;"	f	class:V3SDG
collectFaninMuxFF	stg/v3StgSDG.cpp	/^V3SDG::collectFaninMuxFF(V3SDGBase* const node, V3SDGBase* const depNode) {$/;"	f	class:V3SDG
collectLeafFormula	ext/v3Formula.cpp	/^V3Formula::collectLeafFormula(V3UI32Set& netSet) const {$/;"	f	class:V3Formula
collectLeafFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::collectLeafFormula(V3UI32Set& netSet) const {$/;"	f	class:V3LTLFormula
collectStateNets	stg/v3StgFSM.cpp	/^V3FSM::collectStateNets(V3FSMSDG* const sdg, V3UI32Set& stateNets) const {$/;"	f	class:V3FSM
collectStateNets	stg/v3StgFSM.cpp	/^V3FSM::collectStateNets(V3UI32Set& stateNets) const {$/;"	f	class:V3FSM
combineConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineConstraints(const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
combineConstraintsToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineConstraintsToOutputs(const uint32_t& pIndex, const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
combineConstraintsToOutputs	v3mc/v3MCElaborate.cpp	/^void combineConstraintsToOutputs(V3Ntk* const ntk, const V3UI32Vec& poList, const V3NetVec& constr) {$/;"	f
combineFSMInvariantsToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineFSMInvariantsToOutputs(const uint32_t& pIndex, V3FSM* const fsm) {$/;"	f	class:V3NtkElaborate
combineInvariantToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineInvariantToOutputs(const uint32_t& pIndex, const V3NetVec& invList) {$/;"	f	class:V3NtkElaborate
comp	pdr/HeapV.h	/^    C        comp;$/;"	m	class:Heap
compare_generate	trans/v3BvBlastAigHelper.h	/^inline const V3NetId compare_generate(V3Ntk* const ntk, const V3NetVec& e, const V3NetVec& c)$/;"	f
compress	pdr/ProofV.cpp	/^void Proof::compress(Proof& dst, ClauseId goal)$/;"	f	class:Proof
computeFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::computeFSMSDG(V3FSMSDG* const mux, V3NetVec& parentNets) {$/;"	f	class:V3FSMSDGDB
computeFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::computeFSMSDG(const V3NetId& id, V3NetVec& parentNets, const V3FSMSDGMap& siblingMap) {$/;"	f	class:V3FSMSDGDB
computeFanout	ntk/v3NtkTraverse.cpp	/^void computeFanout(V3Ntk* const ntk, V3NetTable& outputTable, const V3NetVec& targetNets) {$/;"	f
computeLatchBoundsForUniqueness	vrf/v3VrfUMC.cpp	/^V3VrfUMC::computeLatchBoundsForUniqueness(const uint32_t& depth) {$/;"	f	class:V3VrfUMC
computeLevel	ntk/v3NtkTraverse.cpp	/^const uint32_t computeLevel(V3Ntk* const ntk, V3UI32Vec& levelData, const V3NetVec& targetNets) {$/;"	f
computeSimTrace	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::computeSimTrace(const V3CexTrace& cex) {$/;"	f	class:V3TraceSimplify
computeTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::computeTrace(const V3CexTrace& cex, V3SimTrace& initData, V3VrfSimTraceVec& traceData) {$/;"	f	class:V3VrfSEC
computeTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::computeTrace(const V3SimTrace& initData, const V3VrfSimTraceVec& traceData, const uint32_t& idx) {$/;"	f	class:V3VrfSEC
computeTraceData	dfx/v3DfxTrace.cpp	/^void computeTraceData(V3NtkHandler* const handler, const V3CexTrace& cex, V3SimTraceVec& inVec, V3SimTraceVec& flopVec) {$/;"	f
conflict	pdr/SolverV.h	/^    vec<Lit>    conflict;           \/\/ If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.$/;"	m	class:SolverV
conflict_id	pdr/SolverV.h	/^    ClauseId    conflict_id;        \/\/ (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.$/;"	m	class:SolverV
conflicts	pdr/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
consistencyCheck	vrf/v3VrfBase.cpp	/^V3VrfBase::consistencyCheck() const {$/;"	f	class:V3VrfBase
constructAigSDG	stg/v3StgSDG.cpp	/^V3AigSDG::constructAigSDG(const V3NetId& id, V3SDGBase* const n) {$/;"	f	class:V3AigSDG
constructBvSDG	stg/v3StgSDG.cpp	/^V3SDG::constructBvSDG(const V3NetId& id, V3SDGBase* const n) {$/;"	f	class:V3SDG
constructInputFSMSDG	stg/v3StgExtract.cpp	/^V3FSMExtract::constructInputFSMSDG(V3NtkHandler* const handler, const string& fileName) {$/;"	f	class:V3FSMExtract
constructSDG	stg/v3StgSDG.cpp	/^V3AigSDG::constructSDG(const V3NetId& id) {$/;"	f	class:V3AigSDG
constructSDG	stg/v3StgSDG.cpp	/^V3SDG::constructSDG(const V3NetId& id) {$/;"	f	class:V3SDG
constructStandardFSMSDG	stg/v3StgExtract.cpp	/^V3FSMExtract::constructStandardFSMSDG() {$/;"	f	class:V3FSMExtract
containNode	bdd/bddNodeV.cpp	/^BddNodeV::containNode(unsigned bLevel, unsigned eLevel) const$/;"	f	class:BddNodeV
containNodeRecur	bdd/bddNodeV.cpp	/^BddNodeV::containNodeRecur(unsigned bLevel, unsigned eLevel) const$/;"	f	class:BddNodeV
copy	adt/v3BitVec.cpp	/^V3BitVec::copy(V3BitVec& b) const {$/;"	f	class:V3BitVec
copy	adt/v3BitVec.cpp	/^V3BitVecX::copy(V3BitVecX& b) const {$/;"	f	class:V3BitVecX
copyTo	pdr/GlobalV.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
copyV3Ntk	ntk/v3NtkConstruct.cpp	/^V3Ntk* const copyV3Ntk(V3Ntk* const& ntk) {$/;"	f
countCube	bdd/bddNodeV.cpp	/^BddNodeV::countCube() const$/;"	f	class:BddNodeV
countCubeRecur	bdd/bddNodeV.cpp	/^BddNodeV::countCubeRecur(bool phase, map<size_t, size_t>& numCubeMap) const$/;"	f	class:BddNodeV
cp	ntk/v3Type.h	/^   uint32_t    cp :  1;$/;"	m	struct:V3NetId
cpuTime	pdr/GlobalV.h	/^static inline double cpuTime(void) {$/;"	f
createAigAndGate	ntk/v3NtkConstruct.cpp	/^const bool createAigAndGate(V3AigNtk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& id2) {$/;"	f
createAigFalseGate	ntk/v3NtkConstruct.cpp	/^const bool createAigFalseGate(V3AigNtk* const ntk, const V3NetId& id) {$/;"	f
createBvConstGate	ntk/v3NtkConstruct.cpp	/^const bool createBvConstGate(V3BvNtk* const ntk, const V3NetId& id, const string& value_exp) {$/;"	f
createBvMuxGate	ntk/v3NtkConstruct.cpp	/^const bool createBvMuxGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& fId, const V3NetId& tId, const V3NetId& sId) {$/;"	f
createBvPairGate	ntk/v3NtkConstruct.cpp	/^const bool createBvPairGate(V3BvNtk* const ntk, const V3GateType& type, const V3NetId& id, $/;"	f
createBvReducedGate	ntk/v3NtkConstruct.cpp	/^const bool createBvReducedGate(V3BvNtk* const ntk, const V3GateType& type, const V3NetId& id, const V3NetId& id1) {$/;"	f
createBvSliceGate	ntk/v3NtkConstruct.cpp	/^const bool createBvSliceGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& id1, uint32_t msb, uint32_t lsb) {$/;"	f
createClock	ntk/v3Ntk.cpp	/^V3Ntk::createClock(const V3NetId& id) {$/;"	f	class:V3Ntk
createConst	ntk/v3Ntk.cpp	/^V3Ntk::createConst(const V3NetId& id) {$/;"	f	class:V3Ntk
createConstrOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::createConstrOutputs(const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
createGate	ntk/v3Ntk.cpp	/^V3Ntk::createGate(const V3GateType& type, const V3NetId& id) {$/;"	f	class:V3Ntk
createIOExtensionGate	ntk/v3NtkConstruct.cpp	/^const bool createIOExtensionGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& id1) {$/;"	f
createInout	ntk/v3Ntk.cpp	/^V3Ntk::createInout(const V3NetId& id) {$/;"	f	class:V3Ntk
createInout	ntk/v3NtkConstruct.cpp	/^const bool createInout(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createInput	ntk/v3Ntk.cpp	/^V3Ntk::createInput(const V3NetId& id) {$/;"	f	class:V3Ntk
createInput	ntk/v3NtkConstruct.cpp	/^const bool createInput(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createLatch	ntk/v3Ntk.cpp	/^V3Ntk::createLatch(const V3NetId& id) {$/;"	f	class:V3Ntk
createModule	ntk/v3Ntk.cpp	/^V3Ntk::createModule(V3NtkModule* const module) {$/;"	f	class:V3Ntk
createModule	ntk/v3NtkConstruct.cpp	/^const bool createModule(V3Ntk* const ntk, const V3NetVec& inputs, const V3NetVec& outputs, $/;"	f
createNet	ntk/v3Ntk.cpp	/^V3BvNtk::createNet(const uint32_t& width) {$/;"	f	class:V3BvNtk
createNet	ntk/v3Ntk.cpp	/^V3Ntk::createNet(const uint32_t& width) {$/;"	f	class:V3Ntk
createNet	ntk/v3NtkConstruct.cpp	/^const V3NetId createNet(V3Ntk* const ntk, uint32_t width) {$/;"	f
createNet	ntk/v3NtkInput.cpp	/^V3NtkInput::createNet(const string& netName, uint32_t width) {$/;"	f	class:V3NtkInput
createNetExtensionGate	ntk/v3NtkConstruct.cpp	/^const V3NetId createNetExtensionGate(V3BvNtk* const ntk, const V3NetId& id, const uint32_t& width) {$/;"	f
createOutput	ntk/v3Ntk.cpp	/^V3Ntk::createOutput(const V3NetId& id) {$/;"	f	class:V3Ntk
createOutput	ntk/v3NtkConstruct.cpp	/^const bool createOutput(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createSDGFromSpec	stg/v3StgFSM.cpp	/^createSDGFromSpec(V3Ntk* const ntk, const V3StrVec& tokens, uint32_t& index) {$/;"	f
createSuccessor	ext/v3Formula.cpp	/^V3Formula::createSuccessor(V3NtkHandler* const handler) const {$/;"	f	class:V3Formula
createSuccessor	ext/v3LTLFormula.cpp	/^V3LTLFormula::createSuccessor(V3NtkHandler* const handler) const {$/;"	f	class:V3LTLFormula
createV3AndGate	ntk/v3NtkConstruct.cpp	/^const bool createV3AndGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& id2) {$/;"	f
createV3BufGate	ntk/v3NtkConstruct.cpp	/^const bool createV3BufGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1) {$/;"	f
createV3FFGate	ntk/v3NtkConstruct.cpp	/^const bool createV3FFGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& init_id) {$/;"	f
createV3Ntk	ntk/v3NtkConstruct.cpp	/^V3Ntk* const createV3Ntk(const bool& isBv) {$/;"	f
cycleSimulateResult	vrf/v3VrfResult.cpp	/^const int cycleSimulateResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
data	pdr/GlobalV.h	/^    T*  data;$/;"	m	class:vec
data	pdr/SolverTypesV.h	/^    Lit     data[1];$/;"	m	class:Clause
data	pdr/SolverTypesV.h	/^    void*   data;$/;"	m	class:GClause
dcBits	adt/v3BitVec.cpp	/^V3BitVecX::dcBits() const {$/;"	f	class:V3BitVecX
debug	pdr/v3SvrPDRSat.h	9;"	d
debugValues	stg/v3StgFSM.cpp	/^V3FSM::debugValues(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3FSM
decInstRef	ntk/v3NtkHandler.h	/^      inline void decInstRef() { assert (_instRef); --_instRef; }$/;"	f	class:V3NtkHandler
decOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::decOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
decRefCount	bdd/bddNodeV.h	/^   void decRefCount() { --_refCount; }$/;"	f	class:BddNodeVInt
decRefCount	ntk/v3NtkHandler.h	/^      inline void decRefCount() { assert (_refCount); --_refCount; }$/;"	f	class:V3NtkHandler
decisionLevel	pdr/SolverV.h	/^    int      decisionLevel() const { return trail_lim.size(); }$/;"	f	class:SolverV
decisions	pdr/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
decode64	pdr/FileV.h	/^static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }$/;"	f
decodeStateToNetId	stg/v3StgFSM.cpp	/^V3FSM::decodeStateToNetId(const V3FSMSDG* const sdg, const uint32_t& state, V3NetVec& netIdVec) const {$/;"	f	class:V3FSM
decodeStateToNetId	stg/v3StgFSM.cpp	/^V3FSM::decodeStateToNetId(const uint32_t& state, V3NetVec& netIdVec) const {$/;"	f	class:V3FSM
default_params	pdr/SolverV.h	/^    SearchParams    default_params;     \/\/ Restart frequency etc.$/;"	m	class:SolverV
deleteEdge	adt/v3Graph.h	/^V3Graph<T>::deleteEdge(const T& f, const T& t) {$/;"	f	class:V3Graph
deleted	pdr/ProofV.cpp	/^void Proof::deleted(ClauseId gone)$/;"	f	class:Proof
deleted	pdr/ProofV.h	/^    virtual void deleted(ClauseId c) {}$/;"	f	struct:ProofTraverser
depth	pdr/pdrMgr.h	/^    unsigned                  depth;$/;"	m	class:PDRMgr
dfs	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::dfs(V3NetVec& orderedNets) {$/;"	f	class:V3SvrPDRSat
dfs	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::dfs(V3NetVec& orderedNets, bool b, Cube* s) {$/;"	f	class:V3SvrPDRSat
dfsBuildNtkFromQuteRTL	io/v3NtkQuteRTL.cpp	/^const V3NetId dfsBuildNtkFromQuteRTL(V3NtkInput* const quteHandler, CktOutPin* const OutPin, const bool& a2s) {$/;"	f
dfsComputeFanout	ntk/v3NtkTraverse.cpp	/^void dfsComputeFanout(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetTable& outputTable) {$/;"	f
dfsComputeLevel	ntk/v3NtkTraverse.cpp	/^void dfsComputeLevel(V3Ntk* const ntk, V3NetVec& orderMap, V3UI32Vec& levelData) {$/;"	f
dfsConstructConstAssignments	stg/v3StgExtract.cpp	/^const bool dfsConstructConstAssignments(V3Ntk* const ntk, const V3NetId& ffId, const V3NetId& id, bool ok, V3NetVec& stateNets) {$/;"	f
dfsGeneralOrder	ntk/v3NtkTraverse.cpp	/^void dfsGeneralOrder(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetVec& orderMap) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetId& pId, const V3BoolVec& insensitiveList, V3BoolVec& m) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetTable& idGroup, V3BoolTable& v) {$/;"	f
dfsNtkForGeneralOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForGeneralOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& allNets) {$/;"	f
dfsNtkForReductionOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForReductionOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& reduceLatch) {$/;"	f
dfsNtkForSimulationOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForSimulationOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& allNets) {$/;"	f
dfsOrder	ntk/v3NtkBdd.cpp	/^void V3Ntk::dfsOrder(const V3NetId& id, V3NetVec& nets) {$/;"	f	class:V3Ntk
dfsSimulationOrder	ntk/v3NtkTraverse.cpp	/^void dfsSimulationOrder(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetVec& orderMap) {$/;"	f
done	pdr/ProofV.h	/^    virtual void done   () {}$/;"	f	struct:ProofTraverser
dotToPng	util/v3FileUtil.h	/^static inline void dotToPng(const string fileName) {$/;"	f
dotToPs	util/v3FileUtil.h	/^static inline void dotToPs(const string fileName) {$/;"	f
drand	pdr/GlobalV.h	/^static inline double drand(double& seed) {$/;"	f
drawBdd	bdd/bddMgrV.cpp	/^BddMgrV::drawBdd(const string& name, const string& fileName) const$/;"	f	class:BddMgrV
drawBdd	bdd/bddNodeV.cpp	/^BddNodeV::drawBdd(const string& name, ofstream& ofile) const$/;"	f	class:BddNodeV
drawBddRecur	bdd/bddNodeV.cpp	/^BddNodeV::drawBddRecur(ofstream& ofile) const$/;"	f	class:BddNodeV
duplicateGeneralInit	ntk/v3NtkDuplicate.cpp	/^void duplicateGeneralInit(V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& orderMap, const bool& reduceON) {$/;"	f
duplicateInputGates	ntk/v3NtkDuplicate.cpp	/^void duplicateInputGates(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateInputNets	ntk/v3NtkDuplicate.cpp	/^void duplicateInputNets(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap, V3NetVec& orderMap) {$/;"	f
duplicateNet	ntk/v3NtkDuplicate.cpp	/^const V3NetId duplicateNet(V3Ntk* const ntk, V3Ntk* const pNtk, const V3NetId& pId, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const duplicateNtk(V3NtkHandler* const handler, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateNtk	ntk/v3NtkDuplicate.cpp	/^void duplicateNtk(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap, V3NetVec& orderMap, V3PortableType& netHash, V3NtkHierInfo& hierInfo, const uint32_t& flattenLevel) {$/;"	f
duplicateReductionInit	ntk/v3NtkDuplicate.cpp	/^void duplicateReductionInit(V3Ntk* const ntk, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& orderMap) {$/;"	f
elaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborate(V3LTLFormula* const ltlFormula) {$/;"	f	class:V3NtkElaborate
elaborateAigAndOrAndGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateAigAndOrAndGate(V3AigNtk* const ntk, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateAigFormula	ext/v3ExtElaborate.cpp	/^const V3NetId elaborateAigFormula(V3Formula* const formula, const uint32_t& rootIndex, V3PortableType& netHash) {$/;"	f
elaborateAigGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateAigGate(V3AigNtk* const ntk, const V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateBvFormula	ext/v3ExtElaborate.cpp	/^const V3NetId elaborateBvFormula(V3Formula* const formula, const uint32_t& rootIndex, V3PortableType& netHash) {$/;"	f
elaborateBvGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateBvGate(V3BvNtk* const ntk, const V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateConstraints(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMConstraints(V3FSM* const fsm, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMInvariants	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMInvariants(V3FSM* const fsm, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMState	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMState(const V3NetVec& stateNets, const bool& nextState) {$/;"	f	class:V3NtkElaborate
elaborateFairness	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFairness(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFairnessL2S	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFairnessL2S(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateInvariants	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateInvariants(V3Constraint* const constr) {$/;"	f	class:V3NtkElaborate
elaborateL2S	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateL2S(const V3NetId& id) {$/;"	f	class:V3NtkElaborate
elaborateLTLFormula	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateLTLFormula(V3LTLFormula* const ltlFormula, const bool& l2s) {$/;"	f	class:V3NtkElaborate
elaborateLTLFormula	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateLTLFormula(V3LTLFormula* const ltlFormula, const uint32_t& rootIndex) {$/;"	f	class:V3NtkElaborate
elaborateLivenessNetwork	v3mc/v3MCElaborate.cpp	/^V3NtkHandler* const elaborateLivenessNetwork(V3NtkHandler* const handler, const V3UI32Vec& poList, V3NetTable& invConstr, V3NetTable& fairConstr) {$/;"	f
elaborateNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const elaborateNtk(V3NtkHandler* const handler, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& c2pMap, V3PortableType& netHash) {$/;"	f
elaboratePOConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaboratePOConstraints(const uint32_t& start, const uint32_t& end, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateProperties	v3mc/v3MCElaborate.cpp	/^V3NtkElaborate* const elaborateProperties(V3NtkHandler* const handler, V3StrVec& name, V3UI32Vec& prop, V3UI32Table& invc, V3UI32Table& fair, const bool& l2s, const bool& invc2Prop, const bool& safeOnly, const bool& liveOnly) {$/;"	f
elaborateProperty	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateProperty(V3Property* const p, V3NetVec& constrList, const bool& l2s) {$/;"	f	class:V3NtkElaborate
elaborateSafetyNetwork	v3mc/v3MCElaborate.cpp	/^V3NtkHandler* const elaborateSafetyNetwork(V3NtkHandler* const handler, const V3UI32Vec& poList, V3NetTable& invConstr) {$/;"	f
empty	bdd/myHash.h	/^   bool empty() const {$/;"	f	class:Hash
empty	pdr/HeapV.h	/^    bool empty     ()         { return heap.size() == 1; }$/;"	f	class:Heap
enableConstructStandardFSM	stg/v3StgExtract.h	/^      inline void enableConstructStandardFSM()  { assert (!(_configs & 256ul)); _configs |= 256ul; }$/;"	f	class:V3FSMExtract
enableOmitNodesAllCombVars	stg/v3StgExtract.h	/^      inline void enableOmitNodesAllCombVars()  { assert (!(_configs & 16ul )); _configs |= 16ul;  }$/;"	f	class:V3FSMExtract
enableOmitNodesIndepToVars	stg/v3StgExtract.h	/^      inline void enableOmitNodesIndepToVars()  { assert (!(_configs & 32ul )); _configs |= 32ul;  }$/;"	f	class:V3FSMExtract
enableRenderNonEmptyStates	stg/v3StgExtract.h	/^      inline void enableRenderNonEmptyStates()  { assert (!(_configs & 64ul )); _configs |= 64ul;  }$/;"	f	class:V3FSMExtract
enableStopOnAllInitOrTerms	stg/v3StgExtract.h	/^      inline void enableStopOnAllInitOrTerms()  { assert (!(_configs & 128ul)); _configs |= 128ul; }$/;"	f	class:V3FSMExtract
encode64	pdr/FileV.h	/^static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }$/;"	f
encodeAllStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeAllStateFromSimulator() const {$/;"	f	class:V3FSM
encodeAllStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeAllStateFromSimulator(V3FSMSDG* const sdg) const {$/;"	f	class:V3FSM
encodeStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeStateFromSimulator() const {$/;"	f	class:V3FSM
encodeStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeStateFromSimulator(V3FSMSDG* const sdg) const {$/;"	f	class:V3FSM
encode_aig	io/v3AigWriter.cpp	/^void encode_aig(ofstream& output, int x) {$/;"	f
end	bdd/myHash.h	/^   iterator end() const {$/;"	f	class:Hash
end	util/v3Usage.h	/^      inline void end() { assert (_isStarted); _timeAccum += (clock() - _startTime) \/ CLOCKS_PER_SEC; _isStarted = 0; }$/;"	f	class:V3Stat
endChain	pdr/ProofV.cpp	/^ClauseId Proof::endChain()$/;"	f	class:Proof
endLineON	vrf/v3VrfBase.h	/^      static inline const bool endLineON() { return intactON() &&  (4ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
enqueue	pdr/SolverV.cpp	/^bool SolverV::enqueue(Lit p, Clause* from)$/;"	f	class:SolverV
eof	itp/reader.cpp	/^bool Reader::eof() {$/;"	f	class:Reader
eof	pdr/FileV.h	/^    bool eof(void) {$/;"	f	class:File
eof	pdr/reader.cpp	/^bool Reader::eof() {$/;"	f	class:Reader
errorOption	cmd/v3CmdMgr.cpp	/^V3CmdExec::errorOption(V3CmdOptionError err, const string& opt) const {$/;"	f	class:V3CmdExec
evalCube	bdd/bddMgrV.cpp	/^BddMgrV::evalCube(const BddNodeV& node, const string& pattern) const$/;"	f	class:BddMgrV
exec	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::exec(const string& option) {$/;"	f	class:V3PlotTraceCmd
exec	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::exec(const string& option) {$/;"	f	class:V3SimNtkCmd
exec	bdd/bddCmd.cpp	/^BAndCmd::exec(const string& option)$/;"	f	class:BAndCmd
exec	bdd/bddCmd.cpp	/^BCofactorCmd::exec(const string& option)$/;"	f	class:BCofactorCmd
exec	bdd/bddCmd.cpp	/^BCompareCmd::exec(const string& option)$/;"	f	class:BCompareCmd
exec	bdd/bddCmd.cpp	/^BConstructCmd::exec(const string& option)$/;"	f	class:BConstructCmd
exec	bdd/bddCmd.cpp	/^BDrawCmd::exec(const string& option)$/;"	f	class:BDrawCmd
exec	bdd/bddCmd.cpp	/^BExistCmd::exec(const string& option)$/;"	f	class:BExistCmd
exec	bdd/bddCmd.cpp	/^BInvCmd::exec(const string& option)$/;"	f	class:BInvCmd
exec	bdd/bddCmd.cpp	/^BNandCmd::exec(const string& option)$/;"	f	class:BNandCmd
exec	bdd/bddCmd.cpp	/^BNorCmd::exec(const string& option)$/;"	f	class:BNorCmd
exec	bdd/bddCmd.cpp	/^BOrCmd::exec(const string& option)$/;"	f	class:BOrCmd
exec	bdd/bddCmd.cpp	/^BReportCmd::exec(const string& option)$/;"	f	class:BReportCmd
exec	bdd/bddCmd.cpp	/^BResetCmd::exec(const string& option)$/;"	f	class:BResetCmd
exec	bdd/bddCmd.cpp	/^BSetOrderCmd::exec(const string& option)$/;"	f	class:BSetOrderCmd
exec	bdd/bddCmd.cpp	/^BSetVarCmd::exec(const string& option)$/;"	f	class:BSetVarCmd
exec	bdd/bddCmd.cpp	/^BSimulateCmd::exec(const string& option)$/;"	f	class:BSimulateCmd
exec	bdd/bddCmd.cpp	/^BXnorCmd::exec(const string& option)$/;"	f	class:BXnorCmd
exec	bdd/bddCmd.cpp	/^BXorCmd::exec(const string& option)$/;"	f	class:BXorCmd
exec	cmd/v3CmdComm.cpp	/^V3DofileCmd::exec(const string& option) {     $/;"	f	class:V3DofileCmd
exec	cmd/v3CmdComm.cpp	/^V3HelpCmd::exec(const string& option) {$/;"	f	class:V3HelpCmd
exec	cmd/v3CmdComm.cpp	/^V3HistoryCmd::exec(const string& option) {$/;"	f	class:V3HistoryCmd
exec	cmd/v3CmdComm.cpp	/^V3LogFileCmd::exec(const string& option) {$/;"	f	class:V3LogFileCmd
exec	cmd/v3CmdComm.cpp	/^V3QuitCmd::exec(const string& option) {$/;"	f	class:V3QuitCmd
exec	cmd/v3CmdComm.cpp	/^V3UsageCmd::exec(const string& option) {     $/;"	f	class:V3UsageCmd
exec	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::exec(const string& option) {$/;"	f	class:V3OptTraceCmd
exec	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::exec(const string& option) {$/;"	f	class:V3TraceSimplifyCmd
exec	itp/satCmd.cpp	/^SATVerifyBmcCmd::exec(const string& option)$/;"	f	class:SATVerifyBmcCmd
exec	itp/satCmd.cpp	/^SATVerifyItpCmd::exec(const string& option)$/;"	f	class:SATVerifyItpCmd
exec	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::exec(const string& option) {$/;"	f	class:V3DuplicateNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::exec(const string& option) {$/;"	f	class:V3ListNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::exec(const string& option)$/;"	f	class:V3NetInfoCmd
exec	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::exec(const string& option) {$/;"	f	class:V3PlotNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::exec(const string& option) {$/;"	f	class:V3PrintNetCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::exec(const string& option) {$/;"	f	class:V3PrintNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::exec(const string& option) {$/;"	f	class:V3PrintVerbosityCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::exec(const string& option) {$/;"	f	class:V3ReadAIGCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::exec(const string& option) {$/;"	f	class:V3ReadBTORCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::exec(const string& option) {$/;"	f	class:V3ReadRTLCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::exec(const string& option) {$/;"	f	class:V3ReduceNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::exec(const string& option) {$/;"	f	class:V3RefNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::exec(const string& option) {$/;"	f	class:V3RewriteNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::exec(const string& option) {$/;"	f	class:V3SetNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::exec(const string& option) {$/;"	f	class:V3SetVerbosityCmd
exec	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::exec(const string& option) {$/;"	f	class:V3StrashNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::exec(const string& option) {$/;"	f	class:V3WorkNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::exec(const string& option) {$/;"	f	class:V3WriteAIGCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::exec(const string& option) {$/;"	f	class:V3WriteBTORCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::exec(const string& option) {$/;"	f	class:V3WriteRTLCmd
exec	pdr/pdrCmd.cpp	/^SATVerifyCmd::exec(const string& option)$/;"	f	class:SATVerifyCmd
exec	prove/proveCmd.cpp	/^PCheckPropertyCmd::exec(const string& option)$/;"	f	class:PCheckPropertyCmd
exec	prove/proveCmd.cpp	/^PImageCmd::exec(const string& option)$/;"	f	class:PImageCmd
exec	prove/proveCmd.cpp	/^PInitialStateCmd::exec(const string& option)$/;"	f	class:PInitialStateCmd
exec	prove/proveCmd.cpp	/^PTransRelationCmd::exec(const string& option)$/;"	f	class:PTransRelationCmd
exec	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::exec(const string& option) {$/;"	f	class:V3ElaborateFSMCmd
exec	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::exec(const string& option) {$/;"	f	class:V3ExtractFSMCmd
exec	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::exec(const string& option) {$/;"	f	class:V3PlotFSMCmd
exec	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::exec(const string& option) {$/;"	f	class:V3WriteFSMCmd
exec	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::exec(const string& option) {$/;"	f	class:V3BlastNtkCmd
exec	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::exec(const string& option) {$/;"	f	class:V3ExpandNtkCmd
exec	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::exec(const string& option) {$/;"	f	class:V3FlattenNtkCmd
exec	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::exec(const string& option) {$/;"	f	class:V3MiterNtkCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::exec(const string& option) {$/;"	f	class:V3MCReadPropertyCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::exec(const string& option) {$/;"	f	class:V3MCRunCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::exec(const string& option) {$/;"	f	class:V3MCWritePropertyCmd
exec	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::exec(const string& option) {$/;"	f	class:V3BMCVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::exec(const string& option) {$/;"	f	class:V3CheckResultCmd
exec	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::exec(const string& option) {$/;"	f	class:V3ElaboratePrptyCmd
exec	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::exec(const string& option) {$/;"	f	class:V3ITPVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::exec(const string& option) {$/;"	f	class:V3KLiveVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::exec(const string& option) {$/;"	f	class:V3PDRVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::exec(const string& option) {$/;"	f	class:V3PlotResultCmd
exec	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::exec(const string& option) {$/;"	f	class:V3PrintReportCmd
exec	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::exec(const string& option) {$/;"	f	class:V3PrintSolverCmd
exec	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::exec(const string& option) {$/;"	f	class:V3SECVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::exec(const string& option) {$/;"	f	class:V3SIMVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::exec(const string& option) {$/;"	f	class:V3SetLivenessCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::exec(const string& option) {$/;"	f	class:V3SetReportCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::exec(const string& option) {$/;"	f	class:V3SetSafetyCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::exec(const string& option) {$/;"	f	class:V3SetSolverCmd
exec	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::exec(const string& option) {$/;"	f	class:V3UMCVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::exec(const string& option) {$/;"	f	class:V3WriteResultCmd
execOneCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::execOneCmd() {$/;"	f	class:V3CmdMgr
exist	bdd/bddNodeV.cpp	/^BddNodeV::exist(unsigned l) const$/;"	f	class:BddNodeV
exist0	adt/v3BitVec.cpp	/^V3BitVecX::exist0 () const {$/;"	f	class:V3BitVecX
exist1	adt/v3BitVec.cpp	/^V3BitVecX::exist1 () const {$/;"	f	class:V3BitVecX
existFSM	ntk/v3NtkHandler.h	/^      inline const bool existFSM(const string& s) const { return _fsm.end() != _fsm.find(s); }$/;"	f	class:V3NtkHandler
existInitial	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::existInitial(const V3NetVec& state) {$/;"	f	class:V3VrfIPDR
existInitial	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::existInitial(const V3NetVec& state) {$/;"	f	class:V3VrfMPDR
existList	adt/v3Misc.h	/^      inline const bool existList(const uint32_t& i) const {$/;"	f	class:V3PortableType
existNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::existNetName(const string& s) const {$/;"	f	class:V3NtkHandler
existProperty	ntk/v3NtkHandler.h	/^      inline const bool existProperty(const string& s) const { return _property.end() != _property.find(s); }$/;"	f	class:V3NtkHandler
existRecur	bdd/bddNodeV.cpp	/^BddNodeV::existRecur(unsigned l, map<size_t, size_t>& existMap) const$/;"	f	class:BddNodeV
existState	stg/v3StgFSM.cpp	/^V3FSMSDGDB::existState(const V3NetVec& stateVars) {$/;"	f	class:V3FSMSDGDB
existVerifyData	itp/sat.cpp	/^const bool SatSolver::existVerifyData(const V3NetId& id, const uint32_t& depth)$/;"	f	class:SatSolver
existVerifyData	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
existVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
existVerifyData	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
existVerifyData	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
expandSimulateResult	vrf/v3VrfResult.cpp	/^const int expandSimulateResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler) {$/;"	f
expensive_ccmin	pdr/SolverV.h	/^    bool            expensive_ccmin;    \/\/ Controls conflict clause minimization. TRUE by default.$/;"	m	class:SolverV
extractModel	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::extractModel(const uint32_t& d, const V3IPDRCube* const nextCube) {$/;"	f	class:V3VrfIPDR
extractModel	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::extractModel(const V3MPDRCube* const nextCube, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
extractNewCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::extractNewCube(V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
extractNewCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::extractNewCube(V3FITPCube* const curCube) {$/;"	f	class:V3VrfFITP
fd	itp/reader.h	/^	int 			fd;$/;"	m	class:Reader
fd	pdr/FileV.h	/^    int         fd;         \/\/ Underlying file descriptor.$/;"	m	class:File
fd	pdr/reader.h	/^	int 			fd;$/;"	m	class:Reader
files	pdr/ProofV.cpp	/^    vec<cchar*> files;      \/\/ For clean-up purposed on abnormal exit.$/;"	m	class:TempFiles	file:
filterOutNoMuxVariable	stg/v3StgExtract.h	/^      inline void filterOutNoMuxVariable()      { assert (!(_configs & 4ul  )); _configs |= 4ul;   }$/;"	f	class:V3FSMExtract
filterOutNonSeqVariable	stg/v3StgExtract.h	/^      inline void filterOutNonSeqVariable()     { assert (!(_configs & 8ul  )); _configs |= 8ul;   }$/;"	f	class:V3FSMExtract
findCorresOperator	ext/v3Formula.cpp	/^V3Formula::findCorresOperator(const string& exp, const char& prefix, const char& suffix) {$/;"	f	class:V3Formula
findNextOperator	ext/v3Formula.cpp	/^V3Formula::findNextOperator(const string& exp, uint32_t& pos) {$/;"	f	class:V3Formula
findSliceOperand	ext/v3Formula.cpp	/^V3Formula::findSliceOperand(const string& exp, uint32_t& msb, uint32_t& lsb) {$/;"	f	class:V3Formula
first0	adt/v3BitVec.cpp	/^V3BitVecX::first0() const {$/;"	f	class:V3BitVecX
first1	adt/v3BitVec.cpp	/^V3BitVecX::first1() const {$/;"	f	class:V3BitVecX
firstX	adt/v3BitVec.cpp	/^V3BitVecX::firstX() const {$/;"	f	class:V3BitVecX
flattenNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const flattenNtk(V3NtkHandler* const handler, V3NetVec& c2pMap, V3NtkHierInfo& hierInfo, const uint32_t& flattenLevel) {$/;"	f
flush	pdr/FileV.h	/^    void flush(void) {$/;"	f	class:File
forceAddBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::forceAddBddNodeV(const string& str, size_t n)$/;"	f	class:BddMgrV
forceInsert	bdd/myHash.h	/^   void forceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
formalBlockCurrentState	stg/v3StgFSM.cpp	/^V3FSM::formalBlockCurrentState(const uint32_t& state, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalBlockNextState	stg/v3StgFSM.cpp	/^V3FSM::formalBlockNextState(const uint32_t& state, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalCheckFiredResult	vrf/v3VrfResult.cpp	/^const int formalCheckFiredResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
formalCheckProvenResult	vrf/v3VrfResult.cpp	/^const int formalCheckProvenResult(const V3Ntk* const inv, const V3NtkHandler* const handler) {$/;"	f
formalForBackwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::formalForBackwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
formalForForwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::formalForForwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
formalGetCurrentState	stg/v3StgFSM.cpp	/^V3FSM::formalGetCurrentState(const V3NetVec& stateData, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetInitialState	stg/v3StgFSM.cpp	/^V3FSM::formalGetInitialState(const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetNextState	stg/v3StgFSM.cpp	/^V3FSM::formalGetNextState(const V3NetVec& stateData, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetTerminalState	stg/v3StgFSM.cpp	/^V3FSM::formalGetTerminalState(const V3SvrData& svrData) {$/;"	f	class:V3FSM
forwardModel	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::forwardModel(const V3IPDRCube* const curCube) {$/;"	f	class:V3VrfIPDR
forwardModel	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::forwardModel(const V3MPDRCube* const curCube) {$/;"	f	class:V3VrfMPDR
forwardProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::forwardProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
forwardProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::forwardProof(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
fp	pdr/ProofV.h	/^    File            fp;$/;"	m	class:Proof
fp_name	pdr/ProofV.h	/^    cchar*          fp_name;$/;"	m	class:Proof
freeNetId	ntk/v3Ntk.h	/^inline void V3Ntk::freeNetId(const V3NetId& id) {$/;"	f	class:V3Ntk
generalization	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalization(V3IPDRTimedCube& generalizedCube) {$/;"	f	class:V3VrfIPDR
generalization	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalization(V3MPDRTimedCube& generalizedCube) {$/;"	f	class:V3VrfMPDR
generalizationValid	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::generalizationValid() {$/;"	f	class:V3AlgAigGeneralize
generalizationValid	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::generalizationValid() {$/;"	f	class:V3AlgBvGeneralize
generalize	pdr/pdrMgr.cpp	/^TCube PDRMgr::generalize(TCube s) {$/;"	f	class:PDRMgr
generalizeCex	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeCex(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
generalizeCex	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeCex(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
generalizeProof	vrf/v3VrfCITP.cpp	/^V3VrfCITP::generalizeProof(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
generalizeProof	vrf/v3VrfFITP.cpp	/^V3VrfFITP::generalizeProof(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
generalizeProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
generalizeProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeProof(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
generalizeSimulation	vrf/v3VrfCITP.cpp	/^V3VrfCITP::generalizeSimulation(V3CITPCube* const cube, const V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
generalizeSimulation	vrf/v3VrfFITP.cpp	/^V3VrfFITP::generalizeSimulation(const V3NetVec& nextCube) {$/;"	f	class:V3VrfFITP
generalizeSimulation	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeSimulation(const uint32_t& d, V3IPDRCube* const cube, const V3IPDRCube* const nextCube) {$/;"	f	class:V3VrfIPDR
generalizeSimulation	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeSimulation(V3MPDRCube* const cube, const V3MPDRCube* const nextCube, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
generalizeStateFromSimulation	stg/v3StgFSM.cpp	/^V3FSM::generalizeStateFromSimulation(const V3NetVec& targetNets, const uint32_t& depth) {$/;"	f	class:V3FSM
generateAndAddUniquenessBound	vrf/v3VrfUMC.cpp	/^V3VrfUMC::generateAndAddUniquenessBound(const uint32_t& depth) {$/;"	f	class:V3VrfUMC
geq	svr/v3SvrSatHelper.h	/^inline void geq(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
geqInt	svr/v3SvrSatHelper.h	/^inline void geqInt(Solver* SS, const Var& y, const Var& g, const Var& e, const uint32_t& Width)$/;"	f
geq_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId geq_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
get64	itp/reader.cpp	/^unsigned long long Reader::get64(){$/;"	f	class:Reader
get64	pdr/reader.cpp	/^unsigned long long Reader::get64(){$/;"	f	class:Reader
getAccumTime	util/v3Usage.h	/^      inline const double getAccumTime() const { assert (!_isStarted); return _timeAccum; }$/;"	f	class:V3Stat
getAccumToRef	util/v3Usage.h	/^      inline const double getAccumToRef() const { return _refStat ? getAccumTime() \/ _refStat->getAccumTime() : 0; }$/;"	f	class:V3Stat
getActivator	vrf/v3VrfMPDR.h	/^      inline const V3SvrData& getActivator() const { return _activator; }$/;"	f	class:V3MPDRFrame
getActiveMainSize	v3mc/v3MCMain.cpp	/^V3MCResource::getActiveMainSize() {$/;"	f	class:V3MCResource
getAllCubes	bdd/bddNodeV.cpp	/^BddNodeV::getAllCubes() const$/;"	f	class:BddNodeV
getAllCubesRecur	bdd/bddNodeV.cpp	/^BddNodeV::getAllCubesRecur$/;"	f	class:BddNodeV
getAuxFSMName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getAuxFSMName() const {$/;"	f	class:V3NtkHandler
getAuxPropertyName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getAuxPropertyName() const {$/;"	f	class:V3NtkHandler
getAvailableCores	v3mc/v3MCMain.cpp	/^V3MCResource::getAvailableCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
getAvgTime	util/v3Usage.h	/^      inline const double getAvgTime() const { return getAccumTime() \/ (double)(getNumCalled()); }$/;"	f	class:V3Stat
getBadCube	pdr/v3SvrPDRSat.cpp	/^Cube* V3SvrPDRSat::getBadCube(unsigned depth) {$/;"	f	class:V3SvrPDRSat
getBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getBase() const { return _base; }$/;"	f	class:V3SDGNode
getBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::getBddNodeV(const string& name) const$/;"	f	class:BddMgrV
getBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::getBddNodeV(unsigned id) const$/;"	f	class:BddMgrV
getBddNodeV	bdd/bddMgrV.cpp	/^BddNodeV getBddNodeV(const string& bddName)$/;"	f
getBddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt* getBddNodeVInt() const {$/;"	f	class:BddNodeV
getBitBlastedNet	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getBitBlastedNet(const V3NetId& id, const uint32_t& index) {$/;"	f	class:V3BvBlastBv
getBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::getBound(const uint32_t& p) {$/;"	f	class:V3VrfSharedBound
getBound	vrf/v3VrfShared.h	/^      inline void getBound(V3UI32Vec& bound) { lock(); bound = _bound; unlock(); }$/;"	f	class:V3VrfSharedBound
getBranchIndex	ext/v3Formula.h	/^      inline const uint32_t getBranchIndex(const uint32_t& i, const uint32_t& j) const {$/;"	f	class:V3Formula
getBranchIndex	ext/v3LTLFormula.h	/^      inline const uint32_t getBranchIndex(const uint32_t& i, const uint32_t& j) const {$/;"	f	class:V3LTLFormula
getBranchSize	ext/v3Formula.h	/^      inline const uint32_t getBranchSize(const uint32_t& i) const {$/;"	f	class:V3Formula
getBranchSize	ext/v3LTLFormula.h	/^      inline const uint32_t getBranchSize(const uint32_t& i) const {$/;"	f	class:V3LTLFormula
getBtorInput	io/v3BtorParser.cpp	/^inline const V3NetId getBtorInput(const V3HashMap<uint32_t, V3NetId>::Hash& id2IdHash, const int& id) {$/;"	f
getCOISize	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getCOISize() {$/;"	f	class:V3VrfSEC
getCexTrace	ext/v3Property.h	/^      inline V3CexTrace* const getCexTrace() const { assert (isCex()); return (V3CexTrace*)(_cexOrInv); }$/;"	f	class:V3VrfResult
getCexTrace	ext/v3Property.h	/^      inline const V3CexTrace* const getCexTrace() const { assert (isFired()); return _result.getCexTrace(); }$/;"	f	class:V3Property
getChar	itp/reader.cpp	/^unsigned int Reader::getChar(){$/;"	f	class:Reader
getChar	pdr/FileV.h	/^    int getChar(void) {$/;"	f	class:File
getChar	pdr/reader.cpp	/^unsigned int Reader::getChar(){$/;"	f	class:Reader
getCharQ	pdr/FileV.h	/^    int getCharQ(void) {            \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
getChecker	v3mc/v3MCEngine.cpp	/^V3VrfBase* getChecker(const V3MCEngineType& type, V3NtkHandler* const handler, const uint32_t& ntkSize) {$/;"	f
getClock	ntk/v3Ntk.h	/^      inline const V3NetId& getClock() const { return _globalClk; }$/;"	f	class:V3Ntk
getCluster	stg/v3StgExtract.h	/^      inline const V3UI32Set& getCluster(const uint32_t& i) const { assert (i < _clusters.size()); return _clusters[i]; }$/;"	f	class:V3FSMExtract
getClusterSize	stg/v3StgExtract.h	/^      inline const uint32_t getClusterSize() const { return _clusters.size(); }$/;"	f	class:V3FSMExtract
getCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::getCmd(const string& cmd) const {$/;"	f	class:V3CmdMgr
getCmdLen	cmd/v3CmdMgr.h	/^      inline unsigned getCmdLen() const { return _cmdLen; }$/;"	f	class:V3CmdExec
getCmdListFromPart	cmd/v3CmdMgr.cpp	/^V3CmdMgr::getCmdListFromPart(const string& cmd) const {$/;"	f	class:V3CmdMgr
getConst	ntk/v3Ntk.h	/^      inline const V3NetId& getConst(const uint32_t& i) const { assert (i < getConstSize()); return _ConstList[i]; }$/;"	f	class:V3Ntk
getConstSize	ntk/v3Ntk.h	/^      inline const uint32_t getConstSize() const { return _ConstList.size(); }$/;"	f	class:V3Ntk
getConstValue	ntk/v3Ntk.cpp	/^V3BvNtk::getConstValue(const V3BVXId& valueId) const {$/;"	f	class:V3BvNtk
getConstWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getConstWidth(const V3BVXId& valueId) const {$/;"	f	class:V3BvNtk
getCube	bdd/bddNodeV.cpp	/^BddNodeV::getCube(size_t ith) const$/;"	f	class:BddNodeV
getCubeList	vrf/v3VrfCITP.h	/^      inline V3CITPCubeList& getCubeList() { return _cubeList; }$/;"	f	class:V3CITPFrame
getCubeList	vrf/v3VrfFITP.h	/^      inline V3FITPCubeList& getCubeList() { return _cubeList; }$/;"	f	class:V3FITPFrame
getCubeList	vrf/v3VrfIPDR.h	/^      inline const V3IPDRCubeList& getCubeList() const { return _cubeList; }$/;"	f	class:V3IPDRFrame
getCubeList	vrf/v3VrfMPDR.h	/^      inline const V3MPDRCubeList& getCubeList() const { return _cubeList; }$/;"	f	class:V3MPDRFrame
getCubeRecur	bdd/bddNodeV.cpp	/^BddNodeV::getCubeRecur$/;"	f	class:BddNodeV
getCubeSize	alg/v3AlgGeneralize.h	/^      inline const uint32_t getCubeSize() const { return _cube2Var.size(); }$/;"	f	class:V3GenStruct
getCurHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getCurHandler() const { $/;"	f	class:V3Handler
getCurHandlerId	ntk/v3NtkHandler.h	/^      inline const uint32_t getCurHandlerId() const { return _curHandlerId; }$/;"	f	class:V3Handler
getCurrentNetId	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkElaborate
getCurrentNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getCurrentNetId	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkSimplify
getCurrentNetId	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getCurrentNetId	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getCurrentNetId	trans/v3NtkExpand.cpp	/^V3NtkExpand::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getCurrentNetId	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getCurrentNetId(const V3NetId& id, const uint32_t& handlerIndex) const {$/;"	f	class:V3NtkFlatten
getCutSignal	ntk/v3Ntk.h	/^      inline const V3NetId& getCutSignal(const uint32_t& i) const { return _cutSignals[i]; }$/;"	f	class:V3Ntk
getCutSize	ntk/v3Ntk.h	/^      inline const uint32_t getCutSize() const { return _cutSignals.size(); }$/;"	f	class:V3Ntk
getCycle	trans/v3NtkExpand.h	/^      inline const uint32_t& getCycle() const { return _cycle; }$/;"	f	class:V3NtkExpand
getCycleCount	alg/v3AlgSimulate.h	/^      inline const uint32_t getCycleCount() const { return _cycle; }$/;"	f	class:V3AlgSimulate
getData	ext/v3Property.h	/^      inline const V3BitVecX& getData(const uint32_t& i) const { assert (i < _data.size()); return _data[i]; }$/;"	f	class:V3CexTrace
getDataConflict	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getDataConflict(V3SvrDataVec& vars) const {$/;"	f	class:V3SvrPDRSat
getDataConflict	svr/v3SvrBase.cpp	/^V3SvrBase::getDataConflict(V3SvrDataVec& var_exp) const {$/;"	f	class:V3SvrBase
getDataConflict	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataConflict(V3SvrDataVec& Exps) const {$/;"	f	class:V3SvrBoolector
getDataConflict	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataConflict(V3SvrDataVec& vars) const {$/;"	f	class:V3SvrMiniSat
getDataValue	itp/sat.cpp	/^const V3BitVecX SatSolver::getDataValue(const V3NetId& id, const uint32_t& depth) const $/;"	f	class:SatSolver
getDataValue	itp/sat.cpp	/^const bool SatSolver::getDataValue(const size_t& var) const $/;"	f	class:SatSolver
getDataValue	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrPDRSat
getDataValue	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getDataValue(const size_t& var) const {$/;"	f	class:V3SvrPDRSat
getDataValue	svr/v3SvrBase.cpp	/^V3SvrBase::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBase
getDataValue	svr/v3SvrBase.cpp	/^V3SvrBase::getDataValue(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
getDataValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBoolector
getDataValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataValue(const size_t& exp) const {$/;"	f	class:V3SvrBoolector
getDataValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrMiniSat
getDataValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataValue(const size_t& var) const {$/;"	f	class:V3SvrMiniSat
getDefaultCheckerList	v3mc/v3MCEngine.cpp	/^void getDefaultCheckerList(const V3MCMainType& type, const uint32_t& pSize, V3MCEngineList& checkers) {$/;"	f
getDefaultSolver	vrf/v3VrfBase.h	/^      static inline const V3SolverType getDefaultSolver() { return _extSolverType; }$/;"	f	class:V3VrfBase
getDepFFCone	stg/v3StgSDG.h	/^      inline V3SDGBase* const getDepFFCone() { return _depFFCone; }$/;"	f	class:V3SDGBase
getDepFFSet	stg/v3StgSDG.h	/^      inline const V3UI32Set& getDepFFSet() const { return _depFFSet; }$/;"	f	class:V3SDGBase
getDepMuxCone	stg/v3StgSDG.h	/^      inline V3SDGBase* const getDepMuxCone() { return _depMuxCone; }$/;"	f	class:V3SDGBase
getDepMuxSet	stg/v3StgSDG.h	/^      inline const V3UI32Set& getDepMuxSet() const { return _depMuxSet; }$/;"	f	class:V3SDGBase
getDepVars	stg/v3StgFSM.h	/^      inline const V3UI32Set& getDepVars() const { return _depVars; }$/;"	f	class:V3FSMSDGDB
getEnd	ext/v3Property.h	/^      inline const uint32_t getEnd()   const { assert (isPOConstr()); return V3PairType(_constrInfo).bus[1]; }$/;"	f	class:V3Constraint
getFBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getFBase() const { return _fBase; }$/;"	f	class:V3SDGMUX
getFSM	ext/v3Property.h	/^      inline V3FSM* const getFSM() const { assert (isFSMConstr()); return (V3FSM* const)(_constrInfo); }$/;"	f	class:V3Constraint
getFSM	ntk/v3NtkHandler.h	/^      inline V3FSMExtract* const getFSM(const string& s) const { assert (existFSM(s)); return _fsm.find(s)->second; }$/;"	f	class:V3NtkHandler
getFSM	stg/v3StgExtract.h	/^      inline V3FSM* const getFSM(const uint32_t& i) const { assert (i < _fsmList.size()); return _fsmList[i]; }$/;"	f	class:V3FSMExtract
getFSMListSize	stg/v3StgExtract.h	/^      inline const uint32_t getFSMListSize() const { return _fsmList.size(); }$/;"	f	class:V3FSMExtract
getFSMSDGDBSize	stg/v3StgExtract.h	/^      inline const uint32_t getFSMSDGDBSize() const { return _sdgDBList.size(); }$/;"	f	class:V3FSMExtract
getFSMSDGList	stg/v3StgFSM.h	/^      inline const V3FSMSDGList& getFSMSDGList() const { return _sdgDB->getFSMSDGList(); }$/;"	f	class:V3FSM
getFSMSDGList	stg/v3StgFSM.h	/^      inline const V3FSMSDGList& getFSMSDGList() const { return _sdgList; }$/;"	f	class:V3FSMSDGDB
getFairConstr	ext/v3Property.cpp	/^V3Property::getFairConstr(const uint32_t& i) const {$/;"	f	class:V3Property
getFairConstrSize	ext/v3Property.h	/^      inline const uint32_t getFairConstrSize() const { return _fairConstrs.size(); }$/;"	f	class:V3Property
getFalseSDG	stg/v3StgFSM.h	/^      inline const V3FSMSDGSet& getFalseSDG() const { return _falseSDG; }$/;"	f	class:V3FSMSDG
getFalseStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getFalseStateSize() const { return _falseSize; }$/;"	f	class:V3FSMSDG
getFormula	ext/v3LTLFormula.h	/^      inline V3Formula* const getFormula(const uint32_t& i) const {$/;"	f	class:V3LTLFormula
getFormula	itp/sat.cpp	/^const size_t SatSolver::getFormula(const V3NetId& id, const uint32_t& depth)$/;"	f	class:SatSolver
getFormula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
getFormula	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrPDRSat
getFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrBase
getFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
getFormula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
getFormula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
getFormula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
getFormula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
getFrameId	dfx/v3DfxTrace.h	/^      inline const uint32_t getFrameId() const { return _frameId; }$/;"	f	class:V3DfxCube
getFromSize	adt/v3Graph.h	/^V3Graph<T>::getFromSize(const uint32_t& t) const {$/;"	f	class:V3Graph
getGateType	ext/v3Formula.h	/^      inline const V3GateType& getGateType(const uint32_t& i) const { assert (!isLeaf(i)); return _formula[i].first; }$/;"	f	class:V3Formula
getGateType	ntk/v3Ntk.h	/^inline const V3GateType V3Ntk::getGateType(const V3NetId& id) const {$/;"	f	class:V3Ntk
getGeneralizationResult	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::getGeneralizationResult() const {$/;"	f	class:V3AlgGeneralize
getHandler	ext/v3Formula.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3Formula
getHandler	ext/v3LTLFormula.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3LTLFormula
getHandler	ext/v3Property.h	/^      inline V3NtkHandler* const getHandler() const { return (V3NtkHandler*)(~3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
getHandler	ntk/v3NtkHandler.cpp	/^V3Handler::getHandler(const uint32_t& ntkId) const {$/;"	f	class:V3Handler
getHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3NtkHandler
getHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getHandler(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getHandlerCount	ntk/v3NtkHandler.h	/^      inline const uint32_t getHandlerCount() const { return _ntkHandlerList.size(); }$/;"	f	class:V3Handler
getInNode	adt/v3Graph.h	/^V3Graph<T>::getInNode(const uint32_t& i, const uint32_t& s) const {$/;"	f	class:V3Graph
getInNodeSize	adt/v3Graph.h	/^V3Graph<T>::getInNodeSize(const uint32_t& i) const {$/;"	f	class:V3Graph
getIncLastDepthToKeepGoing	vrf/v3VrfBase.h	/^      inline const uint32_t getIncLastDepthToKeepGoing() const { return _incLastDepthToKeepGoing; }$/;"	f	class:V3VrfBase
getIndInv	ext/v3Property.h	/^      inline V3Ntk* const getIndInv() const { assert (isInv()); return (V3Ntk*)(_cexOrInv & ~1ul); }$/;"	f	class:V3VrfResult
getIndInv	ext/v3Property.h	/^      inline const V3Ntk* const getIndInv() const { assert (isProven()); return _result.getIndInv(); }$/;"	f	class:V3Property
getInit	ext/v3Property.h	/^      inline V3BitVecX* const getInit() const { return _init; }$/;"	f	class:V3CexTrace
getInitFwdReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getInitFwdReachableSize() {$/;"	f	class:V3FSM
getInitStateSize	stg/v3StgFSM.cpp	/^V3FSM::getInitStateSize() const {$/;"	f	class:V3FSM
getInitStates	stg/v3StgFSM.cpp	/^V3FSM::getInitStates(V3UI32Vec& states, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getInitialObligation	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::getInitialObligation() {  \/\/ If SAT(R ^ T ^ !p)$/;"	f	class:V3VrfIPDR
getInitialObligation	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::getInitialObligation() {  \/\/ If SAT(R ^ T ^ !p)$/;"	f	class:V3VrfMPDR
getInout	ntk/v3Ntk.h	/^      inline const V3NetId& getInout(const uint32_t& i) const { assert (i < getInoutSize()); return _IOList[2][i]; }$/;"	f	class:V3Ntk
getInoutName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getInoutName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getInoutName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getInoutName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getInoutName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getInoutName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getInoutName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getInoutName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getInoutSize	ntk/v3Ntk.h	/^      inline const uint32_t getInoutSize() const { return _IOList[2].size(); }$/;"	f	class:V3Ntk
getInput	ntk/v3Ntk.h	/^      inline const V3NetId& getInput(const uint32_t& i) const { assert (i < getInputSize()); return _IOList[0][i]; }$/;"	f	class:V3Ntk
getInputConstValue	ntk/v3Ntk.cpp	/^V3BvNtk::getInputConstValue(const V3NetId& id) const {$/;"	f	class:V3BvNtk
getInputData	vrf/v3VrfIPDR.h	/^      inline const V3BitVecX& getInputData() const { return _inputData; }$/;"	f	class:V3IPDRCube
getInputData	vrf/v3VrfMPDR.h	/^      inline const V3BitVecX& getInputData() const { return _inputData; }$/;"	f	class:V3MPDRCube
getInputList	ntk/v3Ntk.h	/^      inline const V3NetVec& getInputList() const { return _inputs; }$/;"	f	class:V3NtkModule
getInputName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getInputName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getInputName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getInputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getInputName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getInputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getInputName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getInputName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getInputNetId	ntk/v3Ntk.h	/^inline const V3NetId& V3Ntk::getInputNetId(const V3NetId& id, const uint32_t& i) const {$/;"	f	class:V3Ntk
getInputNetSize	ntk/v3Ntk.h	/^inline const uint32_t V3Ntk::getInputNetSize(const V3NetId& id) const {$/;"	f	class:V3Ntk
getInputSize	ntk/v3Ntk.h	/^      inline const uint32_t getInputSize() const { return _IOList[0].size(); }$/;"	f	class:V3Ntk
getInputSliceBit	ntk/v3Ntk.cpp	/^V3BvNtk::getInputSliceBit(const V3NetId& id, const bool& msb) const {$/;"	f	class:V3BvNtk
getInt	pdr/FileV.h	/^static inline uint64 getInt  (File& in)             { return decode64(getUInt(in)); }$/;"	f
getInv	vrf/v3VrfShared.h	/^      inline void getInv(V3NetTable& inv) { lock(); inv = _inv; unlock(); }$/;"	f	class:V3VrfSharedInv
getInvConstr	ext/v3Property.cpp	/^V3Property::getInvConstr(const uint32_t& i) const {$/;"	f	class:V3Property
getInvConstrSize	ext/v3Property.h	/^      inline const uint32_t getInvConstrSize() const { return _invConstrs.size(); }$/;"	f	class:V3Property
getInvariant	ext/v3Property.cpp	/^V3Property::getInvariant(const uint32_t& i) const {$/;"	f	class:V3Property
getInvariantSize	ext/v3Property.h	/^      inline const uint32_t getInvariantSize() const { return _invariants.size(); }$/;"	f	class:V3Property
getItp	itp/satMgr.cpp	/^V3NetId SATMgr::getItp() const {$/;"	f	class:SATMgr
getKLHandler	vrf/v3VrfKLive.h	/^      inline V3NtkHandler* const getKLHandler() const { return _klHandler; }$/;"	f	class:V3VrfKLive
getLTLFormulSize	ext/v3NtkElaborate.h	/^      inline const uint32_t getLTLFormulSize() const { return _pOutput.size(); }$/;"	f	class:V3NtkElaborate
getLTLFormula	ext/v3Property.h	/^      inline V3LTLFormula* const getLTLFormula() const { return _formula; }$/;"	f	class:V3Property
getLabel	bdd/bddNodeV.cpp	/^BddNodeV::getLabel() const$/;"	f	class:BddNodeV
getLatch	ntk/v3Ntk.h	/^      inline const V3NetId& getLatch(const uint32_t& i) const { assert (i < getLatchSize()); return _FFList[i]; }$/;"	f	class:V3Ntk
getLatchSize	ntk/v3Ntk.h	/^      inline const uint32_t getLatchSize() const { return _FFList.size(); }$/;"	f	class:V3Ntk
getLeaves	adt/v3Graph.h	/^V3Graph<T>::getLeaves(V3NodeLayer& leafList) const {$/;"	f	class:V3Graph
getLeft	bdd/bddNodeV.cpp	/^BddNodeV::getLeft() const$/;"	f	class:BddNodeV
getLeft	bdd/bddNodeV.h	/^   const BddNodeV& getLeft() const { return _left; }$/;"	f	class:BddNodeVInt
getLeftCofactor	bdd/bddNodeV.cpp	/^BddNodeV::getLeftCofactor(unsigned i) const$/;"	f	class:BddNodeV
getLevel	bdd/bddNodeV.cpp	/^BddNodeV::getLevel() const$/;"	f	class:BddNodeV
getLevel	bdd/bddNodeV.h	/^   unsigned getLevel() const { return _level; }$/;"	f	class:BddNodeVInt
getList	adt/v3Misc.h	/^      inline const size_t& getList(const uint32_t& i) const {$/;"	f	class:V3PortableType
getMandCmd	cmd/v3CmdMgr.h	/^      inline const string& getMandCmd(size_t idx) const { return _mandCmd[idx]; }$/;"	f	class:V3CmdExec
getMap	ntk/v3NtkHandler.h	/^      inline V3NetVec& getMap(const uint32_t& i) {$/;"	f	class:V3NtkHierInfo
getMap	ntk/v3NtkHandler.h	/^      inline const V3NetVec& getMap(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getMaxAllowedStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getMaxAllowedStateSize() const { return _maxSize; }$/;"	f	class:V3FSMSDGDB
getMaxDepth	itp/satMgr.h	/^    uint32_t getMaxDepth() const { return _maxDepth; }$/;"	f	class:SatProofRes
getMaxDepth	pdr/pdrMgr.h	/^    uint32_t getMaxDepth() const { return _maxDepth; }$/;"	f	class:SatProofRes
getMaxMemory	vrf/v3VrfShared.h	/^      inline const double getMaxMemory() { lock(); const double m = _maxMemory; unlock(); return m; }$/;"	f	class:V3VrfSharedMem
getMemUsage	util/v3Usage.h	/^      const double getMemUsage() { setMemUsage(); return _currentMem; }$/;"	f	class:V3Usage
getMemory	svr/v3SvrBase.cpp	/^V3SvrBase::getMemory() const {$/;"	f	class:V3SvrBase
getMemory	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getMemory() const {$/;"	f	class:V3SvrMiniSat
getMemory	vrf/v3VrfShared.h	/^      inline const double getMemory() { lock(); const double m = v3Usage.getMemUsage(); unlock(); return m; }$/;"	f	class:V3VrfSharedMem
getMileStoneSize	stg/v3StgFSM.cpp	/^V3FSM::getMileStoneSize() const {$/;"	f	class:V3FSM
getMode	pdr/FileV.h	/^    FileMode getMode(void) {$/;"	f	class:File
getModule	ntk/v3Ntk.h	/^inline V3NtkModule* const V3Ntk::getModule(const V3NetId& id) const {$/;"	f	class:V3Ntk
getModule	ntk/v3Ntk.h	/^inline V3NtkModule* const V3Ntk::getModule(const uint32_t& i) const {$/;"	f	class:V3Ntk
getModuleSize	ntk/v3Ntk.h	/^      inline const uint32_t getModuleSize() const { return _ntkModule.size(); }$/;"	f	class:V3Ntk
getName	ext/v3LTLFormula.h	/^      inline const string& getName() const { return _name; }$/;"	f	class:V3LTLFormula
getNegExp	svr/v3SvrBoolector.h	/^      inline const size_t getNegExp(const BtorExp* const e) const { return ((getPosExp(e)) | 2ul); }$/;"	f	class:V3SvrBoolector
getNegFormula	itp/sat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:SatSolver
getNegFormula	pdr/v3SvrPDRSat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:V3SvrPDRSat
getNegFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getNegFormula(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
getNegFormula	svr/v3SvrBoolector.h	/^      inline const size_t getNegFormula(const size_t& e) const { return (e ^ 2ul); }$/;"	f	class:V3SvrBoolector
getNegFormula	svr/v3SvrMiniSat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:V3SvrMiniSat
getNegVar	itp/sat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:SatSolver
getNegVar	pdr/v3SvrPDRSat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:V3SvrPDRSat
getNegVar	svr/v3SvrMiniSat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:V3SvrMiniSat
getNetExpression	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetExpression(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetFromName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetFromName(const string& s) const {$/;"	f	class:V3NtkHandler
getNetFromName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getNetFromName(const string& s) const {$/;"	f	class:V3BvBlastAig
getNetFromName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getNetFromName(const string& s) const {$/;"	f	class:V3BvBlastBv
getNetFromName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getNetFromName(const string& s) const {$/;"	f	class:V3NtkExpand
getNetFromName	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getNetFromName(const string& s) const {$/;"	f	class:V3NtkFlatten
getNetId	ext/v3Formula.h	/^      inline const V3NetId& getNetId(const uint32_t& i) const {$/;"	f	class:V3Formula
getNetId	ntk/v3NtkInput.cpp	/^V3NtkInput::getNetId(const string& netName) const {$/;"	f	class:V3NtkInput
getNetId	stg/v3StgSDG.h	/^      inline const V3NetId& getNetId() const { return _netId; }$/;"	f	class:V3SDGNode
getNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkHandler
getNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetName(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3BvBlastAig
getNetName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3BvBlastBv
getNetName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkExpand
getNetName	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkFlatten
getNetName	trans/v3NtkMiter.cpp	/^V3NtkMiter::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkMiter
getNetNameOrFormedWithId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetNameOrFormedWithId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetRecurExpression	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetRecurExpression(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetSize	ntk/v3Ntk.h	/^      inline const uint32_t getNetSize() const { return _inputData.size(); }$/;"	f	class:V3Ntk
getNetSize	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNetSize() {$/;"	f	class:V3VrfSharedNtk
getNetWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getNetWidth(const V3NetId& id) const {$/;"	f	class:V3BvNtk
getNetWidth	ntk/v3Ntk.cpp	/^V3Ntk::getNetWidth(const V3NetId& id) const {$/;"	f	class:V3Ntk
getNextCube	vrf/v3VrfCITP.h	/^      inline const V3CITPCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3CITPCube
getNextCube	vrf/v3VrfFITP.h	/^      inline const V3FITPCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3FITPCube
getNextCube	vrf/v3VrfIPDR.h	/^      inline const V3IPDRCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3IPDRCube
getNextCube	vrf/v3VrfMPDR.h	/^      inline const V3MPDRCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3MPDRCube
getNextLineInCexTrace	ext/v3ExtIO.cpp	/^inline const bool getNextLineInCexTrace(ifstream& input, string& inputStr) {$/;"	f
getNextVar	alg/v3AlgGeneralize.cpp	/^V3GenStruct::getNextVar() {$/;"	f	class:V3GenStruct
getNextVar	alg/v3AlgGeneralize.cpp	/^V3GenStruct::getNextVar(uint32_t& cost) {$/;"	f	class:V3GenStruct
getNode	adt/v3Graph.h	/^V3Graph<T>::getNode(const uint32_t& i) const {$/;"	f	class:V3Graph
getNodeIndex	adt/v3Graph.h	/^V3Graph<T>::getNodeIndex(const T& t) const {$/;"	f	class:V3Graph
getNodeSize	adt/v3Graph.h	/^V3Graph<T>::getNodeSize() const { return _nodeList.size(); }$/;"	f	class:V3Graph
getNtk	ntk/v3NtkHandler.h	/^      inline V3Ntk* const getNtk() const { return _ntk; }$/;"	f	class:V3NtkHandler
getNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNtk(V3NtkHandler* const handler) {$/;"	f	class:V3VrfSharedNtk
getNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNtk(V3NtkHandler* const handler, V3NetTable& constr) {$/;"	f	class:V3VrfSharedNtk
getNtkHandler	stg/v3StgExtract.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3FSMExtract
getNtkHandler	stg/v3StgFSM.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3FSMSDGDB
getNtkHandler	stg/v3StgFSM.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _sdgDB->getNtkHandler(); }$/;"	f	class:V3FSM
getNtkHandler	stg/v3StgSDG.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3SDG
getNtkHandler	vrf/v3VrfBase.h	/^      inline const V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3VrfBase
getNtkName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNtkName() const {$/;"	f	class:V3NtkHandler
getNtkName	ntk/v3NtkInput.h	/^      inline const string getNtkName() const { return _ntkName; }$/;"	f	class:V3NtkInput
getNtkRef	ntk/v3Ntk.h	/^      inline V3NtkHandler* const getNtkRef() const { return (V3NtkHandler*)(_ref & ~1ul); }$/;"	f	class:V3NtkModule
getNtkSize	ntk/v3NtkHandler.h	/^      inline const uint32_t getNtkSize() const { return _hierInfo.size(); }$/;"	f	class:V3NtkHierInfo
getNumCalled	util/v3Usage.h	/^      inline const uint32_t getNumCalled() const { assert (!_isStarted); return _numCalled; }$/;"	f	class:V3Stat
getNumClauses	itp/sat.h	/^      int getNumClauses() const { return _solver->nRootCla(); }$/;"	f	class:SatSolver
getNumClauses	itp/satMgr.h	/^    int getNumClauses() const{ return _ptrMinisat->getNumClauses(); }$/;"	f	class:SATMgr
getNumSupports	bdd/bddMgrV.h	/^   size_t getNumSupports() const { return _supports.size(); }$/;"	f	class:BddMgrV
getOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::getOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
getOpType	ext/v3LTLFormula.h	/^      inline const V3LTLOpType& getOpType(const uint32_t& i) const { assert (!isLeaf(i)); return _formula[i].first; }$/;"	f	class:V3LTLFormula
getOptCmd	cmd/v3CmdMgr.h	/^      inline const string& getOptCmd(size_t idx) const { return _optCmd[idx]; }$/;"	f	class:V3CmdExec
getOriExp	svr/v3SvrBoolector.h	/^      inline BtorExp* const getOriExp(const size_t& e) const { return (BtorExp*)(e & ~2ul); }$/;"	f	class:V3SvrBoolector
getOriVar	itp/sat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:SatSolver
getOriVar	pdr/v3SvrPDRSat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:V3SvrPDRSat
getOriVar	svr/v3SvrMiniSat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:V3SvrMiniSat
getOutNode	adt/v3Graph.h	/^V3Graph<T>::getOutNode(const uint32_t& i, const uint32_t& s) const {$/;"	f	class:V3Graph
getOutNodeSize	adt/v3Graph.h	/^V3Graph<T>::getOutNodeSize(const uint32_t& i) const {$/;"	f	class:V3Graph
getOutPinWidthFromQuteRTL	io/v3NtkQuteRTL.cpp	/^const uint32_t getOutPinWidthFromQuteRTL(const string& name, CktOutPin* const OutPin) {$/;"	f
getOutput	ntk/v3Ntk.h	/^      inline const V3NetId& getOutput(const uint32_t& i) const { assert (i < getOutputSize()); return _IOList[1][i]; }$/;"	f	class:V3Ntk
getOutputList	ntk/v3Ntk.h	/^      inline const V3NetVec& getOutputList() const { return _outputs; }$/;"	f	class:V3NtkModule
getOutputName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getOutputName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getOutputName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getOutputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getOutputName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getOutputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getOutputName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getOutputName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getOutputSize	ntk/v3Ntk.h	/^      inline const uint32_t getOutputSize() const { return _IOList[1].size(); }$/;"	f	class:V3Ntk
getPDRDepth	vrf/v3VrfIPDR.h	/^      inline const uint32_t getPDRDepth() const { return _pdrFrame.size() - 1; }$/;"	f	class:V3VrfIPDR
getPDRDepth	vrf/v3VrfMPDR.h	/^      inline const uint32_t getPDRDepth() const { return _pdrFrame.size() - 2; }$/;"	f	class:V3VrfMPDR
getPDRFrame	vrf/v3VrfIPDR.h	/^      inline const uint32_t getPDRFrame() const { return _pdrFrame.size(); }$/;"	f	class:V3VrfIPDR
getPDRFrame	vrf/v3VrfMPDR.h	/^      inline const uint32_t getPDRFrame() const { return _pdrFrame.size() - 1; }$/;"	f	class:V3VrfMPDR
getPInitState	bdd/bddMgrV.h	/^   BddNodeV getPInitState() const { return _initState; }$/;"	f	class:BddMgrV
getPReachState	bdd/bddMgrV.h	/^   BddNodeV getPReachState() const { $/;"	f	class:BddMgrV
getPTr	bdd/bddMgrV.h	/^   BddNodeV getPTr() const { return _tr; }$/;"	f	class:BddMgrV
getPTri	bdd/bddMgrV.h	/^   BddNodeV getPTri() const { return _tri; }$/;"	f	class:BddMgrV
getParentId	ntk/v3NtkHandler.h	/^      inline const uint32_t getParentId(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getParentIndex	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3BvBlastAig
getParentIndex	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3BvBlastBv
getParentIndex	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3NtkFlatten
getParentNetId	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkElaborate
getParentNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getParentNetId	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkSimplify
getParentNetId	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3BvBlastAig
getParentNetId	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3BvBlastBv
getParentNetId	trans/v3NtkExpand.cpp	/^V3NtkExpand::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkExpand
getParentNetId	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkFlatten
getPosExp	svr/v3SvrBoolector.h	/^      inline const size_t getPosExp(const BtorExp* const e) const { return ((size_t)e); }$/;"	f	class:V3SvrBoolector
getPosVar	itp/sat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:SatSolver
getPosVar	pdr/v3SvrPDRSat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:V3SvrPDRSat
getPosVar	svr/v3SvrMiniSat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:V3SvrMiniSat
getPrimitive	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getPrimitive() const {$/;"	f	class:V3NtkHandler
getPrimitiveNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getPrimitiveNetId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getPrompt	cmd/v3CmdMgr.h	/^      inline const string& getPrompt() const { return _prompt; }$/;"	f	class:V3CmdMgr
getProperty	ntk/v3NtkHandler.h	/^      V3Property* const getProperty(const string& s) const {$/;"	f	class:V3NtkHandler
getPropertyList	ntk/v3NtkHandler.h	/^      inline const V3PropertyMap& getPropertyList() const { return _property; }$/;"	f	class:V3NtkHandler
getReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getReachableSize() const {$/;"	f	class:V3FSM
getRefCount	bdd/bddNodeV.cpp	/^BddNodeV::getRefCount() const$/;"	f	class:BddNodeV
getRefCount	bdd/bddNodeV.h	/^   unsigned getRefCount() const { return _refCount; }$/;"	f	class:BddNodeVInt
getRefId	ntk/v3NtkHandler.h	/^      inline const V3PairType& getRefId(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getRefSize	ntk/v3NtkHandler.h	/^      inline const uint32_t getRefSize() const { return _refIdMap.size(); }$/;"	f	class:V3NtkHierInfo
getResult	v3mc/v3MCMain.h	/^      inline void getResult(V3VrfResultVec& result) { lock(); result = _result; unlock(); }$/;"	f	class:V3MCResult
getResult	vrf/v3VrfBase.h	/^      inline const V3VrfResult& getResult(const uint32_t& i) const { assert (i < _result.size()); return _result[i]; }$/;"	f	class:V3VrfBase
getRight	bdd/bddNodeV.cpp	/^BddNodeV::getRight() const$/;"	f	class:BddNodeV
getRight	bdd/bddNodeV.h	/^   const BddNodeV& getRight() const { return _right; }$/;"	f	class:BddNodeVInt
getRightCofactor	bdd/bddNodeV.cpp	/^BddNodeV::getRightCofactor(unsigned i) const$/;"	f	class:BddNodeV
getRoot	ext/v3Formula.h	/^      inline const uint32_t getRoot() const { assert (isValid()); return _rootId; }$/;"	f	class:V3Formula
getRoot	ext/v3LTLFormula.h	/^      inline const uint32_t getRoot() const { assert (isValid()); return _rootId; }$/;"	f	class:V3LTLFormula
getSATAssignmentToCube	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::getSATAssignmentToCube(Cube* cube) {$/;"	f	class:V3SvrPDRSat
getSDGExpr	stg/v3StgFSM.cpp	/^V3FSMSDG::getSDGExpr(const V3UI32Vec& stateMap, string& exp) const {$/;"	f	class:V3FSMSDG
getSDGNode	stg/v3StgSDG.h	/^      inline V3SDGNode* const getSDGNode(const uint32_t& i) const { $/;"	f	class:V3SDG
getSECHandler	vrf/v3VrfSEC.h	/^      inline V3NtkHandler* const getSECHandler() const { return _secHandler; }$/;"	f	class:V3VrfSEC
getSatSolver	itp/satMgr.h	/^    SatSolver* getSatSolver() const { return _satSolver; }$/;"	f	class:SatProofRes
getSatSolver	pdr/pdrMgr.h	/^    V3SvrPDRSat* getSatSolver() const { return _satSolver; }$/;"	f	class:SatProofRes
getSignature	dfx/v3DfxTrace.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3DfxCube
getSignature	vrf/v3VrfCITP.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3CITPCube
getSignature	vrf/v3VrfFITP.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3FITPCube
getSignature	vrf/v3VrfIPDR.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3IPDRCube
getSignature	vrf/v3VrfMPDR.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3MPDRCube
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const {$/;"	f	class:V3AlgAigSimulate
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const {$/;"	f	class:V3AlgBvSimulate
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const { traceData.clear(); }$/;"	f	class:V3AlgSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::getSimValue(const V3NetId& id) const {$/;"	f	class:V3AlgAigSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::getSimValue(const V3NetId& id) const {$/;"	f	class:V3AlgBvSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::getSimValue(const V3NetId& id) const { return V3BitVecX(); }$/;"	f	class:V3AlgSimulate
getSliceBit	ntk/v3Ntk.cpp	/^V3BvNtk::getSliceBit(const V3BusId& busId, const bool& msb) const {$/;"	f	class:V3BvNtk
getSliceWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getSliceWidth(const V3BusId& busId) const {$/;"	f	class:V3BvNtk
getSolver	stg/v3StgFSM.h	/^      inline V3SvrBase* const getSolver() const { return _solver; }$/;"	f	class:V3FSMSDGDB
getSolver	vrf/v3VrfBase.h	/^      inline const V3SolverType getSolver() const { return (V3_SVR_TOTAL == _solverType) ? _extSolverType : _solverType; }$/;"	f	class:V3VrfBase
getSolverCexTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getSolverCexTrace(V3SvrBase* const solver, const uint32_t& cycle) {$/;"	f	class:V3VrfSEC
getStart	ext/v3Property.h	/^      inline const uint32_t getStart() const { assert (isPOConstr()); return V3PairType(_constrInfo).bus[0]; }$/;"	f	class:V3Constraint
getState	dfx/v3DfxTrace.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3DfxCube
getState	vrf/v3VrfCITP.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3CITPCube
getState	vrf/v3VrfFITP.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3FITPCube
getState	vrf/v3VrfIPDR.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3IPDRCube
getState	vrf/v3VrfMPDR.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3MPDRCube
getStateBwdReachable	stg/v3StgFSM.cpp	/^V3FSM::getStateBwdReachable(const uint32_t& state, V3UI32Vec& bwdStates, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getStateFwdReachable	stg/v3StgFSM.cpp	/^V3FSM::getStateFwdReachable(const uint32_t& state, V3UI32Vec& fwdStates, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getStateName	stg/v3StgFSM.cpp	/^V3FSM::getStateName(const uint32_t& i) const {$/;"	f	class:V3FSM
getStateNet	stg/v3StgFSM.h	/^      inline const V3NetId getStateNet() const { return _netId; }$/;"	f	class:V3FSMSDG
getStateNetId	stg/v3StgFSM.cpp	/^V3FSM::getStateNetId(const uint32_t& state, V3NetVec& stateData) const {$/;"	f	class:V3FSM
getStateSize	stg/v3StgFSM.cpp	/^V3FSMSDG::getStateSize() const {$/;"	f	class:V3FSMSDG
getStateSize	stg/v3StgFSM.cpp	/^V3FSMSDGDB::getStateSize() const {$/;"	f	class:V3FSMSDGDB
getStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getStateSize() const { return _sdgDB->getStateSize(); }$/;"	f	class:V3FSM
getStateStr	vrf/v3VrfCITP.cpp	/^V3VrfCITP::getStateStr(const V3NetVec& state) const {$/;"	f	class:V3VrfCITP
getStepBwdFromTerm	stg/v3StgFSM.cpp	/^V3FSM::getStepBwdFromTerm(const uint32_t& state) const {$/;"	f	class:V3FSM
getStepFwdFromInit	stg/v3StgFSM.cpp	/^V3FSM::getStepFwdFromInit(const uint32_t& state) const {$/;"	f	class:V3FSM
getStronglyConnectedComponents	adt/v3Graph.h	/^V3Graph<T>::getStronglyConnectedComponents(V3NodeField& scc) const {$/;"	f	class:V3Graph
getStronglyConnectedComponentsIndex	adt/v3Graph.h	/^V3Graph<T>::getStronglyConnectedComponentsIndex(V3IndexField& scc) const {$/;"	f	class:V3Graph
getSubsumedCubes	dfx/v3DfxTrace.cpp	/^const V3Vec<V3DfxCube*>::Vec getSubsumedCubes(V3DfxCube* const cube, const V3DfxCubeList& stateList) {$/;"	f
getSubsumingCubes	dfx/v3DfxTrace.cpp	/^const V3Vec<V3DfxCube*>::Vec getSubsumingCubes(V3DfxCube* const cube, const V3DfxCubeList& stateList) {$/;"	f
getSupport	bdd/bddMgrV.h	/^   const BddNodeV& getSupport(size_t i) const { return _supports[i]; }$/;"	f	class:BddMgrV
getTBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getTBase() const { return _tBase; }$/;"	f	class:V3SDGMUX
getTargetCandidate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getTargetCandidate() {$/;"	f	class:V3VrfSEC
getTermBwdReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getTermBwdReachableSize() {$/;"	f	class:V3FSM
getTermStateSize	stg/v3StgFSM.cpp	/^V3FSM::getTermStateSize() const {$/;"	f	class:V3FSM
getTermStates	stg/v3StgFSM.cpp	/^V3FSM::getTermStates(V3UI32Vec& states, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getTime	svr/v3SvrBase.cpp	/^V3SvrBase::getTime() const {$/;"	f	class:V3SvrBase
getTime	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getTime() const {$/;"	f	class:V3SvrMiniSat
getTimeUsed	vrf/v3VrfShared.h	21;"	d
getToSize	adt/v3Graph.h	/^V3Graph<T>::getToSize(const uint32_t& f) const {$/;"	f	class:V3Graph
getTotalOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::getTotalOccupiedCores() {$/;"	f	class:V3MCResource
getTrace	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::getTrace() const {$/;"	f	class:V3TraceSimplify
getTraceDataSize	ext/v3Property.h	/^      inline const uint32_t getTraceDataSize() const { return _data.size(); }$/;"	f	class:V3CexTrace
getTraceSize	ext/v3Property.h	/^      inline const uint32_t getTraceSize() const { return _size; }$/;"	f	class:V3CexTrace
getTrueSDG	stg/v3StgFSM.h	/^      inline const V3FSMSDGSet& getTrueSDG() const { return _trueSDG; }$/;"	f	class:V3FSMSDG
getTrueStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getTrueStateSize() const { return _trueSize; }$/;"	f	class:V3FSMSDG
getUInt	pdr/FileV.cpp	/^uint64 getUInt(File& in)$/;"	f
getUNSATCore	itp/satMgr.cpp	/^vector<Clause> SATMgr::getUNSATCore() const {$/;"	f	class:SATMgr
getUndecided	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::getUndecided() const {$/;"	f	class:V3AlgGeneralize
getUnrolledNtk	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::getUnrolledNtk(const bool& genOnFF, const uint32_t& f){$/;"	f	class:V3TraceSimplify
getUnsolvedSize	vrf/v3VrfShared.h	/^      inline uint32_t getUnsolvedSize() const { return _unsvd; }$/;"	f	class:V3VrfSharedBound
getV3CmdType	cmd/v3CmdMgr.h	/^      inline V3CmdType getV3CmdType() const { return _cmdType; }$/;"	f	class:V3CmdExec
getV3ExtendNormal	ntk/v3Ntk.h	31;"	d
getV3InvertNet	ntk/v3Ntk.h	17;"	d
getV3NetIndex	ntk/v3Ntk.h	18;"	d
getValue	pdr/v3SvrPDRSat.cpp	/^int V3SvrPDRSat::getValue(Var v) const {$/;"	f	class:V3SvrPDRSat
getVarSize	alg/v3AlgGeneralize.h	/^      inline const uint32_t getVarSize() const { return _var2Cube.size(); }$/;"	f	class:V3GenStruct
getVariableSize	stg/v3StgExtract.h	/^      inline const uint32_t getVariableSize() const { return _depGraph.getNodeSize(); }$/;"	f	class:V3FSMExtract
getVerifyData	itp/sat.cpp	/^const Var SatSolver::getVerifyData(const V3NetId& id, const uint32_t& depth) const$/;"	f	class:SatSolver
getVerifyData	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::getVerifyData(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrPDRSat
getVerifyData	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getVerifyData(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBoolector
getVerifyData	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getVerifyData(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrMiniSat
getVerilogModuleName	io/v3RTLWriter.cpp	/^const string getVerilogModuleName(const V3NtkHandler* const handler) {$/;"	f
getVerilogName	io/v3RTLWriter.cpp	/^const string getVerilogName(const V3NtkHandler* const handler, const string& name) {$/;"	f
getmin	pdr/HeapV.h	/^    int  getmin() {$/;"	f	class:Heap
greater_2	svr/v3SvrSatHelper.h	/^inline void greater_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
greater_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId greater_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
grow	pdr/GlobalV.h	/^void vec<T>::grow(int min_cap) {$/;"	f	class:vec
growTo	pdr/GlobalV.h	/^void vec<T>::growTo(int size) {$/;"	f	class:vec
growTo	pdr/GlobalV.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:vec
hash	pdr/SolverTypesV.h	/^    inline uint hash() const { return (uint)x; }$/;"	f	class:Lit
hashV3BusId	ntk/v3Ntk.cpp	/^V3BvNtk::hashV3BusId(const uint32_t& msb, const uint32_t& lsb) {$/;"	f	class:V3BvNtk
hashV3ConstBitVec	ntk/v3Ntk.cpp	/^V3BvNtk::hashV3ConstBitVec(const string& input_exp) {$/;"	f	class:V3BvNtk
heap	pdr/HeapV.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:Heap
heap	pdr/VarOrderV.h	/^    Heap<VarOrder_lt>   heap;$/;"	m	class:VarOrder
heapProperty	pdr/HeapV.h	/^    bool heapProperty() {$/;"	f	class:Heap
heapProperty	pdr/HeapV.h	/^    bool heapProperty(int i) {$/;"	f	class:Heap
help	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::help() const {$/;"	f	class:V3PlotTraceCmd
help	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::help() const {$/;"	f	class:V3SimNtkCmd
help	bdd/bddCmd.cpp	/^BAndCmd::help() const$/;"	f	class:BAndCmd
help	bdd/bddCmd.cpp	/^BCofactorCmd::help() const$/;"	f	class:BCofactorCmd
help	bdd/bddCmd.cpp	/^BCompareCmd::help() const$/;"	f	class:BCompareCmd
help	bdd/bddCmd.cpp	/^BConstructCmd::help() const$/;"	f	class:BConstructCmd
help	bdd/bddCmd.cpp	/^BDrawCmd::help() const$/;"	f	class:BDrawCmd
help	bdd/bddCmd.cpp	/^BExistCmd::help() const$/;"	f	class:BExistCmd
help	bdd/bddCmd.cpp	/^BInvCmd::help() const$/;"	f	class:BInvCmd
help	bdd/bddCmd.cpp	/^BNandCmd::help() const$/;"	f	class:BNandCmd
help	bdd/bddCmd.cpp	/^BNorCmd::help() const$/;"	f	class:BNorCmd
help	bdd/bddCmd.cpp	/^BOrCmd::help() const$/;"	f	class:BOrCmd
help	bdd/bddCmd.cpp	/^BReportCmd::help() const$/;"	f	class:BReportCmd
help	bdd/bddCmd.cpp	/^BResetCmd::help() const$/;"	f	class:BResetCmd
help	bdd/bddCmd.cpp	/^BSetOrderCmd::help() const$/;"	f	class:BSetOrderCmd
help	bdd/bddCmd.cpp	/^BSetVarCmd::help() const$/;"	f	class:BSetVarCmd
help	bdd/bddCmd.cpp	/^BSimulateCmd::help() const$/;"	f	class:BSimulateCmd
help	bdd/bddCmd.cpp	/^BXnorCmd::help() const$/;"	f	class:BXnorCmd
help	bdd/bddCmd.cpp	/^BXorCmd::help() const$/;"	f	class:BXorCmd
help	cmd/v3CmdComm.cpp	/^V3DofileCmd::help() const {$/;"	f	class:V3DofileCmd
help	cmd/v3CmdComm.cpp	/^V3HelpCmd::help() const {$/;"	f	class:V3HelpCmd
help	cmd/v3CmdComm.cpp	/^V3HistoryCmd::help() const {$/;"	f	class:V3HistoryCmd
help	cmd/v3CmdComm.cpp	/^V3LogFileCmd::help() const {$/;"	f	class:V3LogFileCmd
help	cmd/v3CmdComm.cpp	/^V3QuitCmd::help() const {$/;"	f	class:V3QuitCmd
help	cmd/v3CmdComm.cpp	/^V3UsageCmd::help() const {$/;"	f	class:V3UsageCmd
help	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::help() const {$/;"	f	class:V3OptTraceCmd
help	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::help() const {$/;"	f	class:V3TraceSimplifyCmd
help	itp/satCmd.cpp	/^SATVerifyBmcCmd::help() const$/;"	f	class:SATVerifyBmcCmd
help	itp/satCmd.cpp	/^SATVerifyItpCmd::help() const$/;"	f	class:SATVerifyItpCmd
help	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::help() const {$/;"	f	class:V3DuplicateNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::help() const {$/;"	f	class:V3ListNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::help() const$/;"	f	class:V3NetInfoCmd
help	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::help() const {$/;"	f	class:V3PlotNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::help() const {$/;"	f	class:V3PrintNetCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::help() const {$/;"	f	class:V3PrintNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::help() const {$/;"	f	class:V3PrintVerbosityCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::help() const {$/;"	f	class:V3ReadAIGCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::help() const {$/;"	f	class:V3ReadBTORCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::help() const {$/;"	f	class:V3ReadRTLCmd
help	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::help() const {$/;"	f	class:V3ReduceNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::help() const {$/;"	f	class:V3RefNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::help() const {$/;"	f	class:V3RewriteNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::help() const {$/;"	f	class:V3SetNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::help() const {$/;"	f	class:V3SetVerbosityCmd
help	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::help() const {$/;"	f	class:V3StrashNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::help() const {$/;"	f	class:V3WorkNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::help() const {$/;"	f	class:V3WriteAIGCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::help() const {$/;"	f	class:V3WriteBTORCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::help() const {$/;"	f	class:V3WriteRTLCmd
help	pdr/pdrCmd.cpp	/^SATVerifyCmd::help() const$/;"	f	class:SATVerifyCmd
help	prove/proveCmd.cpp	/^PCheckPropertyCmd::help() const$/;"	f	class:PCheckPropertyCmd
help	prove/proveCmd.cpp	/^PImageCmd::help() const$/;"	f	class:PImageCmd
help	prove/proveCmd.cpp	/^PInitialStateCmd::help() const$/;"	f	class:PInitialStateCmd
help	prove/proveCmd.cpp	/^PTransRelationCmd::help() const$/;"	f	class:PTransRelationCmd
help	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::help() const {$/;"	f	class:V3ElaborateFSMCmd
help	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::help() const {$/;"	f	class:V3ExtractFSMCmd
help	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::help() const {$/;"	f	class:V3PlotFSMCmd
help	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::help() const {$/;"	f	class:V3WriteFSMCmd
help	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::help() const {$/;"	f	class:V3BlastNtkCmd
help	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::help() const {$/;"	f	class:V3ExpandNtkCmd
help	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::help() const {$/;"	f	class:V3FlattenNtkCmd
help	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::help() const {$/;"	f	class:V3MiterNtkCmd
help	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::help() const {$/;"	f	class:V3MCReadPropertyCmd
help	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::help() const {$/;"	f	class:V3MCRunCmd
help	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::help() const {$/;"	f	class:V3MCWritePropertyCmd
help	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::help() const {$/;"	f	class:V3BMCVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::help() const {$/;"	f	class:V3CheckResultCmd
help	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::help() const {$/;"	f	class:V3ElaboratePrptyCmd
help	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::help() const {$/;"	f	class:V3ITPVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::help() const {$/;"	f	class:V3KLiveVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::help() const {$/;"	f	class:V3PDRVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::help() const {$/;"	f	class:V3PlotResultCmd
help	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::help() const {$/;"	f	class:V3PrintReportCmd
help	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::help() const {$/;"	f	class:V3PrintSolverCmd
help	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::help() const {$/;"	f	class:V3SECVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::help() const {$/;"	f	class:V3SIMVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::help() const {$/;"	f	class:V3SetLivenessCmd
help	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::help() const {$/;"	f	class:V3SetReportCmd
help	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::help() const {$/;"	f	class:V3SetSafetyCmd
help	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::help() const {$/;"	f	class:V3SetSolverCmd
help	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::help() const {$/;"	f	class:V3UMCVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::help() const {$/;"	f	class:V3WriteResultCmd
hwmcc_aiger_decode	v3mc/v3MCAiger.cpp	/^unsigned hwmcc_aiger_decode(FILE* file) {$/;"	f
hwmcc_aiger_getnoneofch	v3mc/v3MCAiger.cpp	/^unsigned char hwmcc_aiger_getnoneofch(FILE* file) {$/;"	f
hwmcc_aiger_symbol	v3mc/v3MCAiger.cpp	/^bool hwmcc_aiger_symbol(FILE* file, unsigned char& c, uint32_t& index, string& name) {$/;"	f
hwmcc_encode_aig	v3mc/v3MCAiger.cpp	/^void hwmcc_encode_aig(ofstream& output, int x) {$/;"	f
id	ntk/v3Type.h	/^   V3NetId     id;$/;"	m	union:V3NetType
id	ntk/v3Type.h	/^   uint32_t    id : 31;$/;"	m	struct:V3NetId
id	pdr/SolverTypesV.h	/^    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }$/;"	f	class:Clause
id	pdr/SolverTypesV.h	/^inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }$/;"	f
id_counter	pdr/ProofV.h	/^    ClauseId        id_counter;$/;"	m	class:Proof
identifyCandidates	stg/v3StgSDG.cpp	/^V3AigSDG::identifyCandidates() {$/;"	f	class:V3AigSDG
inHeap	pdr/HeapV.h	/^    bool inHeap    (int n)    { assert(ok(n)); return indices[n] != 0; }$/;"	f	class:Heap
inc	alg/v3AlgGeneralize.cpp	/^V3GenBucket::inc(const uint32_t& data, const uint32_t& amount) {$/;"	f	class:V3GenBucket
incInstRef	ntk/v3NtkHandler.h	/^      inline void incInstRef() { ++_instRef; assert (_instRef); }$/;"	f	class:V3NtkHandler
incOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::incOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
incRefCount	bdd/bddNodeV.h	/^   void incRefCount() { ++_refCount; }$/;"	f	class:BddNodeVInt
incRefCount	ntk/v3NtkHandler.h	/^      inline void incRefCount() { ++_refCount; assert (_refCount); }$/;"	f	class:V3NtkHandler
increase	pdr/HeapV.h	/^    void increase  (int n)    { assert(ok(n)); assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
indBmc	itp/satMgr.cpp	/^void SATMgr::indBmc(const V3NetId& monitor, SatProofRes& pRes) {$/;"	f	class:SATMgr
index	pdr/SolverTypesV.h	/^inline int  index (Lit p) { return p.x; }                \/\/ A "toInt" method that guarantees small, positive integers suitable for array indexing.$/;"	f
indices	pdr/HeapV.h	/^    vec<int> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
init	adt/v3Bucket.h	/^V3BucketList<T>::init(const uint32_t& size) {$/;"	f	class:V3BucketList
init	adt/v3Bucket.h	/^V3IncBucketList<T>::init(const uint32_t& size) {$/;"	f	class:V3IncBucketList
init	bdd/bddMgrV.cpp	/^BddMgrV::init(size_t nin, size_t h, size_t c)$/;"	f	class:BddMgrV
init	bdd/myHash.h	/^   void init(size_t b) {$/;"	f	class:Hash
init	bdd/myHash.h	/^   void init(size_t s) { reset(); _size = s; _cache = new CacheNode[s]; }$/;"	f	class:Cache
initAlgCmd	alg/v3AlgCmd.cpp	/^bool initAlgCmd() {$/;"	f
initBddCmd	bdd/bddCmd.cpp	/^initBddCmd() {$/;"	f
initCommonCmd	cmd/v3CmdComm.cpp	/^bool initCommonCmd() {$/;"	f
initDfxCmd	dfx/v3DfxCmd.cpp	/^bool initDfxCmd() {$/;"	f
initItpCmd	itp/satCmd.cpp	/^initItpCmd() {$/;"	f
initNtkCmd	ntk/v3NtkCmd.cpp	/^bool initNtkCmd() {$/;"	f
initPdrCmd	pdr/pdrCmd.cpp	/^initPdrCmd() {$/;"	f
initProveCmd	prove/proveCmd.cpp	/^initProveCmd() {$/;"	f
initRelease	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::initRelease() { _init.clear(); }$/;"	f	class:V3SvrPDRSat
initRelease	svr/v3SvrBase.cpp	/^V3SvrBase::initRelease() {$/;"	f	class:V3SvrBase
initRelease	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::initRelease() {$/;"	f	class:V3SvrBoolector
initRelease	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::initRelease() { _init.clear(); }$/;"	f	class:V3SvrMiniSat
initStgCmd	stg/v3StgCmd.cpp	/^bool initStgCmd() {$/;"	f
initTransCmd	trans/v3TransCmd.cpp	/^bool initTransCmd() {$/;"	f
initV3MCCmd	v3mc/v3MCCmd.cpp	/^bool initV3MCCmd() {$/;"	f
initValue3Data	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::initValue3Data() {$/;"	f	class:V3SvrPDRSat
initVrfCmd	vrf/v3VrfCmd.cpp	/^bool initVrfCmd() {$/;"	f
initialize	ntk/v3Ntk.cpp	/^V3BvNtk::initialize() {$/;"	f	class:V3BvNtk
initialize	ntk/v3Ntk.cpp	/^V3Ntk::initialize() {$/;"	f	class:V3Ntk
initializeBMCSolver	vrf/v3VrfCITP.cpp	/^V3VrfCITP::initializeBMCSolver(const uint32_t& start, const uint32_t& frames) {$/;"	f	class:V3VrfCITP
initializeBMCSolver	vrf/v3VrfFITP.cpp	/^V3VrfFITP::initializeBMCSolver(const uint32_t& start, const uint32_t& frames) {$/;"	f	class:V3VrfFITP
initializeDepGraph	stg/v3StgExtract.cpp	/^V3FSMExtract::initializeDepGraph() {$/;"	f	class:V3FSMExtract
initializeECPair	vrf/v3VrfSEC.cpp	/^V3VrfSEC::initializeECPair() {$/;"	f	class:V3VrfSEC
initializeEventList	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::initializeEventList() {$/;"	f	class:V3AlgSimulate
initializeITPSolver	vrf/v3VrfCITP.cpp	/^V3VrfCITP::initializeITPSolver() {$/;"	f	class:V3VrfCITP
initializeITPSolver	vrf/v3VrfFITP.cpp	/^V3VrfFITP::initializeITPSolver() {$/;"	f	class:V3VrfFITP
initializeNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::initializeNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
initializeOperatorMap	ext/v3Formula.cpp	/^V3Formula::initializeOperatorMap() {$/;"	f	class:V3Formula
initializeReachTable	stg/v3StgFSM.cpp	/^V3FSM::initializeReachTable(const uint32_t& state) {$/;"	f	class:V3FSM
initializeSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::initializeSolver(const uint32_t& d, const bool& isReuse) {$/;"	f	class:V3VrfIPDR
initializeSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::initializeSolver() {$/;"	f	class:V3VrfMPDR
insert	bdd/myHash.h	/^   bool insert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
insert	pdr/HeapV.h	/^    void insert(int n) {$/;"	f	class:Heap
insertEdge	adt/v3Graph.h	/^V3Graph<T>::insertEdge(const T& f, const T& t) {$/;"	f	class:V3Graph
insertFF	stg/v3StgSDG.h	/^      inline void insertFF(const uint32_t& i) { _depFFSet.insert(i); }$/;"	f	class:V3SDGBase
insertMux	stg/v3StgSDG.h	/^      inline void insertMux(const uint32_t& i) { _depMuxSet.insert(i); }$/;"	f	class:V3SDGBase
insertNode	adt/v3Graph.h	/^V3Graph<T>::insertNode(const T& n) {$/;"	f	class:V3Graph
int64	pdr/GlobalV.h	/^typedef INT64              int64;$/;"	t
int64	pdr/GlobalV.h	/^typedef long long          int64;$/;"	t
intactON	vrf/v3VrfBase.h	/^      static inline const bool intactON()  { return reportON() && !(2ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
intp	pdr/GlobalV.h	/^typedef INT_PTR            intp;$/;"	t
intp	pdr/GlobalV.h	/^typedef __PTRDIFF_TYPE__   intp;$/;"	t
inv	trans/v3BvBlastAigHelper.h	/^inline const V3NetId inv(V3Ntk* const ntk, const V3NetId& a)$/;"	f
irand	pdr/GlobalV.h	/^static inline int irand(double& seed, int size) {$/;"	f
isAllOutFileON	util/v3Msg.h	/^      bool isAllOutFileON() { return V3Msg::_allout.is_open(); }$/;"	f	class:V3MsgMgr
isAllReachableFromBwd	stg/v3StgFSM.cpp	/^V3FSM::isAllReachableFromBwd() const {$/;"	f	class:V3FSM
isAllReachableFromFwd	stg/v3StgFSM.cpp	/^V3FSM::isAllReachableFromFwd() const {$/;"	f	class:V3FSM
isAssumeCECMiter	vrf/v3VrfSEC.h	/^      inline const bool isAssumeCECMiter() const { return _secCECAssumed; }$/;"	f	class:V3VrfSEC
isAssumeSECMiter	vrf/v3VrfSEC.h	/^      inline const bool isAssumeSECMiter() const { return _secSECAssumed; }$/;"	f	class:V3VrfSEC
isBddBuilt	ntk/v3Ntk.h	/^      const bool isBddBuilt() const { return _isBddBuilt; }$/;"	f	class:V3Ntk
isBlockBadCountIndep	vrf/v3VrfCITP.h	/^      inline const bool isBlockBadCountIndep()  const { return _itpAttr & 4ul;  }$/;"	f	class:V3VrfCITP
isBlockBadCountIndep	vrf/v3VrfFITP.h	/^      inline const bool isBlockBadCountIndep()  const { return _itpAttr & 4ul;  }$/;"	f	class:V3VrfFITP
isBlocked	pdr/pdrMgr.cpp	/^bool PDRMgr::isBlocked(TCube s) {$/;"	f	class:PDRMgr
isBlocked	pdr/v3SvrPDRSat.cpp	/^bool V3SvrPDRSat::isBlocked(TCube c) {$/;"	f	class:V3SvrPDRSat
isBlocked	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::isBlocked(const V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
isBlocked	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::isBlocked(const V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
isCex	ext/v3Property.h	/^      inline const bool isCex() const { return ((_cexOrInv & ~1ul) && !(_cexOrInv & 1ul)); }$/;"	f	class:V3VrfResult
isCharMatchToken	io/v3RTLParser.cpp	/^bool isCharMatchToken(const char& c, const V3RTLSplitToken& split) {$/;"	f
isCompleteFSM	stg/v3StgFSM.h	/^      inline const bool isCompleteFSM() const { return !(128ul & _configs) && _distInit.size(); }$/;"	f	class:V3FSM
isConstructStandardFSMEnabled	stg/v3StgFSM.h	/^      inline const bool isConstructStandardFSMEnabled() const { return 8ul & _configs; }$/;"	f	class:V3FSMSDGDB
isDynamicInc	vrf/v3VrfUMC.h	/^      inline const bool isDynamicInc() { return _umcAttr & 8ul; }$/;"	f	class:V3VrfUMC
isEarlySuspended	stg/v3StgFSM.h	/^      inline const bool isEarlySuspended() const { return 128ul & _configs; }$/;"	f	class:V3FSMSDGDB
isEmpty	alg/v3AlgGeneralize.h	/^      inline const bool isEmpty() const { return _buckets.size() <= _bestIndex; }$/;"	f	class:V3GenBucket
isEmpty	vrf/v3VrfCITP.h	/^      inline const bool isEmpty() const { return !_signature; }$/;"	f	class:V3CITPCube
isEmpty	vrf/v3VrfFITP.h	/^      inline const bool isEmpty() const { return !_signature; }$/;"	f	class:V3FITPCube
isEnableConstructStandardFSM	stg/v3StgExtract.h	/^      inline const bool isEnableConstructStandardFSM() const { return _configs & 256ul; }$/;"	f	class:V3FSMExtract
isEnableOmitNodesAllCombVars	stg/v3StgExtract.h	/^      inline const bool isEnableOmitNodesAllCombVars() const { return _configs & 16ul;  }$/;"	f	class:V3FSMExtract
isEnableOmitNodesIndepToVars	stg/v3StgExtract.h	/^      inline const bool isEnableOmitNodesIndepToVars() const { return _configs & 32ul;  }$/;"	f	class:V3FSMExtract
isEnableRenderNonEmptyStates	stg/v3StgExtract.h	/^      inline const bool isEnableRenderNonEmptyStates() const { return _configs & 64ul;  }$/;"	f	class:V3FSMExtract
isEnableStopOnAllInitOrTerms	stg/v3StgExtract.h	/^      inline const bool isEnableStopOnAllInitOrTerms() const { return _configs & 128ul; }$/;"	f	class:V3FSMExtract
isExternalSolver	stg/v3StgFSM.h	/^      inline const bool isExternalSolver() const { return  64ul & _configs; }$/;"	f	class:V3FSMSDGDB
isFSMConstr	ext/v3Property.h	/^      inline const bool isFSMConstr() const { return 1ul == (3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
isFilterOutNoMuxVariable	stg/v3StgExtract.h	/^      inline const bool isFilterOutNoMuxVariable()     const { return _configs & 4ul;   }$/;"	f	class:V3FSMExtract
isFilterOutNonSeqVariable	stg/v3StgExtract.h	/^      inline const bool isFilterOutNonSeqVariable()    const { return _configs & 8ul;   }$/;"	f	class:V3FSMExtract
isFireOnly	vrf/v3VrfUMC.h	/^      inline const bool isFireOnly  () { return _umcAttr & 1ul; }$/;"	f	class:V3VrfUMC
isFired	ext/v3Property.h	/^      inline const bool isFired() const { return _result.isCex(); }$/;"	f	class:V3Property
isFired	itp/satMgr.h	/^    bool isFired() const { return (_fired != V3NtkUD); }$/;"	f	class:SatProofRes
isFired	pdr/pdrMgr.h	/^    bool isFired() const { return (_fired != V3NtkUD); }$/;"	f	class:SatProofRes
isForceUnreachable	vrf/v3VrfCITP.h	/^      inline const bool isForceUnreachable()    const { return _itpAttr & 2ul;  }$/;"	f	class:V3VrfCITP
isForceUnreachable	vrf/v3VrfFITP.h	/^      inline const bool isForceUnreachable()    const { return _itpAttr & 2ul;  }$/;"	f	class:V3VrfFITP
isForwardSATGen	vrf/v3VrfIPDR.h	/^      inline const bool isForwardSATGen()   const { return _pdrAttr & 1ul; }$/;"	f	class:V3VrfIPDR
isForwardSATGen	vrf/v3VrfMPDR.h	/^      inline const bool isForwardSATGen()   const { return _pdrAttr & 1ul; }$/;"	f	class:V3VrfMPDR
isForwardUNSATGen	vrf/v3VrfIPDR.h	/^      inline const bool isForwardUNSATGen() const { return _pdrAttr & 2ul; }$/;"	f	class:V3VrfIPDR
isForwardUNSATGen	vrf/v3VrfMPDR.h	/^      inline const bool isForwardUNSATGen() const { return _pdrAttr & 2ul; }$/;"	f	class:V3VrfMPDR
isIncContinueOnLastSolver	vrf/v3VrfBase.h	/^      inline const bool isIncContinueOnLastSolver() const { return _incContinueOnLastSolver; }$/;"	f	class:V3VrfBase
isIncKeepLastReachability	vrf/v3VrfBase.h	/^      inline const bool isIncKeepLastReachability() const { return _incKeepLastReachability; }$/;"	f	class:V3VrfBase
isIncKeepSilent	vrf/v3VrfBase.h	/^      inline const bool isIncKeepSilent          () const { return _incKeepSilent;           }$/;"	f	class:V3VrfBase
isIncVerifyUsingCurResult	vrf/v3VrfBase.h	/^      inline const bool isIncVerifyUsingCurResult() const { return _incVerifyUsingCurResult; }$/;"	f	class:V3VrfBase
isIncrementDepth	vrf/v3VrfCITP.h	/^      inline const bool isIncrementDepth()      const { return _itpAttr & 1ul;  }$/;"	f	class:V3VrfCITP
isIncrementDepth	vrf/v3VrfFITP.h	/^      inline const bool isIncrementDepth()      const { return _itpAttr & 1ul;  }$/;"	f	class:V3VrfFITP
isInitial	pdr/v3SvrPDRSat.cpp	/^bool V3SvrPDRSat::isInitial(Cube* c) {$/;"	f	class:V3SvrPDRSat
isInternalCEC	vrf/v3VrfSEC.h	/^      inline const bool isInternalCEC() const { return _secCECAssumed && !_secIsCECorSEC; }$/;"	f	class:V3VrfSEC
isInternalSEC	vrf/v3VrfSEC.h	/^      inline const bool isInternalSEC() const { return _secSECAssumed &&  _secIsCECorSEC; }$/;"	f	class:V3VrfSEC
isInv	ext/v3Property.h	/^      inline const bool isInv() const { return ((_cexOrInv & ~1ul) &&  (_cexOrInv & 1ul)); }$/;"	f	class:V3VrfResult
isInvariantDirectedCluster	stg/v3StgExtract.h	/^      inline const bool isInvariantDirectedCluster()   const { return _configs & 2ul;   }$/;"	f	class:V3FSMExtract
isIsolatedNode	adt/v3Graph.h	/^V3Graph<T>::isIsolatedNode(const uint32_t& i) const {$/;"	f	class:V3Graph
isLatestMiscData	ntk/v3Ntk.h	/^inline const bool V3Ntk::isLatestMiscData(const V3NetId& id) const {$/;"	f	class:V3Ntk
isLeaf	ext/v3Formula.h	/^      inline const bool isLeaf(const uint32_t& i) const { assert (isValid(i)); return V3_PI == _formula[i].first; }$/;"	f	class:V3Formula
isLeaf	ext/v3LTLFormula.h	/^      inline const bool isLeaf(const uint32_t& i) const { assert (isValid(i)); return V3_LTL_P == _formula[i].first; }$/;"	f	class:V3LTLFormula
isLegalFSMName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::isLegalFSMName(const string& fsmName) const {$/;"	f	class:V3NtkHandler
isLegalNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::isLegalNetName(const string& name) {$/;"	f	class:V3NtkHandler
isLit	pdr/SolverTypesV.h	/^    bool        isLit    () const { return ((uintp)data & 1) == 1; }$/;"	f	class:GClause
isMemValid	vrf/v3VrfShared.h	/^      inline const bool isMemValid() { lock(); const double m = v3Usage.getMemUsage(); unlock(); return _maxMemory > m; }$/;"	f	class:V3VrfSharedMem
isMileStone	stg/v3StgFSM.cpp	/^V3FSM::isMileStone(const uint32_t& state) const {$/;"	f	class:V3FSM
isMutable	ntk/v3NtkHandler.h	/^      inline const bool isMutable() const { return !(_refCount || _instRef); }$/;"	f	class:V3NtkHandler
isNegEdge	bdd/bddNodeV.h	/^   bool isNegEdge() const { return (_nodeV & BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
isNegFormula	itp/sat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:SatSolver
isNegFormula	pdr/v3SvrPDRSat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:V3SvrPDRSat
isNegFormula	svr/v3SvrBase.cpp	/^V3SvrBase::isNegFormula(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
isNegFormula	svr/v3SvrBoolector.h	/^      inline const bool isNegFormula(const size_t& e) const { return (e & 2ul); }$/;"	f	class:V3SvrBoolector
isNegFormula	svr/v3SvrMiniSat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:V3SvrMiniSat
isNoIncBySharedBound	vrf/v3VrfCITP.h	/^      inline const bool isNoIncBySharedBound()  const { return _itpAttr & 8ul;  }$/;"	f	class:V3VrfCITP
isNoIncBySharedBound	vrf/v3VrfFITP.h	/^      inline const bool isNoIncBySharedBound()  const { return _itpAttr & 8ul;  }$/;"	f	class:V3VrfFITP
isNtkRefBlackBoxed	ntk/v3Ntk.h	/^      inline const bool isNtkRefBlackBoxed() const { return (_ref & 1ul); }$/;"	f	class:V3NtkModule
isNtkValid	ntk/v3NtkHandler.h	/^      inline const bool isNtkValid(const uint32_t& i) const { return i < _hierInfo.size(); }$/;"	f	class:V3NtkHierInfo
isOmitNodesAllCombVarsEnabled	stg/v3StgFSM.h	/^      inline const bool isOmitNodesAllCombVarsEnabled() const { return 1ul & _configs; }$/;"	f	class:V3FSMSDGDB
isOmitNodesIndepToVarsEnabled	stg/v3StgFSM.h	/^      inline const bool isOmitNodesIndepToVarsEnabled() const { return 2ul & _configs; }$/;"	f	class:V3FSMSDGDB
isOutFileON	util/v3Msg.h	/^      bool isOutFileON() { return _outfile.is_open(); }$/;"	f	class:V3Msg
isOutputSet	svr/v3SvrBase.cpp	/^V3SvrBase::isOutputSet() const {$/;"	f	class:V3SvrBase
isPFixed	bdd/bddMgrV.h	/^   bool isPFixed() const { return _isFixed; }$/;"	f	class:BddMgrV
isPOConstr	ext/v3Property.h	/^      inline const bool isPOConstr()  const { return 0   == (3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
isPosEdge	bdd/bddNodeV.h	/^   bool isPosEdge() const { return !isNegEdge(); }$/;"	f	class:BddNodeV
isProveOnly	vrf/v3VrfUMC.h	/^      inline const bool isProveOnly () { return _umcAttr & 2ul; }$/;"	f	class:V3VrfUMC
isProved	itp/satMgr.h	/^    bool isProved() const { return (_proved != V3NtkUD); }$/;"	f	class:SatProofRes
isProved	pdr/pdrMgr.h	/^    bool isProved() const { return (_proved != V3NtkUD); }$/;"	f	class:SatProofRes
isProven	ext/v3Property.h	/^      inline const bool isProven() const { return _result.isInv(); }$/;"	f	class:V3Property
isRecycleInterpolants	vrf/v3VrfCITP.h	/^      inline const bool isRecycleInterpolants() const { return _itpAttr & 16ul; }$/;"	f	class:V3VrfCITP
isRecycleInterpolants	vrf/v3VrfFITP.h	/^      inline const bool isRecycleInterpolants() const { return _itpAttr & 16ul; }$/;"	f	class:V3VrfFITP
isRefValid	ntk/v3NtkHandler.h	/^      inline const bool isRefValid(const uint32_t& i) const { return i < _refIdMap.size(); }$/;"	f	class:V3NtkHierInfo
isRenderNonEmptyStatesEnabled	stg/v3StgFSM.h	/^      inline const bool isRenderNonEmptyStatesEnabled() const { return 4ul & _configs; }$/;"	f	class:V3FSMSDGDB
isStopOnAllInitialOrAllTerminal	stg/v3StgFSM.h	/^      inline const bool isStopOnAllInitialOrAllTerminal() const { return 1ul & _configs; }$/;"	f	class:V3FSM
isSynthesisMode	vrf/v3VrfSEC.h	/^      inline const bool isSynthesisMode() const { return _secSynthesis; }$/;"	f	class:V3VrfSEC
isTerminal	bdd/bddNodeV.cpp	/^BddNodeV::isTerminal() const$/;"	f	class:BddNodeV
isUniqueness	vrf/v3VrfUMC.h	/^      inline const bool isUniqueness() { return _umcAttr & 4ul; }$/;"	f	class:V3VrfUMC
isV3BlackBoxed	ntk/v3Ntk.h	20;"	d
isV3ConstType	ntk/v3Ntk.h	21;"	d
isV3ExchangableType	ntk/v3Ntk.h	29;"	d
isV3ExtendInvIn	ntk/v3Ntk.h	26;"	d
isV3ExtendInvOut	ntk/v3Ntk.h	27;"	d
isV3ExtendSwapIn	ntk/v3Ntk.h	25;"	d
isV3ExtendType	ntk/v3Ntk.h	24;"	d
isV3NetInverted	ntk/v3Ntk.h	19;"	d
isV3PairType	ntk/v3Ntk.h	23;"	d
isV3ReducedType	ntk/v3Ntk.h	22;"	d
isValid	ext/v3Formula.h	/^      inline const bool isValid() const { return _rootId < _formula.size(); }$/;"	f	class:V3Formula
isValid	ext/v3Formula.h	/^      inline const bool isValid(const uint32_t& i) const { return i < _formula.size(); }$/;"	f	class:V3Formula
isValid	ext/v3LTLFormula.h	/^      inline const bool isValid() const { return _rootId < _formula.size(); }$/;"	f	class:V3LTLFormula
isValid	ext/v3LTLFormula.h	/^      inline const bool isValid(const uint32_t& i) const { return i < _formula.size(); }$/;"	f	class:V3LTLFormula
isValid	stg/v3StgFSM.h	/^      inline const bool isValid() const { return !isEarlySuspended() && (getStateSize() <= _maxSize); }$/;"	f	class:V3FSMSDGDB
isValidBddName	bdd/bddCmd.cpp	/^static bool isValidBddName(const string& str)$/;"	f	file:
isValidCandidates	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidCandidates(const uint32_t& cycle) const {$/;"	f	class:V3VrfSEC
isValidChecker	vrf/v3VrfKLive.cpp	/^V3VrfKLive::isValidChecker() const {$/;"	f	class:V3VrfKLive
isValidChecker	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidChecker() const {$/;"	f	class:V3VrfSEC
isValidCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::isValidCube(const V3NetVec& cube) const {$/;"	f	class:V3GenStruct
isValidInvariant	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidInvariant(const uint32_t& x) {$/;"	f	class:V3VrfSEC
isValidNet	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidNet(const V3NetId& id) const {$/;"	f	class:V3VrfSEC
isValidVarName	bdd/bddCmd.cpp	/^static bool isValidVarName(const string& str) {$/;"	f	file:
isValidVarName	prove/proveCmd.cpp	/^static bool isValidVarName(const string& str) {$/;"	f	file:
isVariableClusterBySCC	stg/v3StgExtract.h	/^      inline const bool isVariableClusterBySCC()       const { return _configs & 1ul;   }$/;"	f	class:V3FSMExtract
isVisited	bdd/bddNodeV.h	/^   bool isVisited() const { return (_visited == 1); }$/;"	f	class:BddNodeVInt
ite	bdd/bddMgrV.cpp	/^BddMgrV::ite(BddNodeV f, BddNodeV g, BddNodeV h)$/;"	f	class:BddMgrV
iterator	bdd/myHash.h	/^      iterator(Hash<HashKey, HashData>* h = 0, size_t b = 0, size_t bn = 0)$/;"	f	class:Hash::iterator
iterator	bdd/myHash.h	/^      iterator(const iterator& i)$/;"	f	class:Hash::iterator
iterator	bdd/myHash.h	/^   class iterator$/;"	c	class:Hash
itpUbmc	itp/satMgr.cpp	/^void SATMgr::itpUbmc(const V3NetId& monitor, SatProofRes& pRes) {$/;"	f	class:SATMgr
l_False	pdr/GlobalV.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_True	pdr/GlobalV.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_Undef	pdr/GlobalV.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
last	pdr/GlobalV.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	pdr/GlobalV.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
last	pdr/ProofV.h	/^    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }$/;"	f	class:Proof
lastToFirst_lt	pdr/SolverV.cpp	/^    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}$/;"	f	class:lastToFirst_lt
lastToFirst_lt	pdr/SolverV.cpp	/^class lastToFirst_lt {  \/\/ Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.$/;"	c	file:
lbool	pdr/GlobalV.h	/^    explicit lbool(int v) : value(v) { }$/;"	f	class:lbool
lbool	pdr/GlobalV.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	pdr/GlobalV.h	/^    lbool(bool x) : value((int)x*2-1) { }$/;"	f	class:lbool
lbool	pdr/GlobalV.h	/^class lbool {$/;"	c
learnt	pdr/SolverTypesV.h	/^    bool      learnt      ()      const { return size_learnt & 1; }$/;"	f	class:Clause
learnts	pdr/SolverV.h	/^    vec<Clause*>        learnts;          \/\/ List of learnt clauses.$/;"	m	class:SolverV
learnts_literals	pdr/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
left	pdr/HeapV.h	/^static inline int left  (int i) { return i+i; }$/;"	f
leq_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId leq_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
less_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId less_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
level	pdr/SolverV.h	/^    vec<int>            level;            \/\/ 'level[var]' is the decision level at which assignment was made.$/;"	m	class:SolverV
lexConcatenateOperand	ext/v3Formula.cpp	/^V3Formula::lexConcatenateOperand(const string& exp, uint32_t& lhs) {$/;"	f	class:V3Formula
lexConstOperand	ext/v3Formula.cpp	/^V3Formula::lexConstOperand(const string& exp) {$/;"	f	class:V3Formula
lexFSMSpec	stg/v3StgExtract.cpp	/^const bool lexFSMSpec(ifstream& input, uint32_t& lineNumber, V3StrVec& tokens) {$/;"	f
lexFormula	ext/v3Formula.cpp	/^V3Formula::lexFormula(V3OperatorMap::const_iterator& it, string& exp, uint32_t& lhs) {$/;"	f	class:V3Formula
lexHeaderInCexTrace	ext/v3ExtIO.cpp	/^inline const bool lexHeaderInCexTrace(const string& header, uint32_t& pC, uint32_t& pS, uint32_t& iS) {$/;"	f
lexLTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::lexLTLFormula(const string& exp) {$/;"	f	class:V3LTLFormula
lexLineBTOR	io/v3BtorParser.cpp	/^bool lexLineBTOR(ifstream& input, V3BtorLexVec& tokens) {$/;"	f
lexLineRTL	io/v3RTLParser.cpp	/^bool lexLineRTL(ifstream& input, V3StrVec& tokens, const V3RTLSplitToken& split) {$/;"	f
lexOperand	ext/v3Formula.cpp	/^V3Formula::lexOperand(const string& exp, uint32_t& index) {$/;"	f	class:V3Formula
lexOptions	cmd/v3CmdMgr.cpp	/^V3CmdExec::lexOptions(const string& option, vector<string>& tokens) const {$/;"	f	class:V3CmdExec
lexPropSpec	v3mc/v3MCProp.cpp	/^const bool lexPropSpec(ifstream& input, uint32_t& lineNumber, V3StrVec& tokens) {$/;"	f
lexSliceOperand	ext/v3Formula.cpp	/^V3Formula::lexSliceOperand(const string& exp, uint32_t& msb, uint32_t& lsb, uint32_t& index) {$/;"	f	class:V3Formula
lit	pdr/SolverTypesV.h	/^    Lit         lit      () const { return toLit(((intp)data) >> 1); }$/;"	f	class:GClause
lock	vrf/v3VrfShared.h	/^      inline void lock() { pthread_mutex_lock(&_mutex); }$/;"	f	class:V3VrfShared
locked	pdr/SolverV.h	/^    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }$/;"	f	class:SolverV
lseek64	pdr/FileV.h	13;"	d
main	main/main.cpp	/^int main(int argc, char** argv) {$/;"	f
makeNetId	ntk/v3Type.h	/^   static V3NetId makeNetId(uint32_t i = V3NtkUD, uint32_t c = 0) { V3NetId j; j.cp = c; j.id = i; return j; }$/;"	f	struct:V3NetId
mapVar2Net	itp/satMgr.cpp	/^void SATMgr::mapVar2Net(const Var& var, const V3NetId& net) {$/;"	f	class:SATMgr
markDepFF	stg/v3StgSDG.cpp	/^V3SDGBase::markDepFF(V3BitVec& marker) const {$/;"	f	class:V3SDGBase
markDepMux	stg/v3StgSDG.cpp	/^V3SDGBase::markDepMux(V3BitVec& marker) const {$/;"	f	class:V3SDGBase
markOffsetClause	itp/satMgr.cpp	/^void SATMgr::markOffsetClause(const ClauseId& cid) {$/;"	f	class:SATMgr
markOnsetClause	itp/satMgr.cpp	/^void SATMgr::markOnsetClause(const ClauseId& cid) {$/;"	f	class:SATMgr
max	pdr/GlobalV.h	/^template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }$/;"	f
max_literals	pdr/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
maximizeDontCares	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::maximizeDontCares(V3Ntk* const unrolledNtk, V3AlgGeneralize* const unrolledGen, const V3SimTrace& piValue, V3SimTrace& ffValue, const V3NetVec& targetNets) {$/;"	f	class:V3TraceSimplify
memReadStat	pdr/GlobalV.h	/^static inline int memReadStat(int field)$/;"	f
memUsed	pdr/GlobalV.h	/^static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }$/;"	f
memUsed	pdr/GlobalV.h	/^static inline int64 memUsed() {$/;"	f
mergeBitBlastedNets	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::mergeBitBlastedNets(V3NetId id, const uint32_t& size, const V3NetId& mergedId) {$/;"	f	class:V3BvBlastBv
mergeFairnessConstraints	v3mc/v3MCElaborate.cpp	/^void mergeFairnessConstraints(V3Ntk* const ntk, V3NetTable& constr) {$/;"	f
mergeMuxFaninSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::mergeMuxFaninSDG(V3FSMSDG* const sdgNew, V3FSMSDG* const sdgOld, const bool& invert) {$/;"	f	class:V3FSMSDGDB
min	pdr/GlobalV.h	/^template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }$/;"	f
minimizeTransitions	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::minimizeTransitions(V3Ntk* const unrolledNtk, V3AlgGeneralize* const unrolledGen, const V3SimTrace& piValue, V3SimTrace& ffValue, const V3NetVec& targetNets) {$/;"	f	class:V3TraceSimplify
misc	ntk/v3Type.h	/^   uint32_t    misc : 26;$/;"	m	struct:V3MiscType
mkLit	pdr/SolverTypesV.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f
mode	pdr/FileV.h	/^    FileMode    mode;       \/\/ Reading or writing.$/;"	m	class:File
model	pdr/SolverV.h	/^    vec<lbool>  model;              \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:SolverV
moveTo	pdr/GlobalV.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
msgMutex	util/v3Msg.h	/^      pthread_mutex_t msgMutex;$/;"	m	class:V3MsgMgr
mux	trans/v3BvBlastAigHelper.h	/^inline const V3NetId mux(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& s)$/;"	f
mux_a	svr/v3SvrSatHelper.h	/^inline void mux_a(Solver* SS, const Lit& o, const Lit& s, const Lit& a)$/;"	f
mux_abo	svr/v3SvrSatHelper.h	/^inline void mux_abo(Solver* SS, const Lit& o, const Lit& a, const Lit& b)$/;"	f
mux_b	svr/v3SvrSatHelper.h	/^inline void mux_b(Solver* SS, const Lit& o, const Lit& s, const Lit& b)$/;"	f
mySolve	pdr/SolverV.cpp	/^bool SolverV::mySolve(const vec<Lit>& assumps, int conflictThreshold, bool& result)$/;"	f	class:SolverV
nAssigns	pdr/SolverV.h	/^    int     nAssigns() { return trail.size(); }$/;"	f	class:SolverV
nClauses	pdr/SolverV.h	/^    int     nClauses() { return clauses.size(); }$/;"	f	class:SolverV
nLearnts	pdr/SolverV.h	/^    int     nLearnts() { return learnts.size(); }$/;"	f	class:SolverV
nRootCla	pdr/SolverV.h	/^    int     nRootCla() { return root_cla_count; } \/\/ MODIFICATION FOR SoCV$/;"	f	class:SolverV
nVars	pdr/SolverV.h	/^    int     nVars     ()                    { return assigns.size(); }$/;"	f	class:SolverV
nand_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nand_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
nand_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nand_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
neg	pdr/SolverTypesV.h	/^	inline void neg() { x ^= 0x1; }$/;"	f	class:Lit
newActVar	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::newActVar() {$/;"	f	class:V3SvrPDRSat
newClause	pdr/SolverV.cpp	/^void SolverV::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id )$/;"	f	class:SolverV
newDepFFCone	stg/v3StgSDG.h	/^      inline void newDepFFCone() { assert (!_depFFCone); _depFFCone = new V3SDGBase(); assert (_depFFCone); }$/;"	f	class:V3SDGBase
newDepMuxCone	stg/v3StgSDG.h	/^      inline void newDepMuxCone() { assert (!_depMuxCone); _depMuxCone = new V3SDGBase(); assert (_depMuxCone); }$/;"	f	class:V3SDGBase
newFrame	pdr/pdrMgr.cpp	/^void PDRMgr::newFrame(bool force) {$/;"	f	class:PDRMgr
newMiscData	ntk/v3Ntk.h	/^      inline void newMiscData() { assert (_globalMisc < V3MiscType(0, V3NtkUD).misc); ++_globalMisc; }$/;"	f	class:V3Ntk
newVar	itp/sat.cpp	/^const Var SatSolver::newVar() {$/;"	f	class:SatSolver
newVar	pdr/SolverV.cpp	/^Var SolverV::newVar() {$/;"	f	class:SolverV
newVar	pdr/VarOrderV.h	/^void VarOrder::newVar(void)$/;"	f	class:VarOrder
newVar	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::newVar(const uint32_t& width) {$/;"	f	class:V3SvrPDRSat
newVar	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::newVar(const uint32_t& width) {$/;"	f	class:V3SvrMiniSat
next	pdr/pdrMgr.cpp	/^TCube PDRMgr::next(const TCube& s){$/;"	f	class:PDRMgr
nodeMove	bdd/bddNodeV.cpp	/^BddNodeV::nodeMove(unsigned fromLevel, unsigned toLevel, bool& isMoved) const$/;"	f	class:BddNodeV
nodeMoveRecur	bdd/bddNodeV.cpp	/^BddNodeV::nodeMoveRecur$/;"	f	class:BddNodeV
nor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
nor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
noticePushComplete	alg/v3AlgGeneralize.cpp	/^V3GenBucket::noticePushComplete() {$/;"	f	class:V3GenBucket
null	itp/reader.h	/^	bool null()					{ return fd == -1; }$/;"	f	class:Reader
null	pdr/FileV.h	/^    bool null(void) {               \/\/ TRUE if no file is opened.$/;"	f	class:File
null	pdr/reader.h	/^	bool null()					{ return fd == -1; }$/;"	f	class:Reader
numBuckets	bdd/myHash.h	/^   size_t numBuckets() const { return _numBuckets; }$/;"	f	class:Hash
ok	pdr/HeapV.h	/^    bool ok(int n) { return n >= 0 && n < (int)indices.size(); }$/;"	f	class:Heap
ok	pdr/SolverV.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:SolverV
okay	pdr/SolverV.h	/^    bool    okay() { return ok; }       \/\/ FALSE means solver is in an conflicting state (must never be used again!)$/;"	f	class:SolverV
ones	adt/v3BitVec.cpp	/^V3BitVec::ones() const {$/;"	f	class:V3BitVec
op_add	adt/v3BitVec.cpp	/^V3BitVecX::op_add(const char& a, const char& b, const char& c) const$/;"	f	class:V3BitVecX
op_and	adt/v3BitVec.cpp	/^V3BitVecX::op_and(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_bv_equal	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_equal(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_bv_geq	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_geq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_bv_leq	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_leq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_carry	adt/v3BitVec.cpp	/^V3BitVecX::op_carry(const char& a, const char& b, const char& c) const$/;"	f	class:V3BitVecX
op_eq	adt/v3BitVec.cpp	/^V3BitVecX::op_eq(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_ge	adt/v3BitVec.cpp	/^V3BitVecX::op_ge(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_inv	adt/v3BitVec.cpp	/^V3BitVecX::op_inv(const char& a) const {$/;"	f	class:V3BitVecX
op_le	adt/v3BitVec.cpp	/^V3BitVecX::op_le(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_or	adt/v3BitVec.cpp	/^V3BitVecX::op_or(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_xor	adt/v3BitVec.cpp	/^V3BitVecX::op_xor(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
open	itp/reader.cpp	/^void Reader::open( const char* file_name ){$/;"	f	class:Reader
open	itp/reader.cpp	/^void Reader::open(int filedesc)$/;"	f	class:Reader
open	pdr/FileV.cpp	/^void File::open(cchar* name, cchar* mode_)$/;"	f	class:File
open	pdr/FileV.cpp	/^void File::open(int file_descr, FileMode m, bool own)$/;"	f	class:File
open	pdr/ProofV.cpp	/^    char* open(File& fp)$/;"	f	class:TempFiles
open	pdr/reader.cpp	/^void Reader::open( const char* file_name ){$/;"	f	class:Reader
open	pdr/reader.cpp	/^void Reader::open(int filedesc)$/;"	f	class:Reader
open64	pdr/FileV.h	14;"	d
openDofile	cmd/v3CmdMgr.h	/^      bool openDofile(const string& dof) { _dofile.open(dof.c_str()); return _dofile.is_open(); }$/;"	f	class:V3CmdMgr
operator !=	adt/v3BitVec.cpp	/^V3BitVecX::operator != (const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
operator !=	adt/v3BitVec.h	/^      inline const bool operator != (const V3BitVecS& v) const { return !(*this == v); }$/;"	f	class:V3BitVecS
operator !=	bdd/bddNodeV.h	/^   bool operator != (const BddNodeV& n) const { return (_nodeV != n._nodeV); }$/;"	f	class:BddNodeV
operator !=	bdd/myHash.h	/^      bool operator != (const iterator& i) const { return !(*this == i); }$/;"	f	class:Hash::iterator
operator !=	ntk/v3Type.h	/^   const bool operator != (const V3NetId& i) const { return !(*this == i); }$/;"	f	struct:V3NetId
operator !=	pdr/GlobalV.h	/^    bool  operator != (const lbool& other) const { return value != other.value; }$/;"	f	class:lbool
operator !=	pdr/GlobalV.h	/^template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }$/;"	f
operator !=	pdr/PDRDef.h	/^  bool operator != (const Value3& a) const {$/;"	f	class:Value3
operator !=	pdr/SolverTypesV.h	/^    bool        operator != (GClause c) const { return data != c.data; }$/;"	f	class:GClause
operator %=	adt/v3BitVec.cpp	/^V3BitVecX::operator %= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator &	bdd/bddNodeV.cpp	/^BddNodeV::operator & (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator &	pdr/PDRDef.h	/^  Value3 operator & (Value3 a) const {$/;"	f	class:Value3
operator &	pdr/PDRDef.h	/^  Value3 operator & (bool a) const {$/;"	f	class:Value3
operator &=	adt/v3BitVec.cpp	/^V3BitVec::operator &= (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator &=	adt/v3BitVec.cpp	/^V3BitVecX::operator &= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator &=	adt/v3BitVec.h	/^      inline V3BitVecS& operator &= (const V3BitVecS& v) { _data0 |= v._data0; _data1 &= v._data1; return *this; }$/;"	f	class:V3BitVecS
operator &=	bdd/bddNodeV.cpp	/^BddNodeV::operator &= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator ()	adt/v3Hash.h	/^   inline size_t operator() (const pair<S, T>& key) const {$/;"	f	struct:V3PairHashFcn
operator ()	adt/v3Hash.h	/^   inline size_t operator() (const pair<S, T>& key1, const pair<S, T>& key2) const {$/;"	f	struct:V3PairHashEqual
operator ()	adt/v3Misc.h	/^struct V3UI32LessOrEq { const bool operator() (const T& i, const T& j) const { return i <= j; } };$/;"	f	struct:V3UI32LessOrEq
operator ()	alg/v3AlgGeneralize.h	/^         inline const bool operator () (const V3GenVarPair& p1, const V3GenVarPair& p2) const {$/;"	f	struct:V3GenStruct::V3GenComp
operator ()	bdd/bddMgrV.h	/^   size_t operator() () const { return ((_f << 3)+(_g << 3)+(_h << 3)); }$/;"	f	class:BddCacheKeyV
operator ()	bdd/bddMgrV.h	/^   size_t operator() () const { return ((_l << 3) + (_r << 3) + _i); }$/;"	f	class:BddHashKeyV
operator ()	bdd/bddNodeV.h	/^   size_t operator () () const { return _nodeV; }$/;"	f	class:BddNodeV
operator ()	cmd/v3CmdMgr.h	/^struct V3CmdCompare { bool operator() (const V3CmdExec* a, const V3CmdExec* b) const { return (*a < *b); } };$/;"	f	struct:V3CmdCompare
operator ()	dfx/v3DfxTrace.h	/^   const bool operator() (const V3DfxCube* const s1, const V3DfxCube* const s2) const {$/;"	f	struct:V3DfxCubeCompare
operator ()	pdr/SolverV.cpp	/^    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }$/;"	f	class:lastToFirst_lt
operator ()	pdr/SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	f	struct:reduceDB_lt
operator ()	pdr/SortV.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	pdr/VarOrderV.h	/^    bool operator () (Var x, Var y) { return activity[x] > activity[y]; }$/;"	f	struct:VarOrder_lt
operator ()	pdr/pdrMgr.cpp	/^  bool operator() (const TCube lhs, const TCube rhs) const {$/;"	f	class:TCubeCmp
operator ()	util/v3Msg.h	/^      V3Msg& operator () (const V3MsgType type) {$/;"	f	class:V3MsgMgr
operator ()	vrf/v3VrfCITP.h	/^   const bool operator() (const V3CITPCube* const c1, const V3CITPCube* const c2) const {$/;"	f	struct:V3CITPCubeCompare
operator ()	vrf/v3VrfFITP.h	/^   const bool operator() (const V3FITPCube* const c1, const V3FITPCube* const c2) const {$/;"	f	struct:V3FITPCubeCompare
operator ()	vrf/v3VrfIPDR.h	/^   const bool operator() (const V3IPDRCube* const c1, const V3IPDRCube* const c2) const {$/;"	f	struct:V3IPDRCubeCompare
operator ()	vrf/v3VrfMPDR.h	/^   const bool operator() (const V3MPDRCube* const c1, const V3MPDRCube* const c2) const {$/;"	f	struct:V3MPDRCubeCompare
operator *	bdd/myHash.h	/^      HashNode& operator * () { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *	bdd/myHash.h	/^      const HashNode& operator * () const { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *=	adt/v3BitVec.cpp	/^V3BitVecX::operator *= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator ++	bdd/myHash.h	/^      iterator operator ++ (int) { iterator li=(*this); ++(*this); return li; }$/;"	f	class:Hash::iterator
operator ++	bdd/myHash.h	/^      iterator& operator ++ () {$/;"	f	class:Hash::iterator
operator +=	adt/v3BitVec.cpp	/^V3BitVecX::operator += (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator --	bdd/myHash.h	/^      iterator operator -- (int) { iterator li=(*this); --(*this); return li; }$/;"	f	class:Hash::iterator
operator --	bdd/myHash.h	/^      iterator& operator -- () {$/;"	f	class:Hash::iterator
operator -=	adt/v3BitVec.cpp	/^V3BitVecX::operator -= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator /=	adt/v3BitVec.cpp	/^V3BitVecX::operator \/= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator <	bdd/bddNodeV.cpp	/^BddNodeV::operator < (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator <	cmd/v3CmdMgr.cpp	/^V3CmdExec::operator < (const V3CmdExec& rhs) const {$/;"	f	class:V3CmdExec
operator <	pdr/SolverTypesV.h	/^inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  \/\/ '<' guarantees that p, ~p are adjacent in the ordering.$/;"	f
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVec& b) {$/;"	f
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVecS& v) {$/;"	f
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVecX& b) {$/;"	f
operator <<	bdd/bddNodeV.cpp	/^operator << (ostream& os, const BddNodeV& n)$/;"	f
operator <<	util/v3Msg.h	/^      friend V3Msg& operator << (V3Msg& m, StdEndLine e) {$/;"	f	class:V3Msg
operator <<	util/v3Msg.h	/^      template<class T> friend V3Msg& operator << (V3Msg& m, const T& s) {$/;"	f	class:V3Msg
operator <<	util/v3Usage.h	/^      friend ostream& operator << (ostream& os, const V3Stat& stat) {$/;"	f	class:V3Stat
operator <<=	adt/v3BitVec.cpp	/^V3BitVecX::operator <<= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator <=	bdd/bddNodeV.cpp	/^BddNodeV::operator <= (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator <=	pdr/GlobalV.h	/^template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }$/;"	f
operator =	adt/v3BitVec.cpp	/^V3BitVec::operator = (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator =	adt/v3BitVec.cpp	/^V3BitVecX::operator = (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator =	adt/v3Misc.h	/^      V3PortableType& operator = (const V3PortableType& t) {$/;"	f	class:V3PortableType
operator =	bdd/bddNodeV.cpp	/^BddNodeV::operator = (const BddNodeV& n)$/;"	f	class:BddNodeV
operator =	bdd/myHash.h	/^      iterator& operator = (const iterator& i) {$/;"	f	class:Hash::iterator
operator =	pdr/GlobalV.h	/^vec<T>& vec<T>::operator = (const vec<T>& other){$/;"	f	class:vec
operator =	pdr/PDRDef.h	/^  TCube& operator = (const TCube& t){$/;"	f	class:TCube
operator =	pdr/SolverTypesV.h	/^	inline void operator = (int n) { x = n; }$/;"	f	class:Lit
operator ==	adt/v3BitVec.cpp	/^V3BitVec::operator == (const V3BitVec& b) const {$/;"	f	class:V3BitVec
operator ==	adt/v3BitVec.cpp	/^V3BitVecX::operator == (const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
operator ==	adt/v3BitVec.h	/^      inline const bool operator == (const V3BitVecS& v) const { return (_data0 == v._data0) && (_data1 == v._data1); }$/;"	f	class:V3BitVecS
operator ==	bdd/bddMgrV.h	/^   bool operator == (const BddCacheKeyV& k) const {$/;"	f	class:BddCacheKeyV
operator ==	bdd/bddMgrV.h	/^   bool operator == (const BddHashKeyV& k) {$/;"	f	class:BddHashKeyV
operator ==	bdd/bddNodeV.h	/^   bool operator == (const BddNodeV& n) const { return (_nodeV == n._nodeV); }$/;"	f	class:BddNodeV
operator ==	bdd/myHash.h	/^      bool operator == (const iterator& i) const {$/;"	f	class:Hash::iterator
operator ==	ntk/v3Type.h	/^   const bool operator == (const V3NetId& i) const { return cp == i.cp && id == i.id; }$/;"	f	struct:V3NetId
operator ==	pdr/GlobalV.h	/^    bool  operator == (const lbool& other) const { return value == other.value; }$/;"	f	class:lbool
operator ==	pdr/PDRDef.h	/^  bool operator == (const Value3& a) const {$/;"	f	class:Value3
operator ==	pdr/SolverTypesV.h	/^    bool        operator == (GClause c) const { return data == c.data; }$/;"	f	class:GClause
operator ==	pdr/SolverTypesV.h	/^inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }$/;"	f
operator >	bdd/bddNodeV.h	/^   bool operator > (const BddNodeV& n) const { return !((*this) <= n); }$/;"	f	class:BddNodeV
operator >	pdr/GlobalV.h	/^template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }$/;"	f
operator >	pdr/PDRDef.h	/^  friend bool operator > (const TCube& l, const TCube& r) { return l._frame > r._frame; }$/;"	f	class:TCube
operator >=	bdd/bddNodeV.h	/^   bool operator >= (const BddNodeV& n) const { return !((*this) < n); }$/;"	f	class:BddNodeV
operator >=	pdr/GlobalV.h	/^template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }$/;"	f
operator >>=	adt/v3BitVec.cpp	/^V3BitVecX::operator >>= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator T*	pdr/GlobalV.h	/^    operator T*       (void)           { return data; }     \/\/ (unsafe but convenient)$/;"	f	class:vec
operator []	adt/v3BitVec.cpp	/^V3BitVec::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVec
operator []	adt/v3BitVec.cpp	/^V3BitVecS::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVecS
operator []	adt/v3BitVec.cpp	/^V3BitVecX::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVecX
operator []	bdd/myHash.h	/^   CacheNode& operator [] (size_t i) { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/myHash.h	/^   const CacheNode& operator [](size_t i) const { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/myHash.h	/^   const vector<HashNode>& operator [](size_t i) const { return _buckets[i]; }$/;"	f	class:Hash
operator []	bdd/myHash.h	/^   vector<HashNode>& operator [] (size_t i) { return _buckets[i]; }$/;"	f	class:Hash
operator []	pdr/GlobalV.h	/^    T&       operator [] (int index)        { return data[index]; }$/;"	f	class:vec
operator []	pdr/GlobalV.h	/^    const T& operator [] (int index) const  { return data[index]; }$/;"	f	class:vec
operator []	pdr/SolverTypesV.h	/^    Lit       operator [] (int i) const { return data[i]; }$/;"	f	class:Clause
operator []	pdr/SolverTypesV.h	/^    Lit&      operator [] (int i)       { return data[i]; }$/;"	f	class:Clause
operator ^	bdd/bddNodeV.cpp	/^BddNodeV::operator ^ (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator ^=	adt/v3BitVec.cpp	/^V3BitVecS::operator ^= (const V3BitVecS& v) {$/;"	f	class:V3BitVecS
operator ^=	adt/v3BitVec.cpp	/^V3BitVecX::operator ^= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator ^=	bdd/bddNodeV.cpp	/^BddNodeV::operator ^= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator const T*	pdr/GlobalV.h	/^    operator const T* (void) const     { return data; }$/;"	f	class:vec
operator |	bdd/bddNodeV.cpp	/^BddNodeV::operator | (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator |	pdr/PDRDef.h	/^  Value3 operator | (Value3 a) const {$/;"	f	class:Value3
operator |	pdr/PDRDef.h	/^  Value3 operator | (bool a) const {$/;"	f	class:Value3
operator |=	adt/v3BitVec.cpp	/^V3BitVec::operator |= (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator |=	adt/v3BitVec.cpp	/^V3BitVecX::operator |= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator |=	bdd/bddNodeV.cpp	/^BddNodeV::operator |= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator ~	adt/v3BitVec.cpp	/^V3BitVecX::operator ~ () const {$/;"	f	class:V3BitVecX
operator ~	adt/v3BitVec.h	/^      inline const V3BitVecS operator ~ () const { const V3BitVecS v(_data1, _data0); return v; }$/;"	f	class:V3BitVecS
operator ~	bdd/bddNodeV.h	/^   BddNodeV operator ~ () const { return (_nodeV ^ BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
operator ~	ntk/v3Type.h	/^   V3NetId operator ~ () const { return makeNetId(id, cp ^ 1); }$/;"	f	struct:V3NetId
operator ~	pdr/GlobalV.h	/^    lbool operator ~  (void)               const { return lbool(-value); }$/;"	f	class:lbool
operator ~	pdr/PDRDef.h	/^  Value3 operator ~ () const {$/;"	f	class:Value3
operator ~	pdr/SolverTypesV.h	/^inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
or_2	svr/v3SvrSatHelper.h	/^inline void or_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
or_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId or_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
or_red	svr/v3SvrSatHelper.h	/^inline void or_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
or_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId or_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
order	pdr/SolverV.h	/^    VarOrder            order;            \/\/ Keeps track of the decision variable order.$/;"	m	class:SolverV
overall_pos	itp/reader.h	/^	unsigned int	overall_pos;$/;"	m	class:Reader
overall_pos	pdr/reader.h	/^	unsigned int	overall_pos;$/;"	m	class:Reader
own_fd	pdr/FileV.h	/^    bool        own_fd;     \/\/ Do we own the file descriptor? If so, will close file in destructor.$/;"	m	class:File
pair	ntk/v3Type.h	/^      uint64_t    pair;$/;"	m	union:V3PairType::__anon1
parent	pdr/HeapV.h	/^static inline int parent(int i) { return i >> 1; }$/;"	f
parseCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::parseCmd(string& option) {$/;"	f	class:V3CmdMgr
pdrMgr	pdr/pdrCmd.cpp	/^static PDRMgr* pdrMgr = new PDRMgr();$/;"	v	file:
percolateDown	pdr/HeapV.h	/^    inline void percolateDown(int i)$/;"	f	class:Heap
percolateUp	pdr/HeapV.h	/^    inline void percolateUp(int i)$/;"	f	class:Heap
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgAigGeneralize
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgBvGeneralize
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgGeneralize
performImplicationForTargetUpdate	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performImplicationForTargetUpdate(V3NetVec& newSource) {$/;"	f	class:V3AlgAigGeneralize
performImplicationForTargetUpdate	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performImplicationForTargetUpdate(const V3NetId& id, V3NetVec& newSource, V3BoolVec& updated) {$/;"	f	class:V3AlgAigGeneralize
performInputFileSimulation	alg/v3AlgSim.cpp	/^const bool performInputFileSimulation(const V3NtkHandler* const handler, const string& fileName, $/;"	f
performNtkTransformation	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::performNtkTransformation() {$/;"	f	class:V3BvBlastAig
performNtkTransformation	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::performNtkTransformation() {$/;"	f	class:V3BvBlastBv
performNtkTransformation	trans/v3NtkExpand.cpp	/^V3NtkExpand::performNtkTransformation(const bool& init) {$/;"	f	class:V3NtkExpand
performNtkTransformation	trans/v3NtkMiter.cpp	/^V3NtkMiter::performNtkTransformation(V3NtkHandler* const handler1, V3NtkHandler* const handler2, const bool& merge) {$/;"	f	class:V3NtkMiter
performRandomSimulation	alg/v3AlgSim.cpp	/^const bool performRandomSimulation(const V3NtkHandler* const handler, const uint32_t& patternCount, $/;"	f
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgAigGeneralize
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgBvGeneralize
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgGeneralize
performSimulationForFrozenPropagation	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performSimulationForFrozenPropagation(const V3NetVec& newSource) {$/;"	f	class:V3AlgAigGeneralize
performTraceGeneralization	dfx/v3DfxTrace.cpp	/^void performTraceGeneralization(V3NtkHandler* const handler, V3Property* const p) {$/;"	f
performTraceReduction	dfx/v3DfxTrace.cpp	/^void performTraceReduction(V3NtkHandler* const handler, V3Property* const p) {$/;"	f
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgAigGeneralize
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgBvGeneralize
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgAigGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgBvGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgGeneralize
plotNetFanin	io/v3NtkWriter.cpp	/^void plotNetFanin(ofstream& os, V3Ntk* const ntk, const uint32_t& id, const unsigned& depth) {$/;"	f
pop	adt/v3Bucket.h	/^V3BucketList<T>::pop(uint32_t& index, T& t) {$/;"	f	class:V3BucketList
pop	adt/v3Bucket.h	/^V3IncBucketList<T>::pop(uint32_t& index, T& t) {$/;"	f	class:V3IncBucketList
pop	alg/v3AlgGeneralize.cpp	/^V3GenBucket::pop(uint32_t& data) {$/;"	f	class:V3GenBucket
pop	pdr/GlobalV.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
pos	itp/reader.h	/^	unsigned int	pos;$/;"	m	class:Reader
pos	pdr/FileV.h	/^    int         pos;        \/\/ Current position in buffer$/;"	m	class:File
pos	pdr/reader.h	/^	unsigned int	pos;$/;"	m	class:Reader
print	bdd/bddNodeV.cpp	/^BddNodeV::print(ostream& os, size_t indent, size_t& nNodes) const$/;"	f	class:BddNodeV
print	stg/v3StgSDG.cpp	/^V3SDGBase::print() const {$/;"	f	class:V3SDGBase
printCandidate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::printCandidate(const uint32_t& x) const {$/;"	f	class:V3VrfSEC
printCombLoops	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printCombLoops() const {$/;"	f	class:V3NtkHandler
printConfl	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printConfl(const V3UI32Set& cube) const {$/;"	f	class:V3GenStruct
printCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printCube(const V3NetVec& cube) const {$/;"	f	class:V3GenStruct
printCube2Var	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printCube2Var() const {$/;"	f	class:V3GenStruct
printFaninRec	ntk/v3Ntk.cpp	/^void V3Ntk::printFaninRec(V3NtkHandler* const handler, const V3NetId& netId, const int& depth, const int& level) {$/;"	f	class:V3Ntk
printFloatings	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printFloatings() const {$/;"	f	class:V3NtkHandler
printHelps	cmd/v3CmdMgr.cpp	/^V3CmdMgr::printHelps(bool revealed) const {$/;"	f	class:V3CmdMgr
printHistory	cmd/v3CmdMgr.cpp	/^V3CmdMgr::printHistory(int nPrint) const {$/;"	f	class:V3CmdMgr
printInfo	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::printInfo() const {$/;"	f	class:V3SvrPDRSat
printInfo	svr/v3SvrBase.cpp	/^V3SvrBase::printInfo() const {$/;"	f	class:V3SvrBase
printInfo	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::printInfo() const {$/;"	f	class:V3SvrBoolector
printInfo	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::printInfo() const {$/;"	f	class:V3SvrMiniSat
printLock	vrf/v3VrfShared.h	/^      static inline void printLock() { pthread_mutex_lock(&_printMutex); }$/;"	f	class:V3VrfShared
printNet	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printNet(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
printNetlist	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printNetlist() const {$/;"	f	class:V3NtkHandler
printNtkInAncestry	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkInAncestry() const {$/;"	f	class:V3Handler
printNtkInHierarchy	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkInHierarchy() const {$/;"	f	class:V3Handler
printNtkRelation	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkRelation(const string& fileName) const {$/;"	f	class:V3Handler
printPrimary	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printPrimary() const {$/;"	f	class:V3NtkHandler
printRecurHierarchy	ntk/v3NtkHandler.cpp	/^V3Handler::printRecurHierarchy(V3NtkHandler* const handler, const uint32_t& maxLevel, const uint32_t& level) const {$/;"	f	class:V3Handler
printReportSettings	vrf/v3VrfBase.cpp	/^V3VrfBase::printReportSettings() {$/;"	f	class:V3VrfBase
printResult	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::printResult() const {$/;"	f	class:V3AlgAigSimulate
printResult	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::printResult() const {$/;"	f	class:V3AlgBvSimulate
printResult	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::printResult() const { }$/;"	f	class:V3AlgSimulate
printSolverSettings	vrf/v3VrfBase.cpp	/^V3VrfBase::printSolverSettings() {$/;"	f	class:V3VrfBase
printState	vrf/v3VrfCITP.cpp	/^V3VrfCITP::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfCITP
printState	vrf/v3VrfFITP.cpp	/^V3VrfFITP::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfFITP
printState	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfIPDR
printState	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfMPDR
printSummary	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printSummary() const {$/;"	f	class:V3NtkHandler
printTraceInfo	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::printTraceInfo() const {$/;"	f	class:V3TraceSimplify
printUnlock	vrf/v3VrfShared.h	/^      static inline void printUnlock() { pthread_mutex_unlock(&_printMutex); }$/;"	f	class:V3VrfShared
printUnreachables	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printUnreachables() const {$/;"	f	class:V3NtkHandler
printVar2Cube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printVar2Cube() const {$/;"	f	class:V3GenStruct
printVerbose	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printVerbose() const {$/;"	f	class:V3NtkHandler
printVerbose	svr/v3SvrBase.cpp	/^V3SvrBase::printVerbose() const {$/;"	f	class:V3SvrBase
printVerbose	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::printVerbose() const {$/;"	f	class:V3SvrMiniSat
printVerbositySettings	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printVerbositySettings() {$/;"	f	class:V3NtkHandler
profileON	vrf/v3VrfBase.h	/^      static inline const bool profileON() { return reportON() &&  (32ul & _extVerbosity); }$/;"	f	class:V3VrfBase
progressEstimate	pdr/SolverV.cpp	/^double SolverV::progressEstimate()$/;"	f	class:SolverV
progress_estimate	pdr/SolverV.h	/^    double      progress_estimate;  \/\/ Set by 'search()'.$/;"	m	class:SolverV
proof	pdr/SolverV.h	/^    Proof*          proof;              \/\/ Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.$/;"	m	class:SolverV
proof_logged	pdr/SolverV.h	/^    bool    proof_logged() { return false; }$/;"	f	class:SolverV
propagate	pdr/SolverV.cpp	/^Clause* SolverV::propagate()$/;"	f	class:SolverV
propagateBlockedCubes	pdr/pdrMgr.cpp	/^bool PDRMgr::propagateBlockedCubes(SatProofRes& pRes) {$/;"	f	class:PDRMgr
propagateCubes	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::propagateCubes() {$/;"	f	class:V3VrfIPDR
propagateCubes	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::propagateCubes() {$/;"	f	class:V3VrfMPDR
propagate_tmpbin	pdr/SolverV.h	/^    Clause*             propagate_tmpbin;$/;"	m	class:SolverV
propagations	pdr/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
push	alg/v3AlgGeneralize.cpp	/^V3GenBucket::push(const uint32_t& data, const uint32_t& bucketIndex) {$/;"	f	class:V3GenBucket
push	pdr/GlobalV.h	/^    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }$/;"	f	class:vec
push	pdr/GlobalV.h	/^    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }$/;"	f	class:vec
pushAndSetCurHandler	ntk/v3NtkHandler.cpp	/^V3Handler::pushAndSetCurHandler(V3NtkHandler* const handler) {$/;"	f	class:V3Handler
pushCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::pushCube(const V3NetVec& cube, const bool& invert) {$/;"	f	class:V3GenStruct
pushCube	vrf/v3VrfCITP.cpp	/^V3CITPFrame::pushCube(V3CITPCube* const c) {$/;"	f	class:V3CITPFrame
pushCube	vrf/v3VrfFITP.cpp	/^V3FITPFrame::pushCube(V3FITPCube* const c) {$/;"	f	class:V3FITPFrame
pushCube	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::pushCube(V3IPDRCube* const c) {$/;"	f	class:V3IPDRFrame
pushCube	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::pushCube(V3MPDRCube* const c) {$/;"	f	class:V3MPDRFrame
pushData	ext/v3Property.h	/^      inline void pushData(const V3BitVecX& v) { _data.push_back(v); }$/;"	f	class:V3CexTrace
pushInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::pushInv(V3SvrBase* const solver, V3Ntk* const ntk, const uint32_t& depth) {$/;"	f	class:V3VrfSharedInv
pushNtk	ntk/v3NtkHandler.h	/^      inline void pushNtk(V3NtkHandler* const n, const uint32_t& p) { _hierInfo.push_back(new V3NtkHierData(n, p)); }$/;"	f	class:V3NtkHierInfo
pushRefId	ntk/v3NtkHandler.h	/^      inline void pushRefId(const uint32_t& id, const uint32_t& i) { _refIdMap.push_back(V3PairType(id, i)); }$/;"	f	class:V3NtkHierInfo
pushStateIntoSolver	stg/v3StgFSM.cpp	/^V3FSM::pushStateIntoSolver(V3SvrBase* const solver, const uint32_t& state, const uint32_t& depth) const {$/;"	f	class:V3FSM
pushTerminalState	stg/v3StgExtract.h	/^      inline void pushTerminalState(const V3NetId& id) { _terminals.push_back(id); }$/;"	f	class:V3FSMExtract
putChar	pdr/FileV.h	/^    int putChar(int chr) {$/;"	f	class:File
putCharQ	pdr/FileV.h	/^    int putCharQ(int chr) {         \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
putInt	pdr/FileV.h	/^static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }$/;"	f
putUInt	pdr/FileV.cpp	/^void putUInt(File& out, uint64 val)$/;"	f
qhead	pdr/SolverV.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:SolverV
quteRTL_MsgFile	io/v3NtkQuteRTL.cpp	/^const string quteRTL_MsgFile = "quteRTL.log";  \/\/ QuteRTL Log File$/;"	v
random	adt/v3BitVec.cpp	/^V3BitVec::random() {$/;"	f	class:V3BitVec
random	adt/v3BitVec.cpp	/^V3BitVecX::random() {$/;"	f	class:V3BitVecX
random	adt/v3BitVec.h	/^      inline void random() { _data0 = rand(); _data1 = ~_data0; }$/;"	f	class:V3BitVecS
randomGetInitialState	stg/v3StgFSM.cpp	/^V3FSM::randomGetInitialState() {$/;"	f	class:V3FSM
randomSimulate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::randomSimulate(const uint32_t& p, const uint32_t& cycle, const bool& initValid) {$/;"	f	class:V3VrfSEC
randomSimulateOneCycle	stg/v3StgFSM.cpp	/^V3FSM::randomSimulateOneCycle() {$/;"	f	class:V3FSM
random_seed	pdr/VarOrderV.h	/^    double              random_seed; \/\/ For the internal random number generator$/;"	m	class:VarOrder
random_var_freq	pdr/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
read	bdd/myHash.h	/^   bool read(const CacheKey& k, CacheData& d) const {$/;"	f	class:Cache
readAiger	v3mc/v3MCAiger.cpp	/^V3NtkInput* readAiger(const string& fileName, V3NetVec& badList, V3NetVec& invList, V3NetTable& fairList, const bool& hwmcc) {$/;"	f
readProperty	v3mc/v3MCProp.cpp	/^V3NtkHandler* const readProperty(V3NtkHandler* const handler, const string& fileName) {$/;"	f
readRTLModule	io/v3RTLParser.cpp	/^bool readRTLModule(ifstream& input, V3StrSet& ioNames, V3NtkInput* const handler) {$/;"	f
readRTLModuleHeader	io/v3RTLParser.cpp	/^bool readRTLModuleHeader(ifstream& input, string& moduleName, V3StrSet& ioNames) {$/;"	f
reallocNumOfCores	v3mc/v3MCMain.cpp	/^V3MCResource::reallocNumOfCores() {$/;"	f	class:V3MCResource
reason	pdr/SolverV.h	/^    vec<Clause*>        reason;           \/\/ 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:SolverV
recordCubeInputForTraceLog	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recordCubeInputForTraceLog(V3IPDRCube* const& cube) {$/;"	f	class:V3VrfIPDR
recordCubeInputForTraceLog	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recordCubeInputForTraceLog(V3MPDRCube* const& cube) {$/;"	f	class:V3VrfMPDR
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::recordSimValue() {$/;"	f	class:V3AlgAigSimulate
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::recordSimValue() {$/;"	f	class:V3AlgBvSimulate
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::recordSimValue() {}$/;"	f	class:V3AlgSimulate
recordSimulationValue	stg/v3StgFSM.cpp	/^V3FSM::recordSimulationValue(V3SimTrace& trace) const {$/;"	f	class:V3FSM
recordSolverValue	stg/v3StgFSM.cpp	/^V3FSM::recordSolverValue(V3SimTrace& trace, const uint32_t& depth) const {$/;"	f	class:V3FSM
recordSolverXValue	stg/v3StgFSM.cpp	/^V3FSM::recordSolverXValue(V3SimTrace& trace, const uint32_t& depth) const {$/;"	f	class:V3FSM
recoverForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::recoverForGeneralization() {$/;"	f	class:V3AlgAigGeneralize
recoverForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::recoverForGeneralization() {$/;"	f	class:V3AlgBvGeneralize
recurTraverseNtk	io/v3NtkWriter.cpp	/^void recurTraverseNtk(V3Ntk* const ntk, const uint32_t& id, const uint32_t& pId, unsigned& depth, V3Graph<uint32_t>& G) {$/;"	f
recursiveBlockCube	pdr/pdrMgr.cpp	/^bool PDRMgr::recursiveBlockCube(TCube s0){$/;"	f	class:PDRMgr
recursiveBlockCube	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recursiveBlockCube(V3IPDRCube* const badCube) {$/;"	f	class:V3VrfIPDR
recursiveBlockCube	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recursiveBlockCube(V3MPDRCube* const badCube) {$/;"	f	class:V3VrfMPDR
recycleSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recycleSolver(const uint32_t& d) {$/;"	f	class:V3VrfIPDR
recycleSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recycleSolver() {$/;"	f	class:V3VrfMPDR
reduceDB	pdr/SolverV.cpp	/^void SolverV::reduceDB()$/;"	f	class:SolverV
reduceDB_lt	pdr/SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	s	file:
reduceON	ntk/v3NtkHandler.h	/^      static inline const bool reduceON()  { return _extVerbosity & 1ul;  }$/;"	f	class:V3NtkHandler
referenceSolver	svr/v3SvrHandler.cpp	/^V3SvrBase* const referenceSolver(V3SvrBase* const solver) {$/;"	f
regCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::regCmd(const string& cmd, unsigned nCmp, V3CmdExec* e) {$/;"	f	class:V3CmdMgr
regCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::regCmd(const string& cmd, unsigned nCmp1, unsigned nCmp2, V3CmdExec* e) {$/;"	f	class:V3CmdMgr
regEx	adt/v3BitVec.cpp	/^V3BitVec::regEx() const {$/;"	f	class:V3BitVec
regEx	adt/v3BitVec.cpp	/^V3BitVecX::regEx() const {$/;"	f	class:V3BitVecX
release	pdr/GlobalV.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
releaseDescriptor	pdr/FileV.h	/^    int releaseDescriptor(void) {   \/\/ Don't run UNIX function 'close()' on descriptor in 'File's 'close()'.$/;"	f	class:File
releaseNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::releaseNtk(V3NtkHandler* const handler) {$/;"	f	class:V3VrfSharedNtk
remove	pdr/SolverV.cpp	/^void SolverV::remove(Clause* c, bool just_dealloc)$/;"	f	class:SolverV
removeConnection	adt/v3Graph.h	/^V3Graph<T>::removeConnection(const uint32_t& f, const uint32_t& t) {$/;"	f	class:V3Graph
removeECPairOutOfCOI	vrf/v3VrfSEC.cpp	/^V3VrfSEC::removeECPairOutOfCOI() {$/;"	f	class:V3VrfSEC
removeFromProof	vrf/v3VrfCITP.cpp	/^V3VrfCITP::removeFromProof(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
removeFromProof	vrf/v3VrfFITP.cpp	/^V3VrfFITP::removeFromProof(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
removeFromProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::removeFromProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
removeFromProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::removeFromProof(V3MPDRTimedCube& timedCube, const bool& pushForward) {$/;"	f	class:V3VrfMPDR
removeLastInout	ntk/v3Ntk.h	/^      inline void removeLastInout() { _IOList[2].pop_back(); }$/;"	f	class:V3Ntk
removeLastInput	ntk/v3Ntk.h	/^      inline void removeLastInput() { _IOList[0].pop_back(); }$/;"	f	class:V3Ntk
removeLastLatch	ntk/v3Ntk.h	/^      inline void removeLastLatch() { _FFList.pop_back(); }$/;"	f	class:V3Ntk
removeLastOutput	ntk/v3Ntk.h	/^      inline void removeLastOutput() { _IOList[1].pop_back(); }$/;"	f	class:V3Ntk
removePrefixNetName	ntk/v3NtkInput.cpp	/^V3NtkInput::removePrefixNetName(V3Str2BoolFuncPtr toRemove) {$/;"	f	class:V3NtkInput
removeSelfSubsumed	vrf/v3VrfCITP.cpp	/^V3CITPFrame::removeSelfSubsumed() {$/;"	f	class:V3CITPFrame
removeSelfSubsumed	vrf/v3VrfFITP.cpp	/^V3FITPFrame::removeSelfSubsumed() {$/;"	f	class:V3FITPFrame
removeSelfSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSelfSubsumed() {$/;"	f	class:V3IPDRFrame
removeSelfSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSelfSubsumed() {$/;"	f	class:V3MPDRFrame
removeSubsumed	vrf/v3VrfCITP.cpp	/^V3CITPFrame::removeSubsumed(const V3CITPCube* const cube, const V3CITPCubeList::const_iterator& ix) {$/;"	f	class:V3CITPFrame
removeSubsumed	vrf/v3VrfFITP.cpp	/^V3FITPFrame::removeSubsumed(const V3FITPCube* const cube, const V3FITPCubeList::const_iterator& ix) {$/;"	f	class:V3FITPFrame
removeSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSubsumed(const V3IPDRCube* const cube) {$/;"	f	class:V3IPDRFrame
removeSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSubsumed(const V3IPDRCube* const cube, const V3IPDRCubeList::const_iterator& ix) {$/;"	f	class:V3IPDRFrame
removeSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSubsumed(const V3MPDRCube* const cube) {$/;"	f	class:V3MPDRFrame
removeSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSubsumed(const V3MPDRCube* const cube, const V3MPDRCubeList::const_iterator& ix) {$/;"	f	class:V3MPDRFrame
removeWatch	pdr/SolverV.cpp	/^void removeWatch(vec<Clause*>& ws, Clause* elem)$/;"	f
renderConnection	adt/v3Graph.h	/^V3Graph<T>::renderConnection(const uint32_t& f, const uint32_t& t) {$/;"	f	class:V3Graph
renderFreeNetAsInput	ntk/v3NtkInput.cpp	/^V3NtkInput::renderFreeNetAsInput() {$/;"	f	class:V3NtkInput
reorderPropertyByCOI	v3mc/v3MCReorder.cpp	/^void reorderPropertyByCOI(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
reorderPropertyByNetId	v3mc/v3MCReorder.cpp	/^void reorderPropertyByNetId(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
reorderPropertyByNetLevel	v3mc/v3MCReorder.cpp	/^void reorderPropertyByNetLevel(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
replaceFanin	ntk/v3Ntk.cpp	/^V3Ntk::replaceFanin(const V3RepIdHash& repIdHash) {$/;"	f	class:V3Ntk
replaceInsert	bdd/myHash.h	/^   bool replaceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
replaceOutput	ntk/v3Ntk.cpp	/^V3Ntk::replaceOutput(const uint32_t& index, const V3NetId& id) {$/;"	f	class:V3Ntk
replaceSECNetwork	vrf/v3VrfSEC.cpp	/^V3VrfSEC::replaceSECNetwork(V3RepIdHash& repIdHash) {$/;"	f	class:V3VrfSEC
replaceSECOutput	vrf/v3VrfSEC.cpp	/^V3VrfSEC::replaceSECOutput(const uint32_t& x) {$/;"	f	class:V3VrfSEC
replaceV3Ntk	ntk/v3NtkConstruct.cpp	/^const bool replaceV3Ntk(V3Ntk* const ntk1, V3Ntk* const ntk2) {$/;"	f
report	util/v3Usage.h	/^      void report(const bool& repTime, const bool& repMem) {$/;"	f	class:V3Usage
reportAigerCex	v3mc/v3MCReport.cpp	/^void reportAigerCex(const uint32_t& inputSize, const uint32_t& latchSize, const V3CexTrace& cex, const string& prefix) {$/;"	f
reportAigerInv	v3mc/v3MCReport.cpp	/^void reportAigerInv(const uint32_t& inputSize, const uint32_t& latchSize, const string& prefix) {$/;"	f
reportCex	itp/satMgr.cpp	/^void SatProofRes::reportCex(const V3NetId& monitor, const V3Ntk* const ntk) const {$/;"	f	class:SatProofRes
reportCombinationalLoops	ntk/v3NtkConstruct.cpp	/^const bool reportCombinationalLoops(V3Ntk* const ntk, const V3NetId& id, const V3UI32Vec levelData, V3Vec<V3PairType>::Vec& netLoop) {$/;"	f
reportCombinationalLoops	ntk/v3NtkConstruct.cpp	/^const uint32_t reportCombinationalLoops(V3Ntk* const ntk) {$/;"	f
reportIncompatibleModule	ntk/v3NtkConstruct.cpp	/^const bool reportIncompatibleModule(V3Ntk* const ntk, const V3NetVec& inputs, const V3NetVec& outputs, $/;"	f
reportIncompatibleModule	ntk/v3NtkConstruct.cpp	/^const bool reportIncompatibleModule(V3NtkHandler* const handler1, V3NtkHandler* const handler2) {$/;"	f
reportInconsistentRefNtk	ntk/v3NtkConstruct.cpp	/^const bool reportInconsistentRefNtk(V3Ntk* const ntk) {$/;"	f
reportInvertingNet	ntk/v3Ntk.cpp	/^V3Ntk::reportInvertingNet(const V3NetId& id) const {$/;"	f	class:V3Ntk
reportMultipleDrivenNet	ntk/v3Ntk.cpp	/^V3Ntk::reportMultipleDrivenNet(const V3GateType& type, const V3NetId& id) const {$/;"	f	class:V3Ntk
reportNetWidthInconsistency	ntk/v3Ntk.cpp	/^V3Ntk::reportNetWidthInconsistency(const V3NetId& id1, const V3NetId& id2, const string& s) const {$/;"	f	class:V3Ntk
reportON	vrf/v3VrfBase.h	/^      static inline const bool reportON()  { return (1ul & _extVerbosity); }$/;"	f	class:V3VrfBase
reportResult	itp/satMgr.cpp	/^void SatProofRes::reportResult(const string& name) const {$/;"	f	class:SatProofRes
reportShorterTrace	vrf/v3VrfResult.cpp	/^void reportShorterTrace(const uint32_t& cycle, const char& value) {$/;"	f
reportUnexpectedFaninSize	ntk/v3Ntk.cpp	/^V3Ntk::reportUnexpectedFaninSize(const V3GateType& type, const V3NetId& id) const {$/;"	f	class:V3Ntk
reportUnexpectedNetWidth	ntk/v3Ntk.cpp	/^V3Ntk::reportUnexpectedNetWidth(const V3NetId& id, const uint32_t& width, const string& s) const {$/;"	f	class:V3Ntk
reportUnexpectedState	vrf/v3VrfResult.cpp	/^void reportUnexpectedState(const uint32_t& cycle, const uint32_t& index, const V3BitVecX& v1, const V3BitVecX& v2) {$/;"	f
reportUnsatisfiedConstraint	vrf/v3VrfResult.cpp	/^void reportUnsatisfiedConstraint(const uint32_t& cycle, const uint32_t& index, const V3BitVecX& v) {$/;"	f
reportUnsupportedInitialState	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::reportUnsupportedInitialState() {$/;"	f	class:V3VrfIPDR
reportUnsupportedInitialState	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::reportUnsupportedInitialState() {$/;"	f	class:V3VrfMPDR
reportf	pdr/SolverV.h	28;"	d
reserveFormula	itp/sat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar()); }$/;"	f	class:SatSolver
reserveFormula	pdr/v3SvrPDRSat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar(1)); }$/;"	f	class:V3SvrPDRSat
reserveFormula	svr/v3SvrBase.cpp	/^V3SvrBase::reserveFormula() {$/;"	f	class:V3SvrBase
reserveFormula	svr/v3SvrBoolector.h	/^      inline const size_t reserveFormula() { return getPosExp(boolector_var(_Solver, 1, NULL)); }$/;"	f	class:V3SvrBoolector
reserveFormula	svr/v3SvrMiniSat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar(1)); }$/;"	f	class:V3SvrMiniSat
reset	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::reset(const V3NetVec& targetNets) {$/;"	f	class:V3AlgAigSimulate
reset	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::reset(const V3NetVec& targetNets) {$/;"	f	class:V3AlgBvSimulate
reset	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::reset(const V3NetVec& targetNets) { resetSimulator(); }$/;"	f	class:V3AlgSimulate
reset	bdd/bddMgrV.cpp	/^BddMgrV::reset()$/;"	f	class:BddMgrV
reset	bdd/myHash.h	/^   void reset() { _size = 0; if (_cache) { delete [] _cache; _cache = 0; } }$/;"	f	class:Cache
reset	bdd/myHash.h	/^   void reset() {$/;"	f	class:Hash
reset	itp/sat.cpp	/^void SatSolver::reset()$/;"	f	class:SatSolver
reset	itp/satMgr.cpp	/^void SATMgr::reset() {$/;"	f	class:SATMgr
reset	pdr/pdrMgr.cpp	/^void PDRMgr::reset() {$/;"	f	class:PDRMgr
reset	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::reset() {$/;"	f	class:V3SvrPDRSat
reset	svr/v3SvrBase.cpp	/^V3SvrBase::reset() {$/;"	f	class:V3SvrBase
reset	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::reset() {$/;"	f	class:V3SvrBoolector
reset	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::reset() {$/;"	f	class:V3SvrMiniSat
reset	util/v3Usage.h	/^      void reset() {$/;"	f	class:V3Usage
resetAuxRenaming	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetAuxRenaming() {$/;"	f	class:V3NtkHandler
resetNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetNetName(const uint32_t& index, const string& name) {$/;"	f	class:V3NtkHandler
resetNetWidth	ntk/v3Ntk.cpp	/^V3BvNtk::resetNetWidth(const V3NetId& id, const uint32_t& width) {$/;"	f	class:V3BvNtk
resetOutName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetOutName(const uint32_t& index, const string& name) {$/;"	f	class:V3NtkHandler
resetProof	bdd/bddMgrV.h	/^   void resetProof() {}$/;"	f	class:BddMgrV
resetReportSettings	vrf/v3VrfBase.h	/^      static inline void resetReportSettings() { setReport(1); setUsage(1); }$/;"	f	class:V3VrfBase
resetSimulator	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::resetSimulator() {$/;"	f	class:V3AlgSimulate
resetSolverSettings	vrf/v3VrfBase.h	/^      static inline void resetSolverSettings() { _extSolverType = V3_SVR_MINISAT; }$/;"	f	class:V3VrfBase
resetVerbositySettings	ntk/v3NtkHandler.h	/^      static inline void resetVerbositySettings() { _extVerbosity = 0; setReduce(1); setP2CMap(1); setC2PMap(1); }$/;"	f	class:V3NtkHandler
resize	adt/v3BitVec.cpp	/^V3BitVec::resize(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVec
resize	adt/v3BitVec.cpp	/^V3BitVecX::resize(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVecX
resizeNtkData	itp/sat.cpp	/^void SatSolver::resizeNtkData(const uint32_t& num)$/;"	f	class:SatSolver
resizeNtkData	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::resizeNtkData(const uint32_t& num) {$/;"	f	class:V3SvrPDRSat
resolve	pdr/ProofV.cpp	/^void Proof::resolve(ClauseId next, Var x)$/;"	f	class:Proof
resolveInitial	vrf/v3VrfCITP.cpp	/^V3VrfCITP::resolveInitial(V3CITPCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfCITP
resolveInitial	vrf/v3VrfFITP.cpp	/^V3VrfFITP::resolveInitial(V3FITPCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfFITP
resolveInitial	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::resolveInitial(const uint32_t& d, V3IPDRCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfIPDR
resolveInitial	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::resolveInitial(V3MPDRCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfMPDR
restart	bdd/bddMgrV.cpp	/^BddMgrV::restart()$/;"	f	class:BddMgrV
restrict0	adt/v3BitVec.cpp	/^V3BitVecX::restrict0() {$/;"	f	class:V3BitVecX
retrieveProof	itp/satMgr.cpp	/^void SATMgr::retrieveProof( Reader& rdr, vector<Clause>& unsatCore) const {$/;"	f	class:SATMgr
retrieveProof	itp/satMgr.cpp	/^void SATMgr::retrieveProof( Reader& rdr, vector<unsigned int>& clausePos, vector<ClauseId>& usedClause) const {$/;"	f	class:SATMgr
rewriteAigGate	ntk/v3NtkRewrite.cpp	/^const bool rewriteAigGate(V3AigNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewriteBvGate	ntk/v3NtkRewrite.cpp	/^const bool rewriteBvGate(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewriteGetExpr	ntk/v3NtkRewrite.cpp	/^inline const string rewriteGetExpr(const string& width, const string& value) { return width + "'b" + value; }$/;"	f
rewriteON	ntk/v3NtkHandler.h	/^      static inline const bool rewriteON() { return _extVerbosity & 4ul;  }$/;"	f	class:V3NtkHandler
rewriteReturnAigNode	ntk/v3NtkRewrite.cpp	/^const V3NetId rewriteReturnAigNode(V3AigNtk* const ntk, V3PortableType& netHash, const bool& cpId, const V3NetType& in1, const V3NetType& in2) {$/;"	f
rewriteReturnConst	ntk/v3NtkRewrite.cpp	/^const bool rewriteReturnConst(V3BvNtk* const ntk, V3GateType& type, V3PortableType& netHash, const bool& cpId, V3InputVec& inputs, const string& expr) {$/;"	f
rewriteReturnNetId	ntk/v3NtkRewrite.cpp	/^const V3NetId rewriteReturnNetId(V3BvNtk* const ntk, const V3GateType& type, V3PortableType& netHash, const bool& cpId, const V3NetType& in1, const V3NetType& in2 = V3NetUD, const V3NetType& in3 = V3NetUD) {$/;"	f
rewriteReturnTerminal	ntk/v3NtkRewrite.cpp	/^const bool rewriteReturnTerminal(V3Ntk* const ntk, V3GateType& type, V3InputVec& inputs, const V3NetId& id, const bool& cpId) {$/;"	f
rewriteSwapNets	ntk/v3NtkRewrite.cpp	/^inline void rewriteSwapNets(V3NetType& in1, V3NetType& in2) { const V3NetType in = in1; in1 = in2; in2 = in; }$/;"	f
rewrite_ADD	ntk/v3NtkRewrite.cpp	/^const bool rewrite_ADD(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_AIG_NODE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_AIG_NODE(V3AigNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_AND	ntk/v3NtkRewrite.cpp	/^const bool rewrite_AND(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_CONST	ntk/v3NtkRewrite.cpp	/^const bool rewrite_CONST(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_DIV	ntk/v3NtkRewrite.cpp	/^const bool rewrite_DIV(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_EQUALITY	ntk/v3NtkRewrite.cpp	/^const bool rewrite_EQUALITY(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_GEQ	ntk/v3NtkRewrite.cpp	/^const bool rewrite_GEQ(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MERGE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MERGE(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MODULO	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MODULO(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MULT	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MULT(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MUX	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MUX(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_AND	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_AND(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_OR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_OR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_XOR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_XOR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SHL	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SHL(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SHR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SHR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SLICE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SLICE(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SUB	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SUB(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_XOR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_XOR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
right	pdr/HeapV.h	/^static inline int right (int i) { return i+i + 1; }$/;"	f
root	pdr/ProofV.h	/^    virtual void root   (const vec<Lit>& c) {}$/;"	f	struct:ProofTraverser
root_cla_count	pdr/SolverV.h	/^   int      root_cla_count;$/;"	m	class:SolverV
root_level	pdr/SolverV.h	/^    int                 root_level;       \/\/ Level of first proper decision.$/;"	m	class:SolverV
runPCheckProperty	prove/proveBdd.cpp	/^BddMgrV::runPCheckProperty( const string &name, BddNodeV monitor )$/;"	f	class:BddMgrV
satMgr	itp/satCmd.cpp	/^static SATMgr* satMgr = new SATMgr();$/;"	v	file:
save	pdr/ProofV.cpp	/^bool Proof::save(cchar* filename)$/;"	f	class:Proof
search	pdr/SolverV.cpp	/^lbool SolverV::search(int nof_conflicts, int nof_learnts, const SearchParams& params)$/;"	f	class:SolverV
seek	itp/reader.cpp	/^void Reader::seek( const unsigned int to ){$/;"	f	class:Reader
seek	pdr/FileV.cpp	/^void File::seek(int64 file_pos, int whence)$/;"	f	class:File
seek	pdr/reader.cpp	/^void Reader::seek( const unsigned int to ){$/;"	f	class:Reader
select	pdr/VarOrderV.h	/^Var VarOrder::select(double random_var_freq)$/;"	f	class:VarOrder
select	trans/v3BvBlastAigHelper.h	/^inline const V3NetId select(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& s)$/;"	f
selectionSort	pdr/SortV.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	pdr/SortV.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
set	adt/v3BitVec.cpp	/^V3BitVec::set(const char* exp) {$/;"	f	class:V3BitVec
set	adt/v3BitVec.cpp	/^V3BitVec::set(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVec
set	adt/v3BitVec.cpp	/^V3BitVecX::set(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVecX
set0	adt/v3BitVec.cpp	/^V3BitVec::set0(const unsigned& i) {$/;"	f	class:V3BitVec
set0	adt/v3BitVec.cpp	/^V3BitVecX::set0(const unsigned& i) {$/;"	f	class:V3BitVecX
set0	adt/v3BitVec.h	/^      inline void set0(const unsigned& i) { _data0 |= (1ul << i); _data1 &= ~(1ul << i); }$/;"	f	class:V3BitVecS
set1	adt/v3BitVec.cpp	/^V3BitVec::set1(const unsigned& i) {$/;"	f	class:V3BitVec
set1	adt/v3BitVec.cpp	/^V3BitVecX::set1(const unsigned& i) {$/;"	f	class:V3BitVecX
set1	adt/v3BitVec.h	/^      inline void set1(const unsigned& i) { _data0 &= ~(1ul << i); _data1 |= (1ul << i); }$/;"	f	class:V3BitVecS
setActivator	vrf/v3VrfMPDR.h	/^      inline void setActivator(const V3SvrData& act) { _activator = act; }$/;"	f	class:V3MPDRFrame
setAllOutFile	util/v3Msg.h	/^      void setAllOutFile(const string filename) { V3Msg::_allName = filename; }$/;"	f	class:V3MsgMgr
setAssumeCECMiter	vrf/v3VrfSEC.h	/^      inline void setAssumeCECMiter() { _secCECAssumed = 1; }$/;"	f	class:V3VrfSEC
setAssumeSECMiter	vrf/v3VrfSEC.h	/^      inline void setAssumeSECMiter() { _secSECAssumed = 1; }$/;"	f	class:V3VrfSEC
setAuxRenaming	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setAuxRenaming() {$/;"	f	class:V3NtkHandler
setBaseHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setBaseHandler() {$/;"	f	class:V3Handler
setBddMgrV	bdd/bddNodeV.h	/^   static void setBddMgrV(BddMgrV* m) { _BddMgrV = m; }$/;"	f	class:BddNodeV
setBddOrder	bdd/bddCmd.cpp	/^bool                       setBddOrder = false;$/;"	v
setBddOrder	ntk/v3NtkBdd.cpp	/^const bool V3Ntk::setBddOrder(V3NtkHandler* const handler, const bool& file) const {$/;"	f	class:V3Ntk
setBlockBadCount	vrf/v3VrfCITP.h	/^      inline void setBlockBadCount(const uint32_t& m = V3NtkUD) { _itpBadCount = m; }$/;"	f	class:V3VrfCITP
setBlockBadCount	vrf/v3VrfFITP.h	/^      inline void setBlockBadCount(const uint32_t& m = V3NtkUD) { _itpBadCount = m; }$/;"	f	class:V3VrfFITP
setBlockBadCountIndep	vrf/v3VrfCITP.h	/^      inline void setBlockBadCountIndep (const bool& f) { if (f) _itpAttr |= 4ul;  else _itpAttr &= ~4ul;  }$/;"	f	class:V3VrfCITP
setBlockBadCountIndep	vrf/v3VrfFITP.h	/^      inline void setBlockBadCountIndep (const bool& f) { if (f) _itpAttr |= 4ul;  else _itpAttr &= ~4ul;  }$/;"	f	class:V3VrfFITP
setBlockingStruct	vrf/v3VrfCITP.cpp	/^V3VrfCITP::setBlockingStruct(const V3NetVec& baseCube) {$/;"	f	class:V3VrfCITP
setBlockingStruct	vrf/v3VrfCITP.cpp	/^V3VrfCITP::setBlockingStruct(const V3NetVec& baseCube, const V3UI32Vec& blockIndex) {$/;"	f	class:V3VrfCITP
setBlockingStruct	vrf/v3VrfFITP.cpp	/^V3VrfFITP::setBlockingStruct(const V3NetVec& baseCube) {$/;"	f	class:V3VrfFITP
setBlockingStruct	vrf/v3VrfFITP.cpp	/^V3VrfFITP::setBlockingStruct(const V3NetVec& baseCube, const V3UI32Vec& blockIndex) {$/;"	f	class:V3VrfFITP
setBounds	pdr/HeapV.h	/^    void setBounds (int size) { assert(size >= 0); indices.growTo(size,0); }$/;"	f	class:Heap
setC2PMap	ntk/v3NtkHandler.h	/^      static inline void setC2PMap (const bool& t) { if (t) _extVerbosity |= 16ul; else _extVerbosity &= ~16ul; }$/;"	f	class:V3NtkHandler
setCexTrace	ext/v3Property.h	/^      inline void setCexTrace(V3CexTrace* const cex) {$/;"	f	class:V3VrfResult
setChecker	vrf/v3VrfKLive.h	/^      inline void setChecker(V3VrfBase* const c) { _klChecker = c; }$/;"	f	class:V3VrfKLive
setChecker	vrf/v3VrfSEC.h	/^      inline void setChecker(V3VrfBase* const c) { _secChecker = c; }$/;"	f	class:V3VrfSEC
setCmdLen	cmd/v3CmdMgr.h	/^      inline void setCmdLen(unsigned n) { _cmdLen = n; }$/;"	f	class:V3CmdExec
setConstraint	vrf/v3VrfBase.cpp	/^V3VrfBase::setConstraint(const V3NetVec& constrList, const uint32_t& p) {$/;"	f	class:V3VrfBase
setConstructStandardFSM	stg/v3StgFSM.h	/^      inline void setConstructStandardFSM(const bool& e) { if (e) _configs |= 8ul; else _configs &= ~8ul; }$/;"	f	class:V3FSMSDGDB
setCurHandlerFromId	ntk/v3NtkHandler.cpp	/^V3Handler::setCurHandlerFromId(const uint32_t& ntkId) {$/;"	f	class:V3Handler
setCurHandlerFromPath	ntk/v3NtkHandler.cpp	/^V3Handler::setCurHandlerFromPath(const string& path) {$/;"	f	class:V3Handler
setCutSignals	ntk/v3Ntk.h	/^      inline void setCutSignals(const V3NetVec& cut) { _cutSignals = cut; }$/;"	f	class:V3Ntk
setDefaultSolver	vrf/v3VrfBase.h	/^      static inline void setDefaultSolver(const V3SolverType& type) { _extSolverType = type; }$/;"	f	class:V3VrfBase
setDynamicInc	vrf/v3VrfUMC.h	/^      inline void setDynamicInc(const bool& d) { if (d) _umcAttr |= 8ul; else _umcAttr &= ~8ul; }$/;"	f	class:V3VrfUMC
setEarlySuspended	stg/v3StgFSM.h	/^      inline void setEarlySuspended() { _configs |= 128ul; }$/;"	f	class:V3FSM
setEarlySuspended	stg/v3StgFSM.h	/^      inline void setEarlySuspended() { _configs |= 128ul; }$/;"	f	class:V3FSMSDGDB
setEndline	vrf/v3VrfBase.h	/^      static inline void setEndline(const bool& t) { if (t) _extVerbosity |= 4ul;  else _extVerbosity &= ~4ul;  }$/;"	f	class:V3VrfBase
setExternalVerbosity	ntk/v3NtkHandler.h	/^      static inline void setExternalVerbosity() { _intVerbosity = _extVerbosity; }$/;"	f	class:V3NtkHandler
setFSM	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setFSM(const string& fsmName, V3FSMExtract* const fsmList) {$/;"	f	class:V3NtkHandler
setFairConstr	ext/v3Property.cpp	/^V3Property::setFairConstr(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setFairConstr	ext/v3Property.cpp	/^V3Property::setFairConstr(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setFalseEmptyButExist	stg/v3StgFSM.h	/^      inline void setFalseEmptyButExist() { assert (!_falseSize); _falseSize = 1; }$/;"	f	class:V3FSMSDG
setFireOnly	vrf/v3VrfUMC.h	/^      inline void setFireOnly  (const bool& f) { if (f) _umcAttr |= 1ul; else _umcAttr &= ~1ul; }$/;"	f	class:V3VrfUMC
setFired	itp/satMgr.h	/^    void setFired(uint32_t i) { _fired = i; }$/;"	f	class:SatProofRes
setFired	pdr/pdrMgr.h	/^    void setFired(uint32_t i) { _fired = i; }$/;"	f	class:SatProofRes
setForceUnreachable	vrf/v3VrfCITP.h	/^      inline void setForceUnreachable   (const bool& f) { if (f) _itpAttr |= 2ul;  else _itpAttr &= ~2ul;  }$/;"	f	class:V3VrfCITP
setForceUnreachable	vrf/v3VrfFITP.h	/^      inline void setForceUnreachable   (const bool& f) { if (f) _itpAttr |= 2ul;  else _itpAttr &= ~2ul;  }$/;"	f	class:V3VrfFITP
setForwardSATGen	vrf/v3VrfIPDR.h	/^      inline void setForwardSATGen  (const bool& s) { if (s) _pdrAttr |= 1ul; else _pdrAttr &= ~1ul; }$/;"	f	class:V3VrfIPDR
setForwardSATGen	vrf/v3VrfMPDR.h	/^      inline void setForwardSATGen  (const bool& s) { if (s) _pdrAttr |= 1ul; else _pdrAttr &= ~1ul; }$/;"	f	class:V3VrfMPDR
setForwardUNSATGen	vrf/v3VrfIPDR.h	/^      inline void setForwardUNSATGen(const bool& u) { if (u) _pdrAttr |= 2ul; else _pdrAttr &= ~2ul; }$/;"	f	class:V3VrfIPDR
setForwardUNSATGen	vrf/v3VrfMPDR.h	/^      inline void setForwardUNSATGen(const bool& u) { if (u) _pdrAttr |= 2ul; else _pdrAttr &= ~2ul; }$/;"	f	class:V3VrfMPDR
setFrame	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::setFrame(vector<vector<Cube*>*>* f) {$/;"	f	class:V3SvrPDRSat
setImplyInit	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::setImplyInit() {$/;"	f	class:V3SvrPDRSat
setImplyInit	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyInit() {$/;"	f	class:V3SvrBase
setImplyInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyInit() {$/;"	f	class:V3SvrBoolector
setImplyInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyInit() {$/;"	f	class:V3SvrMiniSat
setImplyIntersection	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::setImplyIntersection(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrPDRSat
setImplyIntersection	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyIntersection(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
setImplyIntersection	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyIntersection(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
setImplyIntersection	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyIntersection(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
setImplyUnion	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::setImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrPDRSat
setImplyUnion	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyUnion(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
setImplyUnion	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyUnion(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
setImplyUnion	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
setIncContinueOnLastSolver	vrf/v3VrfBase.h	/^      inline void setIncContinueOnLastSolver(const bool& c) { _incContinueOnLastSolver = c; }$/;"	f	class:V3VrfBase
setIncDepth	vrf/v3VrfBMC.h	/^      inline void setIncDepth(const uint32_t& d) { _incDepth = d; }$/;"	f	class:V3VrfBMC
setIncDepth	vrf/v3VrfKLive.h	/^      inline void setIncDepth(const uint32_t& i) { _incDepth = i; }$/;"	f	class:V3VrfKLive
setIncDepth	vrf/v3VrfUMC.h	/^      inline void setIncDepth(const uint32_t& d) { _incDepth = d; }$/;"	f	class:V3VrfUMC
setIncKeepLastReachability	vrf/v3VrfBase.h	/^      inline void setIncKeepLastReachability(const bool& k) { _incKeepLastReachability = k; }$/;"	f	class:V3VrfBase
setIncKeepSilent	vrf/v3VrfBase.h	/^      inline void setIncKeepSilent          (const bool& s) { _incKeepSilent           = s; }$/;"	f	class:V3VrfBase
setIncLastDepthToKeepGoing	vrf/v3VrfBase.h	/^      inline void setIncLastDepthToKeepGoing(const uint32_t& d) { _incLastDepthToKeepGoing = d; }$/;"	f	class:V3VrfBase
setIncVerifyUsingCurResult	vrf/v3VrfBase.h	/^      inline void setIncVerifyUsingCurResult(const bool& v) { _incVerifyUsingCurResult = v; }$/;"	f	class:V3VrfBase
setIncrementDepth	vrf/v3VrfCITP.h	/^      inline void setIncrementDepth     (const bool& f) { if (f) _itpAttr |= 1ul;  else _itpAttr &= ~1ul;  }$/;"	f	class:V3VrfCITP
setIncrementDepth	vrf/v3VrfFITP.h	/^      inline void setIncrementDepth     (const bool& f) { if (f) _itpAttr |= 1ul;  else _itpAttr &= ~1ul;  }$/;"	f	class:V3VrfFITP
setIndInv	ext/v3Property.h	/^      inline void setIndInv(V3Ntk* const indInv) {$/;"	f	class:V3VrfResult
setInit	ext/v3Property.h	/^      inline void setInit(const V3BitVecX& i) { _init = new V3BitVecX(i); assert (_init); }$/;"	f	class:V3CexTrace
setInput	ntk/v3Ntk.cpp	/^V3Ntk::setInput(const V3NetId& id, const V3InputVec& inputs) {$/;"	f	class:V3Ntk
setInputData	vrf/v3VrfIPDR.h	/^      inline void setInputData(const V3BitVecX& v) { _inputData = v; }$/;"	f	class:V3IPDRCube
setInputData	vrf/v3VrfMPDR.h	/^      inline void setInputData(const V3BitVecX& v) { _inputData = v; }$/;"	f	class:V3MPDRCube
setInternalCEC	vrf/v3VrfSEC.h	/^      inline void setInternalCEC() { assert (isAssumeCECMiter()); _secIsCECorSEC = 0; }$/;"	f	class:V3VrfSEC
setInternalSEC	vrf/v3VrfSEC.h	/^      inline void setInternalSEC() { assert (isAssumeSECMiter()); _secIsCECorSEC = 1; }$/;"	f	class:V3VrfSEC
setInternalVerbosity	ntk/v3NtkHandler.h	/^      static inline void setInternalVerbosity() { _extVerbosity = _intVerbosity; }$/;"	f	class:V3NtkHandler
setInvConstr	ext/v3Property.cpp	/^V3Property::setInvConstr(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setInvConstr	ext/v3Property.cpp	/^V3Property::setInvConstr(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setInvariant	ext/v3Property.cpp	/^V3Property::setInvariant(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setInvariant	ext/v3Property.cpp	/^V3Property::setInvariant(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setInvariantDirectedCluster	stg/v3StgExtract.h	/^      inline void setInvariantDirectedCluster() { assert (!(_configs & 3ul  )); _configs |= 2ul;   }$/;"	f	class:V3FSMExtract
setLastHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setLastHandler() {$/;"	f	class:V3Handler
setLatestMiscData	ntk/v3Ntk.h	/^inline void V3Ntk::setLatestMiscData(const V3NetId& id) {$/;"	f	class:V3Ntk
setList	adt/v3Misc.h	/^      inline void setList(const uint32_t& i, const size_t& t) {$/;"	f	class:V3PortableType
setMandCmd	cmd/v3CmdMgr.h	/^      inline void setMandCmd(const string& str) { _mandCmd.push_back(str);}$/;"	f	class:V3CmdExec
setMaxAllowedStateSize	stg/v3StgFSM.h	/^      inline void setMaxAllowedStateSize(const uint32_t& s) { _maxSize = s; }$/;"	f	class:V3FSMSDGDB
setMaxDepth	itp/satMgr.h	/^    void setMaxDepth(uint32_t d) { _maxDepth = d; }$/;"	f	class:SatProofRes
setMaxDepth	pdr/pdrMgr.h	/^    void setMaxDepth(uint32_t d) { _maxDepth = d; }$/;"	f	class:SatProofRes
setMaxDepth	vrf/v3VrfBase.h	/^      inline void setMaxDepth(const uint32_t& d) { assert (d); _maxDepth = d; }$/;"	f	class:V3VrfBase
setMaxStateSize	stg/v3StgExtract.h	/^      inline void setMaxStateSize(const uint32_t& s) { assert (!_depGraph.getNodeSize()); _maxSize = s; }$/;"	f	class:V3FSMExtract
setMaxTime	vrf/v3VrfBase.h	/^      inline void setMaxTime(const double& t) { assert (t); _maxTime = t; }$/;"	f	class:V3VrfBase
setMaxTimeUsage	stg/v3StgExtract.h	/^      inline void setMaxTimeUsage(const double& t) { assert (t >= 0); _maxTime = t; }$/;"	f	class:V3FSMExtract
setMemUsage	util/v3Usage.h	/^      void setMemUsage() {$/;"	f	class:V3Usage
setMode	pdr/FileV.h	/^    void setMode(FileMode m) {$/;"	f	class:File
setMonitor	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::setMonitor(const V3NetId& m) {$/;"	f	class:V3SvrPDRSat
setNoIncBySharedBound	vrf/v3VrfCITP.h	/^      inline void setNoIncBySharedBound (const bool& d) { if (d) _itpAttr |= 8ul;  else _itpAttr &= ~8ul;  }$/;"	f	class:V3VrfCITP
setNoIncBySharedBound	vrf/v3VrfFITP.h	/^      inline void setNoIncBySharedBound (const bool& d) { if (d) _itpAttr |= 8ul;  else _itpAttr &= ~8ul;  }$/;"	f	class:V3VrfFITP
setNtkName	ntk/v3NtkHandler.h	/^      inline void setNtkName(const string& n) { assert (n.size()); _ntkName = n; }$/;"	f	class:V3NtkHandler
setOmitNodesAllCombVars	stg/v3StgFSM.h	/^      inline void setOmitNodesAllCombVars(const bool& e) { if (e) _configs |= 1ul; else _configs &= ~1ul; }$/;"	f	class:V3FSMSDGDB
setOmitNodesIndepToVars	stg/v3StgFSM.h	/^      inline void setOmitNodesIndepToVars(const bool& e) { if (e) _configs |= 2ul; else _configs &= ~2ul; }$/;"	f	class:V3FSMSDGDB
setOnes	adt/v3BitVec.h	/^      inline void setOnes(const uint64_t& v) { _data1 = v; }$/;"	f	class:V3BitVecS
setOptCmd	cmd/v3CmdMgr.h	/^      inline void setOptCmd(const string& str) { _optCmd.push_back(str); }$/;"	f	class:V3CmdExec
setOutFile	util/v3Msg.h	/^      void setOutFile(const string filename) { _filename = filename; }$/;"	f	class:V3Msg
setOutFile	util/v3Msg.h	/^      void setOutFile(const string filename, const V3MsgType type) { Msgs[type]->setOutFile(filename); }$/;"	f	class:V3MsgMgr
setOutputFile	svr/v3SvrBase.cpp	/^V3SvrBase::setOutputFile(const string fileName) {$/;"	f	class:V3SvrBase
setP2CMap	ntk/v3NtkHandler.h	/^      static inline void setP2CMap (const bool& t) { if (t) _extVerbosity |=  8ul; else _extVerbosity &= ~8ul;  }$/;"	f	class:V3NtkHandler
setPreDepth	vrf/v3VrfBMC.h	/^      inline void setPreDepth(const uint32_t& d) { _preDepth = d; }$/;"	f	class:V3VrfBMC
setPreDepth	vrf/v3VrfUMC.h	/^      inline void setPreDepth(const uint32_t& d) { _preDepth = d; }$/;"	f	class:V3VrfUMC
setPrevHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setPrevHandler() {$/;"	f	class:V3Handler
setProfile	vrf/v3VrfBase.h	/^      static inline void setProfile(const bool& t) { if (t) _extVerbosity |= 32ul; else _extVerbosity &= ~32ul; }$/;"	f	class:V3VrfBase
setPrompt	cmd/v3CmdMgr.h	/^      inline void setPrompt() { _prompt = _defaultPrompt + "> "; }$/;"	f	class:V3CmdMgr
setProperty	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setProperty(V3Property* const p) {$/;"	f	class:V3NtkHandler
setProveOnly	vrf/v3VrfUMC.h	/^      inline void setProveOnly (const bool& p) { if (p) _umcAttr |= 2ul; else _umcAttr &= ~2ul; }$/;"	f	class:V3VrfUMC
setProved	itp/satMgr.h	/^    void setProved(uint32_t i) { _proved = i; }$/;"	f	class:SatProofRes
setProved	pdr/pdrMgr.h	/^    void setProved(uint32_t i) { _proved = i; }$/;"	f	class:SatProofRes
setQuteLogFile	io/v3NtkQuteRTL.cpp	/^void setQuteLogFile() {$/;"	f
setRecycle	vrf/v3VrfIPDR.h	/^      inline void setRecycle(const uint32_t& r) { _pdrRecycle = r; }$/;"	f	class:V3VrfIPDR
setRecycle	vrf/v3VrfMPDR.h	/^      inline void setRecycle(const uint32_t& r) { _pdrRecycle = r; }$/;"	f	class:V3VrfMPDR
setRecycleInterpolants	vrf/v3VrfCITP.h	/^      inline void setRecycleInterpolants(const bool& f) { if (f) _itpAttr |= 16ul; else _itpAttr &= ~16ul; }$/;"	f	class:V3VrfCITP
setRecycleInterpolants	vrf/v3VrfFITP.h	/^      inline void setRecycleInterpolants(const bool& f) { if (f) _itpAttr |= 16ul; else _itpAttr &= ~16ul; }$/;"	f	class:V3VrfFITP
setReduce	ntk/v3NtkHandler.h	/^      static inline void setReduce (const bool& t) { if (t) _extVerbosity |=  1ul; else _extVerbosity &= ~1ul;  }$/;"	f	class:V3NtkHandler
setRenderNonEmptyStates	stg/v3StgFSM.h	/^      inline void setRenderNonEmptyStates(const bool& e) { if (e) _configs |= 4ul; else _configs &= ~4ul; }$/;"	f	class:V3FSMSDGDB
setReport	vrf/v3VrfBase.h	/^      static inline void setReport (const bool& t) { if (t) _extVerbosity |= 1ul;  else _extVerbosity &= ~1ul;  }$/;"	f	class:V3VrfBase
setResult	ext/v3Property.cpp	/^V3Property::setResult(const V3VrfResult& r) {$/;"	f	class:V3Property
setRewrite	ntk/v3NtkHandler.h	/^      static inline void setRewrite(const bool& t) { if (t) _extVerbosity |=  4ul; else _extVerbosity &= ~4ul;  }$/;"	f	class:V3NtkHandler
setRewriteLevel	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setRewriteLevel(const int& rwl) {$/;"	f	class:V3SvrBoolector
setRootHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setRootHandler() {$/;"	f	class:V3Handler
setRstOnly	vrf/v3VrfBase.h	/^      static inline void setRstOnly(const bool& t) { if (t) _extVerbosity |= 2ul;  else _extVerbosity &= ~2ul;  }$/;"	f	class:V3VrfBase
setSatSolver	itp/satMgr.h	/^    void setSatSolver(SatSolver* s) { _satSolver = s; }$/;"	f	class:SatProofRes
setSatSolver	pdr/pdrMgr.h	/^    void setSatSolver(V3SvrPDRSat* s) { _satSolver = s; }$/;"	f	class:SatProofRes
setSharedBound	vrf/v3VrfBase.h	/^      inline void setSharedBound(V3VrfSharedBound* const s) { _sharedBound = s; }$/;"	f	class:V3VrfBase
setSharedInv	vrf/v3VrfBase.h	/^      inline void setSharedInv(V3VrfSharedInv* const i) { _sharedInv = i; }$/;"	f	class:V3VrfBase
setSharedMem	vrf/v3VrfBase.h	/^      inline void setSharedMem(V3VrfSharedMem* const m) { _sharedMem = m; }$/;"	f	class:V3VrfBase
setSharedNtk	vrf/v3VrfBase.h	/^      inline void setSharedNtk(V3VrfSharedNtk* const n) { _sharedNtk = n; }$/;"	f	class:V3VrfBase
setSolver	vrf/v3VrfBase.h	/^      inline void setSolver(const V3SolverType& s) { assert (V3_SVR_TOTAL > s); _solverType = s; }$/;"	f	class:V3VrfBase
setSolver	vrf/v3VrfBase.h	/^      static inline void setSolver (const bool& t) { if (t) _extVerbosity |= 8ul;  else _extVerbosity &= ~8ul;  }$/;"	f	class:V3VrfBase
setSource	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgAigSimulate
setSource	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgBvSimulate
setSource	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {}$/;"	f	class:V3AlgSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgAigSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgBvSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {}$/;"	f	class:V3AlgSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceFree(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgAigSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceFree(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgBvSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceFree(const V3GateType& type, const bool& random) {}$/;"	f	class:V3AlgSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgAigSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgBvSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {}$/;"	f	class:V3AlgSimulate
setState	dfx/v3DfxTrace.h	/^inline void V3DfxCube::setState(const V3NetVec& v) {$/;"	f	class:V3DfxCube
setState	vrf/v3VrfCITP.h	/^inline void V3CITPCube::setState(const V3NetVec& v) {$/;"	f	class:V3CITPCube
setState	vrf/v3VrfFITP.h	/^inline void V3FITPCube::setState(const V3NetVec& v) {$/;"	f	class:V3FITPCube
setState	vrf/v3VrfIPDR.h	/^inline void V3IPDRCube::setState(const V3NetVec& v) {$/;"	f	class:V3IPDRCube
setState	vrf/v3VrfMPDR.h	/^inline void V3MPDRCube::setState(const V3NetVec& v) {$/;"	f	class:V3MPDRCube
setStateForSimulation	stg/v3StgFSM.cpp	/^V3FSM::setStateForSimulation(const V3SimTrace& trace) {$/;"	f	class:V3FSM
setStrash	ntk/v3NtkHandler.h	/^      static inline void setStrash (const bool& t) { if (t) _extVerbosity |=  2ul; else _extVerbosity &= ~2ul;  }$/;"	f	class:V3NtkHandler
setSynthesisMode	vrf/v3VrfSEC.h	/^      inline void setSynthesisMode(const bool& s) { _secSynthesis = s; }$/;"	f	class:V3VrfSEC
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgAigGeneralize
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgBvGeneralize
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgGeneralize
setTargetValue	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrPDRSat
setTargetValue	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrPDRSat
setTargetValue	svr/v3SvrBase.cpp	/^V3SvrBase::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrBase
setTargetValue	svr/v3SvrBase.cpp	/^V3SvrBase::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrBase
setTargetValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrBoolector
setTargetValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrBoolector
setTargetValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrMiniSat
setTargetValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrMiniSat
setTimeUsage	util/v3Usage.h	/^      void setTimeUsage() {$/;"	f	class:V3Usage
setTrueEmptyButExist	stg/v3StgFSM.h	/^      inline void setTrueEmptyButExist() { assert (!_trueSize); _trueSize = 1; }$/;"	f	class:V3FSMSDG
setUniqueness	vrf/v3VrfUMC.h	/^      inline void setUniqueness(const bool& u) { if (u) _umcAttr |= 4ul; else _umcAttr &= ~4ul; }$/;"	f	class:V3VrfUMC
setUsage	vrf/v3VrfBase.h	/^      static inline void setUsage  (const bool& t) { if (t) _extVerbosity |= 16ul; else _extVerbosity &= ~16ul; }$/;"	f	class:V3VrfBase
setVariableClusterBySCC	stg/v3StgExtract.h	/^      inline void setVariableClusterBySCC()     { assert (!(_configs & 3ul  )); _configs |= 1ul;   }$/;"	f	class:V3FSMExtract
setVisited	bdd/bddNodeV.h	/^   void setVisited() { _visited = 1; }$/;"	f	class:BddNodeVInt
setX	adt/v3BitVec.cpp	/^V3BitVecX::setX (const unsigned& i) {$/;"	f	class:V3BitVecX
setX	adt/v3BitVec.h	/^      inline void setX(const unsigned& i) { _data0 &= ~(1ul << i); _data1 &= ~(1ul << i); }$/;"	f	class:V3BitVecS
setZeros	adt/v3BitVec.h	/^      inline void setZeros(const uint64_t& v) { _data0 = v; }$/;"	f	class:V3BitVecS
set_value	adt/v3BitVec.cpp	/^V3BitVecX::set_value(const unsigned& i, const char& v) {$/;"	f	class:V3BitVecX
sh_select	svr/v3SvrSatHelper.h	/^inline void sh_select(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& s)$/;"	f
shortestPath	adt/v3Graph.h	/^V3Graph<T>::shortestPath(const T& node1, const T& node2, V3NodeStack& path) const {$/;"	f	class:V3Graph
show	pdr/PDRDef.h	/^  void show() {$/;"	f	class:Cube
show_address	pdr/PDRDef.h	9;"	d
showinfo	pdr/pdrMgr.cpp	8;"	d	file:
shrink	pdr/GlobalV.h	/^    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
sign	pdr/SolverTypesV.h	/^inline bool sign  (Lit p) { return p.x & 1; }$/;"	f
simpDB_assigns	pdr/SolverV.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplifyDB()'.$/;"	m	class:SolverV
simpDB_props	pdr/SolverV.h	/^    int64               simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplifyDB()'.$/;"	m	class:SolverV
simplify	itp/sat.cpp	/^const bool SatSolver::simplify() { return _solver->simplifyDB(); }$/;"	f	class:SatSolver
simplify	pdr/SolverV.cpp	/^bool SolverV::simplify(Clause* c) const$/;"	f	class:SolverV
simplify	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::simplify() { return _Solver->simplifyDB(); }$/;"	f	class:V3SvrPDRSat
simplify	svr/v3SvrBase.cpp	/^V3SvrBase::simplify() {$/;"	f	class:V3SvrBase
simplify	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::simplify() {$/;"	f	class:V3SvrBoolector
simplify	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::simplify() { return _Solver->simplify(); }$/;"	f	class:V3SvrMiniSat
simplifyDB	pdr/SolverV.cpp	/^bool SolverV::simplifyDB()$/;"	f	class:SolverV
simplifyInputPatterns	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::simplifyInputPatterns(const bool& minTrans, const uint32_t& partition) {$/;"	f	class:V3TraceSimplify
simplifyNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::simplifyNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
simplifySECNetwork	vrf/v3VrfSEC.cpp	/^V3VrfSEC::simplifySECNetwork(V3NetVec& p2cMap, V3NetVec& c2pMap, const V3NetVec& eqNets) {$/;"	f	class:V3VrfSEC
simulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::simulate() {$/;"	f	class:V3AlgAigSimulate
simulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulate() {$/;"	f	class:V3AlgBvSimulate
simulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::simulate() {}$/;"	f	class:V3AlgSimulate
simulateEventList	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::simulateEventList() {$/;"	f	class:V3AlgAigSimulate
simulateEventList	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulateEventList() {$/;"	f	class:V3AlgBvSimulate
simulateForForwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::simulateForForwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecS& generalizeValue) {$/;"	f	class:V3AlgAigGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecS& generalizeValue, $/;"	f	class:V3AlgAigGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecX& generalizeValue) {$/;"	f	class:V3AlgBvGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecX& generalizeValue, $/;"	f	class:V3AlgBvGeneralize
simulateGate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulateGate(const V3NetId& id) {$/;"	f	class:V3AlgBvSimulate
simulationCheckFiredResult	vrf/v3VrfResult.cpp	/^const int simulationCheckFiredResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
size	adt/v3BitVec.h	/^      inline const unsigned size() const { return _size; }$/;"	f	class:V3BitVec
size	adt/v3BitVec.h	/^      inline const unsigned size() const { return _size; }$/;"	f	class:V3BitVecX
size	adt/v3Bucket.h	/^      inline const uint32_t size() const { return _size; }$/;"	f	class:V3BucketList
size	adt/v3Bucket.h	/^      inline const uint32_t size() const { return _size; }$/;"	f	class:V3IncBucketList
size	bdd/myHash.h	/^   size_t size() const { return _size; }$/;"	f	class:Cache
size	bdd/myHash.h	/^   size_t size() const {$/;"	f	class:Hash
size	itp/reader.h	/^	unsigned int 	size;$/;"	m	class:Reader
size	pdr/FileV.h	/^    int         size;       \/\/ Size of buffer (at end of file, less than 'File_BufSize').$/;"	m	class:File
size	pdr/GlobalV.h	/^    int      size   (void) const       { return sz; }$/;"	f	class:vec
size	pdr/SolverTypesV.h	/^    int       size        ()      const { return size_learnt >> 1; }$/;"	f	class:Clause
size	pdr/reader.h	/^	unsigned int 	size;$/;"	m	class:Reader
size_learnt	pdr/SolverTypesV.h	/^    uint    size_learnt;$/;"	m	class:Clause
solve	itp/sat.cpp	/^const bool SatSolver::solve()$/;"	f	class:SatSolver
solve	pdr/SolverV.cpp	/^bool SolverV::solve(const vec<Lit>& assumps)$/;"	f	class:SolverV
solve	pdr/SolverV.h	/^    bool    solve() { vec<Lit> tmp; return solve(tmp); }$/;"	f	class:SolverV
solve	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::solve() {$/;"	f	class:V3SvrPDRSat
solve	svr/v3SvrBase.cpp	/^V3SvrBase::solve() {$/;"	f	class:V3SvrBase
solve	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::solve() {$/;"	f	class:V3SvrBoolector
solve	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::solve() {$/;"	f	class:V3SvrMiniSat
solveLimited	pdr/SolverV.cpp	/^lbool SolverV::solveLimited(const vec<Lit>& assumps, int64_t nConflicts)$/;"	f	class:SolverV
solveLimited	pdr/SolverV.h	/^    lbool   solveLimited(int64_t nConflicts) { vec<Lit> tmp; return solveLimited(nConflicts); }$/;"	f	class:SolverV
solveRelative	pdr/v3SvrPDRSat.cpp	/^TCube V3SvrPDRSat::solveRelative(TCube s, size_t param) {$/;"	f	class:V3SvrPDRSat
sort	pdr/SortV.h	/^template <class T, class LessThan> void sort(T* array, int size, LessThan lt) {$/;"	f
sort	pdr/SortV.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	pdr/SortV.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	pdr/SortV.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	pdr/SortV.h	/^void sort(T* array, int size, LessThan lt, double& seed)$/;"	f
sortUnique	pdr/SortV.h	/^template <class T, class LessThan> void sortUnique(vec<T>& v, LessThan lt) {$/;"	f
sortUnique	pdr/SortV.h	/^template <class T> static inline void sortUnique(T* array, int& size) {$/;"	f
sortUnique	pdr/SortV.h	/^template <class T> void sortUnique(vec<T>& v) {$/;"	f
sortUnique	pdr/SortV.h	/^void sortUnique(T* array, int& size, LessThan lt)$/;"	f
speculativeReduction	vrf/v3VrfSEC.cpp	/^V3VrfSEC::speculativeReduction(const uint32_t& cycle) {$/;"	f	class:V3VrfSEC
splitAigFromProperties	io/v3AigWriter.cpp	/^void splitAigFromProperties(const string& fileName, const bool& symbol) {$/;"	f
standardize	bdd/bddMgrV.cpp	/^BddMgrV::standardize(BddNodeV &f, BddNodeV &g, BddNodeV &h, bool &isNegEdge)$/;"	f	class:BddMgrV
start	util/v3Usage.h	/^      inline void start() { assert (!_isStarted); _startTime = clock(); ++_numCalled; _isStarted = 1; }$/;"	f	class:V3Stat
startAllDefault	util/v3Msg.h	/^      void startAllDefault() { for (unsigned i = 1; i < 5; ++i) Msgs[i]->startDefault(); }$/;"	f	class:V3MsgMgr
startAllOutFile	util/v3Msg.h	/^      void startAllOutFile(bool append = false) {$/;"	f	class:V3MsgMgr
startChecker	v3mc/v3MCMain.cpp	/^void* startChecker(void* param) {$/;"	f
startClusterVariables	stg/v3StgExtract.cpp	/^V3FSMExtract::startClusterVariables() {$/;"	f	class:V3FSMExtract
startConstructFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::startConstructFSMSDG() {$/;"	f	class:V3FSMSDGDB
startConstructFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::startConstructFSMSDG(V3SDGBase* const sdg, uint32_t& stateSize, V3FSMSDGMap& selectMap, V3NetVec& parentNets) {$/;"	f	class:V3FSMSDGDB
startDefault	util/v3Msg.h	/^      void startDefault() { _defaultON = true; }$/;"	f	class:V3Msg
startDefault	util/v3Msg.h	/^      void startDefault(const V3MsgType type) { Msgs[type]->startDefault(); }$/;"	f	class:V3MsgMgr
startExtractClusteredFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractClusteredFSMs() {$/;"	f	class:V3FSMExtract
startExtractFSM	stg/v3StgFSM.cpp	/^V3FSM::startExtractFSM(const V3NetVec& terminal) {$/;"	f	class:V3FSM
startExtractFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractFSMs() {$/;"	f	class:V3FSMExtract
startExtractInvariantFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractInvariantFSMs() {$/;"	f	class:V3FSMExtract
startOutFile	util/v3Msg.h	/^      void startOutFile(bool append) {$/;"	f	class:V3Msg
startOutFile	util/v3Msg.h	/^      void startOutFile(const V3MsgType type, bool append = false) { Msgs[type]->startOutFile(append); }$/;"	f	class:V3MsgMgr
startVarOrder	alg/v3AlgGeneralize.cpp	/^V3GenStruct::startVarOrder(const V3NetVec& careVars) {$/;"	f	class:V3GenStruct
startVerificationFromProp	v3mc/v3MCProp.cpp	/^void startVerificationFromProp(V3NtkHandler* const handler, const uint32_t& numOfCores, const double& maxTime, const double& maxMemory) {$/;"	f
startVerificationMain	v3mc/v3MCMain.cpp	/^void* startVerificationMain(void* param) {$/;"	f
startVerify	vrf/v3VrfBMC.cpp	/^V3VrfBMC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfBMC
startVerify	vrf/v3VrfBase.cpp	/^V3VrfBase::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfBase
startVerify	vrf/v3VrfCITP.cpp	/^V3VrfCITP::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfCITP
startVerify	vrf/v3VrfFITP.cpp	/^V3VrfFITP::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfFITP
startVerify	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfIPDR
startVerify	vrf/v3VrfKLive.cpp	/^V3VrfKLive::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfKLive
startVerify	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfMPDR
startVerify	vrf/v3VrfSEC.cpp	/^V3VrfSEC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfSEC
startVerify	vrf/v3VrfSIM.cpp	/^V3VrfSIM::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfSIM
startVerify	vrf/v3VrfUMC.cpp	/^V3VrfUMC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfUMC
start_proof_logging	pdr/SolverV.h	/^    bool    start_proof_logging() { return false; }$/;"	f	class:SolverV
starts	pdr/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
stats	pdr/SolverV.h	/^    SolverStats     stats;$/;"	m	class:SolverV
stopAllDefault	util/v3Msg.h	/^      void stopAllDefault() { for (unsigned i = 1; i < 5; ++i) Msgs[i]->stopDefault(); }$/;"	f	class:V3MsgMgr
stopAllOutFile	util/v3Msg.h	/^      void stopAllOutFile() { if (isAllOutFileON()) V3Msg::_allout.close(); }$/;"	f	class:V3MsgMgr
stopDefault	util/v3Msg.h	/^      void stopDefault() { _defaultON = false; }$/;"	f	class:V3Msg
stopDefault	util/v3Msg.h	/^      void stopDefault(const V3MsgType type) { Msgs[type]->stopDefault(); }$/;"	f	class:V3MsgMgr
stopOnAllInitialOrAllTerminal	stg/v3StgFSM.h	/^      inline void stopOnAllInitialOrAllTerminal(const bool& e) { if (e) _configs |= 1ul; else _configs &= ~1ul; }$/;"	f	class:V3FSM
stopOutFile	util/v3Msg.h	/^      void stopOutFile() { if (isOutFileON()) _outfile.close(); }$/;"	f	class:V3Msg
stopOutFile	util/v3Msg.h	/^      void stopOutFile(const V3MsgType type) { Msgs[type]->stopOutFile(); }$/;"	f	class:V3MsgMgr
strashAigGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashAigGate(V3AigNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashAigGate	ntk/v3NtkStrash.cpp	/^void strashAigGate(V3AigNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashAigNodeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashAigNodeGate(V3AigNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashAigNodeGate	ntk/v3NtkStrash.cpp	/^void strashAigNodeGate(V3AigNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvConstGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvConstGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvConstGate	ntk/v3NtkStrash.cpp	/^void strashBvConstGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvGate	ntk/v3NtkStrash.cpp	/^void strashBvGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvMuxGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvMuxGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvMuxGate	ntk/v3NtkStrash.cpp	/^void strashBvMuxGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvPairTypeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvPairTypeGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvPairTypeGate	ntk/v3NtkStrash.cpp	/^void strashBvPairTypeGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvReducedTypeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvReducedTypeGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvReducedTypeGate	ntk/v3NtkStrash.cpp	/^void strashBvReducedTypeGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvSliceGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvSliceGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvSliceGate	ntk/v3NtkStrash.cpp	/^void strashBvSliceGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashON	ntk/v3NtkHandler.h	/^      static inline const bool strashON()  { return _extVerbosity & 2ul;  }$/;"	f	class:V3NtkHandler
strongConnect	adt/v3Graph.h	/^V3Graph<T>::strongConnect(const uint32_t& curNode, V3IndexField& scc, V3UI32Vec& nodeIndex, V3UI32Vec& nodeLowlink, V3BoolVec& inStack, V3UI32Stack& nodeStack, uint32_t& curIndex) const {$/;"	f	class:V3Graph
subsumes	pdr/PDRDef.h	/^  bool subsumes(Cube* s) const {$/;"	f	class:Cube
subsumes	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::subsumes(const V3IPDRCube* const cube) const {$/;"	f	class:V3IPDRFrame
subsumes	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::subsumes(const V3MPDRCube* const cube) const {$/;"	f	class:V3MPDRFrame
svrInfoON	vrf/v3VrfBase.h	/^      static inline const bool svrInfoON() { return reportON() &&  (8ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
swapBddNodeV	bdd/bddMgrV.cpp	/^static void swapBddNodeV(BddNodeV& f, BddNodeV& g)$/;"	f	file:
sz	pdr/GlobalV.h	/^    int sz;$/;"	m	class:vec
tell	pdr/FileV.cpp	/^int64 File::tell(void)$/;"	f	class:File
temp_files	pdr/ProofV.cpp	/^static TempFiles temp_files;       \/\/ (should be singleton)$/;"	v	file:
ternarySimInit	pdr/v3SvrPDRSat.cpp	/^bool* V3SvrPDRSat::ternarySimInit(Cube* c) {$/;"	f	class:V3SvrPDRSat
ternarySimulation	pdr/v3SvrPDRSat.cpp	/^Cube* V3SvrPDRSat::ternarySimulation(Cube* c, bool b, bool* input, Cube* s) {$/;"	f	class:V3SvrPDRSat
toDimacs	pdr/SolverTypesV.h	/^inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }$/;"	f
toExp	adt/v3BitVec.cpp	/^V3BitVec::toExp() const {$/;"	f	class:V3BitVec
toExp	adt/v3BitVec.cpp	/^V3BitVecX::toExp() const {$/;"	f	class:V3BitVecX
toInt	pdr/GlobalV.h	/^    int toInt(void) const { return value; }$/;"	f	class:lbool
toInt	pdr/GlobalV.h	/^inline int   toInt  (lbool l) { return l.toInt(); }$/;"	f
toLbool	pdr/GlobalV.h	/^inline lbool toLbool(int   v) { return lbool(v);  }$/;"	f
toLit	pdr/SolverTypesV.h	/^inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  \/\/ Inverse of 'index()'.$/;"	f
toString	bdd/bddNodeV.cpp	/^BddNodeV::toString() const$/;"	f	class:BddNodeV
toStringRecur	bdd/bddNodeV.cpp	/^BddNodeV::toStringRecur(bool phase, string& str) const$/;"	f	class:BddNodeV
topologicalSort	adt/v3Graph.h	/^V3Graph<T>::topologicalSort(V3NodeFlow& orderList) const {$/;"	f	class:V3Graph
topologicalSortIndex	adt/v3Graph.h	/^V3Graph<T>::topologicalSortIndex(V3IndexFlow& orderList) const {$/;"	f	class:V3Graph
tot_literals	pdr/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
totalSolves	pdr/v3SvrPDRSat.h	/^      inline const uint32_t totalSolves() const { return _solves; }$/;"	f	class:V3SvrPDRSat
totalSolves	svr/v3SvrBase.h	/^      inline const uint32_t totalSolves() const { return _solves; }$/;"	f	class:V3SvrBase
totalTime	pdr/v3SvrPDRSat.h	/^      inline const double totalTime() const { return _runTime; }$/;"	f	class:V3SvrPDRSat
totalTime	svr/v3SvrBase.h	/^      inline const double totalTime() const { return _runTime; }$/;"	f	class:V3SvrBase
trail	pdr/SolverV.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:SolverV
trail_lim	pdr/SolverV.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail[]'.$/;"	m	class:SolverV
trail_pos	pdr/SolverV.cpp	/^    const vec<int>& trail_pos;$/;"	m	class:lastToFirst_lt	file:
trail_pos	pdr/SolverV.h	/^    vec<int>            trail_pos;        \/\/ 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.$/;"	m	class:SolverV
trav	pdr/ProofV.h	/^    ProofTraverser* trav;$/;"	m	class:Proof
traverse	pdr/ProofV.cpp	/^void Proof::traverse(ProofTraverser& trav, ClauseId goal)$/;"	f	class:Proof
type	ntk/v3Type.h	/^   uint32_t    type : 6;$/;"	m	struct:V3MiscType
uchar	pdr/GlobalV.h	/^typedef unsigned char uchar;$/;"	t
uint64	pdr/GlobalV.h	/^typedef UINT64             uint64;$/;"	t
uint64	pdr/GlobalV.h	/^typedef unsigned long long uint64;$/;"	t
uintp	pdr/GlobalV.h	/^typedef UINT_PTR           uintp;$/;"	t
uintp	pdr/GlobalV.h	/^typedef unsigned __PTRDIFF_TYPE__ uintp;$/;"	t
undo	pdr/VarOrderV.h	/^void VarOrder::undo(Var x)$/;"	f	class:VarOrder
uniquify	bdd/bddMgrV.cpp	/^BddMgrV::uniquify(size_t l, size_t r, unsigned i)$/;"	f	class:BddMgrV
unit_id	pdr/SolverV.h	/^    vec<ClauseId>       unit_id;          \/\/ 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).$/;"	m	class:SolverV
unlock	vrf/v3VrfShared.h	/^      inline void unlock() { pthread_mutex_unlock(&_mutex); }$/;"	f	class:V3VrfShared
unsetVisited	bdd/bddNodeV.h	/^   void unsetVisited() { _visited = 0; }$/;"	f	class:BddNodeVInt
unsetVisitedRecur	bdd/bddNodeV.cpp	/^BddNodeV::unsetVisitedRecur() const$/;"	f	class:BddNodeV
unsign	pdr/SolverTypesV.h	/^inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }$/;"	f
update	pdr/VarOrderV.h	/^void VarOrder::update(Var x)$/;"	f	class:VarOrder
update	svr/v3SvrBase.cpp	/^V3SvrBase::update() {$/;"	f	class:V3SvrBase
update	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::update() {$/;"	f	class:V3SvrBoolector
update	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::update() {$/;"	f	class:V3SvrMiniSat
updateBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::updateBound(const uint32_t& p, const uint32_t& bound) {$/;"	f	class:V3VrfSharedBound
updateDepMuxSet	stg/v3StgFSM.cpp	/^V3FSMSDGDB::updateDepMuxSet(V3UI32Set& depMuxSet) {$/;"	f	class:V3FSMSDGDB
updateECPair	vrf/v3VrfSEC.cpp	/^V3VrfSEC::updateECPair(const bool& initValid, const bool& update) {$/;"	f	class:V3VrfSEC
updateEQList	vrf/v3VrfSEC.cpp	/^V3VrfSEC::updateEQList(const uint32_t& x, V3RepIdHash& repIdHash) {$/;"	f	class:V3VrfSEC
updateExtractedFSM	stg/v3StgFSM.cpp	/^V3FSM::updateExtractedFSM(const V3NetVec& terminal) {$/;"	f	class:V3FSM
updateInput	ntk/v3Ntk.h	/^      inline void updateInput(const uint32_t& i, const V3NetId& id) { assert (i < _inputs.size()); _inputs[i] = id; }$/;"	f	class:V3NtkModule
updateInv	vrf/v3VrfShared.h	/^      inline void updateInv(const V3NetTable& i) { lock(); _inv = i; unlock(); }$/;"	f	class:V3VrfSharedInv
updateInv	vrf/v3VrfShared.h	/^      inline void updateInv(const V3NetVec& i) { lock(); _inv.push_back(i); unlock(); }$/;"	f	class:V3VrfSharedInv
updateMaxMemory	vrf/v3VrfShared.h	/^      inline void updateMaxMemory(const double& m) { lock(); _maxMemory = m; unlock(); }$/;"	f	class:V3VrfSharedMem
updateModule	ntk/v3NtkConstruct.cpp	/^const bool updateModule(V3Ntk* const ntk, V3NtkModule* const module, $/;"	f
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::updateNextStateEvent() {$/;"	f	class:V3AlgAigSimulate
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::updateNextStateEvent() {$/;"	f	class:V3AlgBvSimulate
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::updateNextStateEvent() {}$/;"	f	class:V3AlgSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::updateNextStateValue() {$/;"	f	class:V3AlgAigSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::updateNextStateValue() {$/;"	f	class:V3AlgBvSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::updateNextStateValue() {}$/;"	f	class:V3AlgSimulate
updateNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::updateNtk(V3Ntk* const ntk, const V3NetTable& constr) {$/;"	f	class:V3VrfSharedNtk
updateNtkRef	ntk/v3Ntk.h	/^      inline void updateNtkRef(const V3NtkHandler* const h, const bool& b = false) {$/;"	f	class:V3NtkModule
updateOutput	ntk/v3Ntk.h	/^      inline void updateOutput(const uint32_t& i, const V3NetId& id) { assert (i < _outputs.size()); _outputs[i] = id; }$/;"	f	class:V3NtkModule
updateOutput	vrf/v3VrfKLive.cpp	/^V3VrfKLive::updateOutput(const uint32_t& p) {$/;"	f	class:V3VrfKLive
updateRemaining	v3mc/v3MCMain.cpp	/^V3MCResource::updateRemaining(const V3MCMainType& t, const uint32_t& rem) {$/;"	f	class:V3MCResource
updateResult	v3mc/v3MCMain.cpp	/^V3MCResult::updateResult(const uint32_t& p, const V3VrfResult& result) {$/;"	f	class:V3MCResult
updateVarOrder	alg/v3AlgGeneralize.cpp	/^V3GenStruct::updateVarOrder(const bool& succeed) {$/;"	f	class:V3GenStruct
usage	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotTraceCmd
usage	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3SimNtkCmd
usage	bdd/bddCmd.cpp	/^BAndCmd::usage(const bool& verbose) const$/;"	f	class:BAndCmd
usage	bdd/bddCmd.cpp	/^BCofactorCmd::usage(const bool& verbose) const$/;"	f	class:BCofactorCmd
usage	bdd/bddCmd.cpp	/^BCompareCmd::usage(const bool& verbose) const$/;"	f	class:BCompareCmd
usage	bdd/bddCmd.cpp	/^BConstructCmd::usage(const bool& verbose) const$/;"	f	class:BConstructCmd
usage	bdd/bddCmd.cpp	/^BDrawCmd::usage(const bool& verbose) const$/;"	f	class:BDrawCmd
usage	bdd/bddCmd.cpp	/^BExistCmd::usage(const bool& verbose) const$/;"	f	class:BExistCmd
usage	bdd/bddCmd.cpp	/^BInvCmd::usage(const bool& verbose) const$/;"	f	class:BInvCmd
usage	bdd/bddCmd.cpp	/^BNandCmd::usage(const bool& verbose) const$/;"	f	class:BNandCmd
usage	bdd/bddCmd.cpp	/^BNorCmd::usage(const bool& verbose) const$/;"	f	class:BNorCmd
usage	bdd/bddCmd.cpp	/^BOrCmd::usage(const bool& verbose) const$/;"	f	class:BOrCmd
usage	bdd/bddCmd.cpp	/^BReportCmd::usage(const bool& verbose) const$/;"	f	class:BReportCmd
usage	bdd/bddCmd.cpp	/^BResetCmd::usage(const bool& verbose) const$/;"	f	class:BResetCmd
usage	bdd/bddCmd.cpp	/^BSetOrderCmd::usage(const bool& verbose) const$/;"	f	class:BSetOrderCmd
usage	bdd/bddCmd.cpp	/^BSetVarCmd::usage(const bool& verbose) const$/;"	f	class:BSetVarCmd
usage	bdd/bddCmd.cpp	/^BSimulateCmd::usage(const bool& verbose) const$/;"	f	class:BSimulateCmd
usage	bdd/bddCmd.cpp	/^BXnorCmd::usage(const bool& verbose) const$/;"	f	class:BXnorCmd
usage	bdd/bddCmd.cpp	/^BXorCmd::usage(const bool& verbose) const$/;"	f	class:BXorCmd
usage	cmd/v3CmdComm.cpp	/^V3DofileCmd::usage(const bool& verbose) const {  $/;"	f	class:V3DofileCmd
usage	cmd/v3CmdComm.cpp	/^V3HelpCmd::usage(const bool& verbose) const {$/;"	f	class:V3HelpCmd
usage	cmd/v3CmdComm.cpp	/^V3HistoryCmd::usage(const bool& verbose) const {$/;"	f	class:V3HistoryCmd
usage	cmd/v3CmdComm.cpp	/^V3LogFileCmd::usage(const bool& verbose) const {$/;"	f	class:V3LogFileCmd
usage	cmd/v3CmdComm.cpp	/^V3QuitCmd::usage(const bool& verbose) const {$/;"	f	class:V3QuitCmd
usage	cmd/v3CmdComm.cpp	/^V3UsageCmd::usage(const bool& verbose) const {$/;"	f	class:V3UsageCmd
usage	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::usage(const bool& verbose) const {$/;"	f	class:V3OptTraceCmd
usage	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::usage(const bool& verbose) const {$/;"	f	class:V3TraceSimplifyCmd
usage	itp/satCmd.cpp	/^SATVerifyBmcCmd::usage(const bool& verbose) const$/;"	f	class:SATVerifyBmcCmd
usage	itp/satCmd.cpp	/^SATVerifyItpCmd::usage(const bool& verbose) const$/;"	f	class:SATVerifyItpCmd
usage	main/main.cpp	/^static void usage() {$/;"	f	file:
usage	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3DuplicateNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ListNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::usage(const bool& verbose) const$/;"	f	class:V3NetInfoCmd
usage	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintNetCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintVerbosityCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadAIGCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadBTORCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadRTLCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReduceNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3RefNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3RewriteNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetVerbosityCmd
usage	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3StrashNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3WorkNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteAIGCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteBTORCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteRTLCmd
usage	pdr/pdrCmd.cpp	/^SATVerifyCmd::usage(const bool& verbose) const$/;"	f	class:SATVerifyCmd
usage	prove/proveCmd.cpp	/^PCheckPropertyCmd::usage(const bool& verbose) const$/;"	f	class:PCheckPropertyCmd
usage	prove/proveCmd.cpp	/^PImageCmd::usage(const bool& verbose) const$/;"	f	class:PImageCmd
usage	prove/proveCmd.cpp	/^PInitialStateCmd::usage(const bool& verbose) const$/;"	f	class:PInitialStateCmd
usage	prove/proveCmd.cpp	/^PTransRelationCmd::usage(const bool& verbose) const$/;"	f	class:PTransRelationCmd
usage	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3ElaborateFSMCmd
usage	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3ExtractFSMCmd
usage	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotFSMCmd
usage	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteFSMCmd
usage	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3BlastNtkCmd
usage	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ExpandNtkCmd
usage	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3FlattenNtkCmd
usage	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3MiterNtkCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCReadPropertyCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCRunCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCWritePropertyCmd
usage	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3BMCVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3CheckResultCmd
usage	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::usage(const bool& verbose) const {$/;"	f	class:V3ElaboratePrptyCmd
usage	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3ITPVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3KLiveVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3PDRVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotResultCmd
usage	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintReportCmd
usage	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintSolverCmd
usage	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3SECVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3SIMVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetLivenessCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetReportCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetSafetyCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetSolverCmd
usage	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3UMCVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteResultCmd
usageON	vrf/v3VrfBase.h	/^      static inline const bool usageON()   { return reportON() &&  (16ul & _extVerbosity); }$/;"	f	class:V3VrfBase
v3CmdMgr	main/main.cpp	/^V3CmdMgr* v3CmdMgr = new V3CmdMgr("v3");$/;"	v
v3CreateDir	util/v3FileUtil.h	/^static inline bool v3CreateDir(const char* dirName, bool replace = true) {$/;"	f
v3DeleteDir	util/v3FileUtil.h	/^static inline void v3DeleteDir(const char* dirName) {$/;"	f
v3ExistDir	util/v3FileUtil.h	/^static inline bool v3ExistDir(const char* dirName) {$/;"	f
v3GetAbsPath	util/v3FileUtil.h	/^static inline const char* v3GetAbsPath(const char* fileName) {$/;"	f
v3GetExecPath	util/v3FileUtil.h	/^static inline const char* v3GetExecPath() {$/;"	f
v3Handler	main/main.cpp	/^V3Handler v3Handler;$/;"	v
v3Int2Str	util/v3StrUtil.cpp	/^v3Int2Str(const int& num, const uint32_t& width) {$/;"	f
v3MCInteractive	v3mc/v3MCMain.h	/^static const bool v3MCInteractive = false;$/;"	v
v3MCResultCheck	v3mc/v3MCMain.h	/^static const bool v3MCResultCheck = false;$/;"	v
v3SimOneGate	pdr/v3SvrPDRSat.cpp	/^void V3SvrPDRSat::v3SimOneGate(V3NetId id) {$/;"	f	class:V3SvrPDRSat
v3Str2BVExpr	util/v3StrUtil.cpp	/^v3Str2BVExpr(const string& expr, uint32_t& start, uint32_t& end) {$/;"	f
v3Str2Int	util/v3StrUtil.cpp	/^v3Str2Int(const string& str, int& num) {$/;"	f
v3Str2UInt	util/v3StrUtil.cpp	/^v3Str2UInt(const string& str, uint32_t& num) {$/;"	f
v3StrGetTok	util/v3StrUtil.cpp	/^v3StrGetTok(const string& str, string& tok, const size_t& pos, const char del) {$/;"	f
v3StrNCmp	util/v3StrUtil.cpp	/^v3StrNCmp(const string& s1, const string& s2, const uint32_t& n) {$/;"	f
v3StrRemoveSpaces	util/v3StrUtil.cpp	/^v3StrRemoveSpaces(const string str) {$/;"	f
v3Usage	main/main.cpp	/^V3Usage v3Usage;$/;"	v
valid	bdd/bddCmd.cpp	/^static bool valid()$/;"	f	file:
valid	itp/satCmd.cpp	/^static bool valid()$/;"	f	file:
valid	pdr/pdrCmd.cpp	/^static bool valid()$/;"	f	file:
valid	prove/proveCmd.cpp	/^static bool valid()$/;"	f	file:
validNetId	itp/sat.h	/^      inline const bool validNetId(const V3NetId& id) const { return _ntk->getNetSize() > id.id; }$/;"	f	class:SatSolver
validNetId	ntk/v3Ntk.h	/^      inline const bool validNetId(const V3NetId& id) const { return (id.id) < getNetSize(); }$/;"	f	class:V3Ntk
validNetId	pdr/v3SvrPDRSat.h	/^      inline const bool validNetId(const V3NetId& id) const { return _ntk->getNetSize() > id.id; }$/;"	f	class:V3SvrPDRSat
validNetId	svr/v3SvrBase.h	/^      inline const bool validNetId(const V3NetId& id) const { return _ntk->getNetSize() > id.id; }$/;"	f	class:V3SvrBase
value	adt/v3BitVec.cpp	/^V3BitVec::value() const {$/;"	f	class:V3BitVec
value	adt/v3BitVec.cpp	/^V3BitVecX::value() const {$/;"	f	class:V3BitVecX
value	ntk/v3Type.h	/^   uint32_t    value;$/;"	m	union:V3NetType
value	pdr/GlobalV.h	/^    int     value;$/;"	m	class:lbool
value	pdr/SolverV.h	/^    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }$/;"	f	class:SolverV
value	pdr/SolverV.h	/^    lbool   value(Var x) const { return toLbool(assigns[x]); }$/;"	f	class:SolverV
var	pdr/SolverTypesV.h	/^inline int  var   (Lit p) { return p.x >> 1; }$/;"	f
varBumpActivity	pdr/SolverV.h	/^    void     varBumpActivity(Lit p) {$/;"	f	class:SolverV
varDecayActivity	pdr/SolverV.h	/^    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }$/;"	f	class:SolverV
varRescaleActivity	pdr/SolverV.cpp	/^void SolverV::varRescaleActivity()$/;"	f	class:SolverV
var_Undef	pdr/SolverTypesV.h	37;"	d
var_decay	pdr/SolverV.h	/^    double              var_decay;        \/\/ INVERSE decay factor for variable activity: stores 1\/decay. Use negative value for static variable order.$/;"	m	class:SolverV
var_decay	pdr/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
var_inc	pdr/SolverV.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:SolverV
vec	pdr/GlobalV.h	/^             vec        (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
vec	pdr/GlobalV.h	/^    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'xfree()')$/;"	f	class:vec
vec	pdr/GlobalV.h	/^    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	pdr/GlobalV.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	pdr/GlobalV.h	/^    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	pdr/GlobalV.h	/^class vec {$/;"	c
verbosity	pdr/SolverV.h	/^    int             verbosity;          \/\/ Verbosity level. 0=silent, 1=some progress report, 2=everything$/;"	m	class:SolverV
verifyInOrder	vrf/v3VrfBase.cpp	/^V3VrfBase::verifyInOrder() {$/;"	f	class:V3VrfBase
verifyProperty	pdr/pdrMgr.cpp	/^void PDRMgr::verifyProperty(const string& name, const V3NetId& monitor) {$/;"	f	class:PDRMgr
verifyProperty	vrf/v3VrfBase.cpp	/^V3VrfBase::verifyProperty(const uint32_t& p) {$/;"	f	class:V3VrfBase
verifyPropertyBmc	itp/satMgr.cpp	/^void SATMgr::verifyPropertyBmc(const string& name, const V3NetId& monitor) {$/;"	f	class:SATMgr
verifyPropertyItp	itp/satMgr.cpp	/^void SATMgr::verifyPropertyItp(const string& name, const V3NetId& monitor) {$/;"	f	class:SATMgr
version_info	pdr/SolverV.h	/^    inline const char* version_info() const { return "MINISAT Ver. 2.2"; }$/;"	f	class:SolverV
watches	pdr/SolverV.h	/^    vec<vec<Clause*> >  watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:SolverV
words	adt/v3BitVec.cpp	/^unsigned words(const unsigned s) { return (s >> 3) + ((MOD_WORD & s) ? 1 : 0); }$/;"	f
write	bdd/myHash.h	/^   void write(const CacheKey& k, const CacheData& d) {$/;"	f	class:Cache
writeAiger	v3mc/v3MCAiger.cpp	/^void writeAiger(V3NtkHandler* const handler, const string& fileName, const bool& l2s, const bool& invc2Prop) {$/;"	f
writeClusterResult	stg/v3StgExtract.cpp	/^V3FSMExtract::writeClusterResult(const string& fileName) const {$/;"	f	class:V3FSMExtract
writeFSM	stg/v3StgExtract.cpp	/^V3FSMExtract::writeFSM(const string& fileName, V3FSM* const fsm) const {$/;"	f	class:V3FSMExtract
writeFSM	stg/v3StgFSM.cpp	/^V3FSM::writeFSM(const string& fileName) const {$/;"	f	class:V3FSM
writeProperty	v3mc/v3MCProp.cpp	/^void writeProperty(V3NtkHandler* const handler, const string& fileName, const bool& l2s, const bool& invc2Prop) {$/;"	f
writeV3GeneralHeader	io/v3NtkWriter.cpp	/^void writeV3GeneralHeader(const string& formatType, ofstream& output, const string& commentStart) {$/;"	f
x	pdr/SolverTypesV.h	/^    int     x;  \/\/ MODIFICATION FOR SoCV$/;"	m	class:Lit
xfree	pdr/GlobalV.h	/^template<class T> static inline void xfree(T *ptr) {$/;"	f
xmalloc	pdr/GlobalV.h	/^template<class T> static inline T* xmalloc(size_t size) {$/;"	f
xnor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xnor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
xnor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xnor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
xor_2	pdr/v3SvrPDRSat.cpp	/^inline void xor_2(SolverV* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
xor_2	svr/v3SvrSatHelper.h	/^inline void xor_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
xor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
xor_3	svr/v3SvrSatHelper.h	/^inline void xor_3(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& c)$/;"	f
xor_3	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_3(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& c)$/;"	f
xor_red	svr/v3SvrSatHelper.h	/^inline void xor_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
xor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
xrealloc	pdr/GlobalV.h	/^template<class T> static inline T* xrealloc(T* ptr, size_t size) {$/;"	f
~BddMgrV	bdd/bddMgrV.h	/^   ~BddMgrV() { reset(); }$/;"	f	class:BddMgrV
~BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::~BddNodeV()$/;"	f	class:BddNodeV
~Cache	bdd/myHash.h	/^   ~Cache() { reset(); }$/;"	f	class:Cache
~Cube	pdr/PDRDef.h	/^  ~Cube() {$/;"	f	class:Cube
~File	pdr/FileV.h	/^   ~File(void) {$/;"	f	class:File
~Hash	bdd/myHash.h	/^   ~Hash() { reset(); }$/;"	f	class:Hash
~PDRMgr	pdr/pdrMgr.h	/^    ~PDRMgr() { reset(); }$/;"	f	class:PDRMgr
~ProofTraverser	pdr/ProofV.h	/^    virtual ~ProofTraverser() {}$/;"	f	struct:ProofTraverser
~Reader	itp/reader.cpp	/^Reader::~Reader(){$/;"	f	class:Reader
~Reader	pdr/reader.cpp	/^Reader::~Reader(){$/;"	f	class:Reader
~SATMgr	itp/satMgr.h	/^    ~SATMgr() { reset(); }$/;"	f	class:SATMgr
~SatSolver	itp/sat.cpp	/^SatSolver::~SatSolver() $/;"	f	class:SatSolver
~SolverV	pdr/SolverV.h	/^   ~SolverV() {$/;"	f	class:SolverV
~TCube	pdr/PDRDef.h	/^  ~TCube(){$/;"	f	class:TCube
~TempFiles	pdr/ProofV.cpp	/^   ~TempFiles()$/;"	f	class:TempFiles
~V3AlgAigGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::~V3AlgAigGeneralize() {$/;"	f	class:V3AlgAigGeneralize
~V3AlgAigSimulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::~V3AlgAigSimulate() {$/;"	f	class:V3AlgAigSimulate
~V3AlgBvGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::~V3AlgBvGeneralize() {$/;"	f	class:V3AlgBvGeneralize
~V3AlgBvSimulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::~V3AlgBvSimulate() {$/;"	f	class:V3AlgBvSimulate
~V3AlgGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::~V3AlgGeneralize() {$/;"	f	class:V3AlgGeneralize
~V3AlgSimulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::~V3AlgSimulate() {$/;"	f	class:V3AlgSimulate
~V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::~V3BitVec() {$/;"	f	class:V3BitVec
~V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::~V3BitVecS() {}$/;"	f	class:V3BitVecS
~V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::~V3BitVecX() {$/;"	f	class:V3BitVecX
~V3BucketList	adt/v3Bucket.h	/^V3BucketList<T>::~V3BucketList() {$/;"	f	class:V3BucketList
~V3BvBlastAig	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::~V3BvBlastAig() {$/;"	f	class:V3BvBlastAig
~V3BvBlastBv	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::~V3BvBlastBv() {$/;"	f	class:V3BvBlastBv
~V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::~V3BvNtk() {$/;"	f	class:V3BvNtk
~V3CITPCube	vrf/v3VrfCITP.h	/^      ~V3CITPCube() { _stateId.clear(); }$/;"	f	class:V3CITPCube
~V3CITPFrame	vrf/v3VrfCITP.cpp	/^V3CITPFrame::~V3CITPFrame() {$/;"	f	class:V3CITPFrame
~V3CexTrace	ext/v3Property.h	/^      ~V3CexTrace() { if (_init) delete _init; _data.clear(); }$/;"	f	class:V3CexTrace
~V3CmdExec	cmd/v3CmdMgr.h	/^      virtual ~V3CmdExec() {}$/;"	f	class:V3CmdExec
~V3CmdMgr	cmd/v3CmdMgr.cpp	/^V3CmdMgr::~V3CmdMgr() {$/;"	f	class:V3CmdMgr
~V3Constraint	ext/v3Property.cpp	/^V3Constraint::~V3Constraint() {$/;"	f	class:V3Constraint
~V3DfxCube	dfx/v3DfxTrace.h	/^      ~V3DfxCube() { _stateId.clear(); }$/;"	f	class:V3DfxCube
~V3FITPCube	vrf/v3VrfFITP.h	/^      ~V3FITPCube() { _stateId.clear(); }$/;"	f	class:V3FITPCube
~V3FITPFrame	vrf/v3VrfFITP.cpp	/^V3FITPFrame::~V3FITPFrame() {$/;"	f	class:V3FITPFrame
~V3FSM	stg/v3StgFSM.cpp	/^V3FSM::~V3FSM() {$/;"	f	class:V3FSM
~V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::~V3FSMExtract() {$/;"	f	class:V3FSMExtract
~V3FSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::~V3FSMSDG() {$/;"	f	class:V3FSMSDG
~V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::~V3FSMSDGDB() {$/;"	f	class:V3FSMSDGDB
~V3Formula	ext/v3Formula.cpp	/^V3Formula::~V3Formula() {$/;"	f	class:V3Formula
~V3GenBucket	alg/v3AlgGeneralize.cpp	/^V3GenBucket::~V3GenBucket() {$/;"	f	class:V3GenBucket
~V3GenStruct	alg/v3AlgGeneralize.cpp	/^V3GenStruct::~V3GenStruct() {$/;"	f	class:V3GenStruct
~V3Graph	adt/v3Graph.h	/^V3Graph<T>::~V3Graph() { clearGraph(); }$/;"	f	class:V3Graph
~V3Handler	ntk/v3NtkHandler.cpp	/^V3Handler::~V3Handler() {$/;"	f	class:V3Handler
~V3IPDRCube	vrf/v3VrfIPDR.h	/^      ~V3IPDRCube() { _stateId.clear(); }$/;"	f	class:V3IPDRCube
~V3IPDRFrame	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::~V3IPDRFrame() {$/;"	f	class:V3IPDRFrame
~V3IncBucketList	adt/v3Bucket.h	/^V3IncBucketList<T>::~V3IncBucketList() {$/;"	f	class:V3IncBucketList
~V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::~V3LTLFormula() {$/;"	f	class:V3LTLFormula
~V3MCResource	v3mc/v3MCMain.cpp	/^V3MCResource::~V3MCResource() {$/;"	f	class:V3MCResource
~V3MCResult	v3mc/v3MCMain.cpp	/^V3MCResult::~V3MCResult() {$/;"	f	class:V3MCResult
~V3MPDRCube	vrf/v3VrfMPDR.h	/^      ~V3MPDRCube() { _stateId.clear(); }$/;"	f	class:V3MPDRCube
~V3MPDRFrame	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::~V3MPDRFrame() {$/;"	f	class:V3MPDRFrame
~V3Msg	util/v3Msg.h	/^      ~V3Msg() {}$/;"	f	class:V3Msg
~V3MsgMgr	util/v3Msg.h	/^      ~V3MsgMgr() { Msgs.clear(); }$/;"	f	class:V3MsgMgr
~V3Ntk	ntk/v3Ntk.cpp	/^V3Ntk::~V3Ntk() {$/;"	f	class:V3Ntk
~V3NtkElaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::~V3NtkElaborate() {$/;"	f	class:V3NtkElaborate
~V3NtkExpand	trans/v3NtkExpand.cpp	/^V3NtkExpand::~V3NtkExpand() {$/;"	f	class:V3NtkExpand
~V3NtkFlatten	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::~V3NtkFlatten() {$/;"	f	class:V3NtkFlatten
~V3NtkHandler	ntk/v3NtkHandler.cpp	/^V3NtkHandler::~V3NtkHandler() {$/;"	f	class:V3NtkHandler
~V3NtkHierData	ntk/v3NtkHandler.h	/^            ~V3NtkHierData() { _p2cMap.clear(); }$/;"	f	class:V3NtkHierInfo::V3NtkHierData
~V3NtkHierInfo	ntk/v3NtkHandler.h	/^      ~V3NtkHierInfo() { clear(); }$/;"	f	class:V3NtkHierInfo
~V3NtkInput	ntk/v3NtkInput.cpp	/^V3NtkInput::~V3NtkInput() {$/;"	f	class:V3NtkInput
~V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::~V3NtkMiter() {$/;"	f	class:V3NtkMiter
~V3NtkSimplify	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::~V3NtkSimplify() {$/;"	f	class:V3NtkSimplify
~V3PortableType	adt/v3Misc.h	/^      ~V3PortableType() { _list.clear(); _index.clear(); }$/;"	f	class:V3PortableType
~V3Property	ext/v3Property.cpp	/^V3Property::~V3Property() {$/;"	f	class:V3Property
~V3SDG	stg/v3StgSDG.cpp	/^V3SDG::~V3SDG() {$/;"	f	class:V3SDG
~V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::~V3SDGBase() {$/;"	f	class:V3SDGBase
~V3SDGMUX	stg/v3StgSDG.cpp	/^V3SDGMUX::~V3SDGMUX() {$/;"	f	class:V3SDGMUX
~V3SDGNode	stg/v3StgSDG.cpp	/^V3SDGNode::~V3SDGNode() {$/;"	f	class:V3SDGNode
~V3Stat	util/v3Usage.h	/^      ~V3Stat() {}$/;"	f	class:V3Stat
~V3SvrBase	svr/v3SvrBase.cpp	/^V3SvrBase::~V3SvrBase() {$/;"	f	class:V3SvrBase
~V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::~V3SvrBoolector() {$/;"	f	class:V3SvrBoolector
~V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::~V3SvrMiniSat() {$/;"	f	class:V3SvrMiniSat
~V3SvrPDRSat	pdr/v3SvrPDRSat.cpp	/^V3SvrPDRSat::~V3SvrPDRSat() {$/;"	f	class:V3SvrPDRSat
~V3TraceSimplify	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::~V3TraceSimplify() {$/;"	f	class:V3TraceSimplify
~V3VrfBMC	vrf/v3VrfBMC.cpp	/^V3VrfBMC::~V3VrfBMC() {$/;"	f	class:V3VrfBMC
~V3VrfBase	vrf/v3VrfBase.cpp	/^V3VrfBase::~V3VrfBase() {$/;"	f	class:V3VrfBase
~V3VrfCITP	vrf/v3VrfCITP.cpp	/^V3VrfCITP::~V3VrfCITP() {$/;"	f	class:V3VrfCITP
~V3VrfFITP	vrf/v3VrfFITP.cpp	/^V3VrfFITP::~V3VrfFITP() {$/;"	f	class:V3VrfFITP
~V3VrfIPDR	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::~V3VrfIPDR() {$/;"	f	class:V3VrfIPDR
~V3VrfKLive	vrf/v3VrfKLive.cpp	/^V3VrfKLive::~V3VrfKLive() {$/;"	f	class:V3VrfKLive
~V3VrfMPDR	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::~V3VrfMPDR() {$/;"	f	class:V3VrfMPDR
~V3VrfResult	ext/v3Property.h	/^      ~V3VrfResult() { \/* Memory Will NOT be Released !! Call clear() Explicitly !! *\/ _cexOrInv = 0; }$/;"	f	class:V3VrfResult
~V3VrfSEC	vrf/v3VrfSEC.cpp	/^V3VrfSEC::~V3VrfSEC() {$/;"	f	class:V3VrfSEC
~V3VrfSIM	vrf/v3VrfSIM.cpp	/^V3VrfSIM::~V3VrfSIM() {$/;"	f	class:V3VrfSIM
~V3VrfShared	vrf/v3VrfShared.h	/^      virtual ~V3VrfShared() {}$/;"	f	class:V3VrfShared
~V3VrfSharedBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::~V3VrfSharedBound() {$/;"	f	class:V3VrfSharedBound
~V3VrfSharedInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::~V3VrfSharedInv() {$/;"	f	class:V3VrfSharedInv
~V3VrfSharedMem	vrf/v3VrfShared.h	/^      ~V3VrfSharedMem() {}$/;"	f	class:V3VrfSharedMem
~V3VrfSharedNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::~V3VrfSharedNtk() {$/;"	f	class:V3VrfSharedNtk
~V3VrfUMC	vrf/v3VrfUMC.cpp	/^V3VrfUMC::~V3VrfUMC() {$/;"	f	class:V3VrfUMC
~iterator	bdd/myHash.h	/^      ~iterator() {} \/\/ Should NOT delete HashData$/;"	f	class:Hash::iterator
~vec	pdr/GlobalV.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec

!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AIG_FALSE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
AIG_NODE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
BDD_CMD_H	bdd/bddCmd.h	10;"	d
BDD_EDGEV_BITS	bdd/bddNodeV.h	18;"	d
BDD_EDGEV_BITS	bdd/test/bddNodeV.h	18;"	d
BDD_EDGEV_DUMMY	bdd/bddNodeV.h	/^   BDD_EDGEV_DUMMY  \/\/ dummy end$/;"	e	enum:BDD_EDGEV_FLAG
BDD_EDGEV_DUMMY	bdd/test/bddNodeV.h	/^   BDD_EDGEV_DUMMY  \/\/ dummy end$/;"	e	enum:BDD_EDGEV_FLAG
BDD_EDGEV_FLAG	bdd/bddNodeV.h	/^enum BDD_EDGEV_FLAG$/;"	g
BDD_EDGEV_FLAG	bdd/test/bddNodeV.h	/^enum BDD_EDGEV_FLAG$/;"	g
BDD_MGRV_H	bdd/bddMgrV.h	10;"	d
BDD_MGRV_H	bdd/test/bddMgrV.h	10;"	d
BDD_NEG_EDGEV	bdd/bddNodeV.h	/^   BDD_NEG_EDGEV = 1,$/;"	e	enum:BDD_EDGEV_FLAG
BDD_NEG_EDGEV	bdd/test/bddNodeV.h	/^   BDD_NEG_EDGEV = 1,$/;"	e	enum:BDD_EDGEV_FLAG
BDD_NODEV_H	bdd/bddNodeV.h	10;"	d
BDD_NODEV_H	bdd/test/bddNodeV.h	10;"	d
BDD_NODE_PTR_MASKV	bdd/bddNodeV.h	20;"	d
BDD_NODE_PTR_MASKV	bdd/test/bddNodeV.h	20;"	d
BDD_POS_EDGEV	bdd/bddNodeV.h	/^   BDD_POS_EDGEV = 0,$/;"	e	enum:BDD_EDGEV_FLAG
BDD_POS_EDGEV	bdd/test/bddNodeV.h	/^   BDD_POS_EDGEV = 0,$/;"	e	enum:BDD_EDGEV_FLAG
BOOLECTOR_H_INCLUDED	eng/boolector/boolector.h	14;"	d
BOOLECTOR_SAT	eng/boolector/boolector.h	129;"	d
BOOLECTOR_UNSAT	eng/boolector/boolector.h	134;"	d
BV_ADD	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_AND	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_BUF	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_CONST	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_DIV	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_EQUALITY	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_GEQ	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_GREATER	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_INV	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_LEQ	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_LESS	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_MERGE	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_MODULO	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_MULT	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_MUX	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_NAND	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_NEQ	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_NOR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_OR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_RED_AND	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_RED_OR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_RED_XOR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BV_SHL	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SHR	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SLICE	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
BV_SUB	ntk/v3Type.h	/^   BV_ADD, BV_SUB, BV_MULT, BV_DIV, BV_MODULO, BV_SHL, BV_SHR,                   \/\/ BV_(ARITH)$/;"	e	enum:V3GateType
BV_SVR_BOOLECTOR_C	svr/v3SvrBoolector.cpp	10;"	d	file:
BV_XNOR	ntk/v3Type.h	/^   BV_BUF, BV_INV, BV_OR, BV_NAND, BV_NOR, BV_XNOR,                              \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
BV_XOR	ntk/v3Type.h	/^   BV_RED_AND, BV_RED_OR, BV_RED_XOR, BV_MUX, BV_AND, BV_XOR,                    \/\/ BV_(RED, LOGIC)$/;"	e	enum:V3GateType
BddArr	bdd/bddMgrV.h	/^typedef vector<size_t>                        BddArr;$/;"	t
BddArr	bdd/test/bddMgrV.h	/^typedef vector<size_t>                        BddArr;$/;"	t
BddCache	bdd/bddMgrV.h	/^typedef Cache<BddCacheKeyV, size_t>    BddCache;$/;"	t	class:BddMgrV
BddCache	bdd/test/bddMgrV.h	/^typedef Cache<BddCacheKeyV, size_t>    BddCache;$/;"	t	class:BddMgrV
BddCacheKeyV	bdd/bddMgrV.h	/^   BddCacheKeyV() {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/bddMgrV.h	/^   BddCacheKeyV(size_t f, size_t g, size_t h) : _f(f), _g(g), _h(h) {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/bddMgrV.h	/^class BddCacheKeyV$/;"	c
BddCacheKeyV	bdd/test/bddMgrV.h	/^   BddCacheKeyV() {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/test/bddMgrV.h	/^   BddCacheKeyV(size_t f, size_t g, size_t h) : _f(f), _g(g), _h(h) {}$/;"	f	class:BddCacheKeyV
BddCacheKeyV	bdd/test/bddMgrV.h	/^class BddCacheKeyV$/;"	c
BddHash	bdd/bddMgrV.h	/^typedef Hash<BddHashKeyV, BddNodeVInt*> BddHash;$/;"	t	class:BddMgrV
BddHash	bdd/test/bddMgrV.h	/^typedef Hash<BddHashKeyV, BddNodeVInt*> BddHash;$/;"	t	class:BddMgrV
BddHashKeyV	bdd/bddMgrV.h	/^   BddHashKeyV(size_t l, size_t r, unsigned i) : _l(l), _r(r), _i(i) {}$/;"	f	class:BddHashKeyV
BddHashKeyV	bdd/bddMgrV.h	/^class BddHashKeyV$/;"	c
BddHashKeyV	bdd/test/bddMgrV.h	/^   BddHashKeyV(size_t l, size_t r, unsigned i) : _l(l), _r(r), _i(i) {}$/;"	f	class:BddHashKeyV
BddHashKeyV	bdd/test/bddMgrV.h	/^class BddHashKeyV$/;"	c
BddMap	bdd/bddMgrV.h	/^typedef map<string, size_t>                   BddMap;$/;"	t
BddMap	bdd/test/bddMgrV.h	/^typedef map<string, size_t>                   BddMap;$/;"	t
BddMapConstIter	bdd/bddMgrV.h	/^typedef map<string, size_t>::const_iterator   BddMapConstIter;$/;"	t
BddMapConstIter	bdd/test/bddMgrV.h	/^typedef map<string, size_t>::const_iterator   BddMapConstIter;$/;"	t
BddMapPair	bdd/bddMgrV.h	/^typedef pair<string, size_t>                  BddMapPair;$/;"	t
BddMapPair	bdd/test/bddMgrV.h	/^typedef pair<string, size_t>                  BddMapPair;$/;"	t
BddMgrV	bdd/bddMgrV.h	/^   BddMgrV(size_t nin = 64, size_t h = 8009, size_t c = 30011)$/;"	f	class:BddMgrV
BddMgrV	bdd/bddMgrV.h	/^class BddMgrV$/;"	c
BddMgrV	bdd/test/bddMgrV.h	/^   BddMgrV(size_t nin = 64, size_t h = 8009, size_t c = 30011)$/;"	f	class:BddMgrV
BddMgrV	bdd/test/bddMgrV.h	/^class BddMgrV$/;"	c
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(BddNodeVInt* n, BDD_EDGEV_FLAG f)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(const BddNodeV& n) : _nodeV(n._nodeV)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(size_t l, size_t r, size_t i, BDD_EDGEV_FLAG f)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::BddNodeV(size_t v) : _nodeV(v)$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.h	/^   BddNodeV() : _nodeV(0) {}$/;"	f	class:BddNodeV
BddNodeV	bdd/bddNodeV.h	/^class BddNodeV$/;"	c
BddNodeV	bdd/test/bddNodeV.h	/^   BddNodeV() : _nodeV(0) {}$/;"	f	class:BddNodeV
BddNodeV	bdd/test/bddNodeV.h	/^class BddNodeV$/;"	c
BddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt() : _level(0), _refCount(0), _visited(0) {}$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt(size_t l, size_t r, unsigned ll)$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/bddNodeV.h	/^class BddNodeVInt$/;"	c
BddNodeVInt	bdd/test/bddNodeV.h	/^   BddNodeVInt() : _level(0), _refCount(0), _visited(0) {}$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/test/bddNodeV.h	/^   BddNodeVInt(size_t l, size_t r, unsigned ll)$/;"	f	class:BddNodeVInt
BddNodeVInt	bdd/test/bddNodeV.h	/^class BddNodeVInt$/;"	c
BoolOption	eng/minisat/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:BoolOption
BoolOption	eng/minisat/Options.h	/^class BoolOption : public Option$/;"	c
Btor	eng/boolector/boolector.h	/^typedef struct Btor Btor;$/;"	t	typeref:struct:Btor
BtorExp	svr/v3SvrType.h	/^typedef struct BtorNode             BtorExp;$/;"	t	typeref:struct:BtorNode
BtorNode	eng/boolector/boolector.h	/^typedef struct BtorNode BtorNode;$/;"	t	typeref:struct:BtorNode
BtorSort	eng/boolector/boolector.h	/^typedef struct BtorSort BtorSort;$/;"	t	typeref:struct:BtorSort
Bucket	adt/v3Bucket.h	/^   typedef typename V3Stack<T>::Stack     Bucket;$/;"	t	class:V3BucketList
Bucket	adt/v3Bucket.h	/^   typedef typename V3Vec<T>::Vec         Bucket;$/;"	t	class:V3IncBucketList
BucketId	adt/v3Bucket.h	/^   typedef pair<uint32_t, Bucket>         BucketId;$/;"	t	class:V3IncBucketList
BucketList	adt/v3Bucket.h	/^   typedef typename V3Vec<Bucket>::Vec    BucketList;$/;"	t	class:V3BucketList
BucketList	adt/v3Bucket.h	/^   typedef typename V3Vec<BucketId>::Vec  BucketList;$/;"	t	class:V3IncBucketList
C2PMapON	ntk/v3NtkHandler.h	/^      static inline const bool C2PMapON()  { return _extVerbosity & 16ul; }$/;"	f	class:V3NtkHandler
CFLAGS	bdd/test/Makefile	/^CFLAGS    = -O3 -Wall$/;"	m
CFLAGS	bdd/test/Makefile	/^CFLAGS    = -g -Wall$/;"	m
CFLAGS	eng/minisat/Makefile	/^CFLAGS    ?= -Wall -Wno-parentheses$/;"	m
CHDRS	bdd/test/Makefile	/^CHDRS     = $(wildcard *.h)$/;"	m
CHDRS	eng/minisat/Makefile	/^CHDRS      = $(wildcard $(PWD)\/*.h)$/;"	m
CMD_EXEC_DONE	cmd/v3CmdMgr.h	/^   CMD_EXEC_DONE  = 0,$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_ERROR	cmd/v3CmdMgr.h	/^   CMD_EXEC_ERROR = 1,$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_NOP	cmd/v3CmdMgr.h	/^   CMD_EXEC_NOP   = 3$/;"	e	enum:V3CmdExecStatus
CMD_EXEC_QUIT	cmd/v3CmdMgr.h	/^   CMD_EXEC_QUIT  = 2,$/;"	e	enum:V3CmdExecStatus
CMD_OPT_EXTRA	cmd/v3CmdMgr.h	/^   CMD_OPT_EXTRA      = 1,$/;"	e	enum:V3CmdOptionError
CMD_OPT_FOPEN_FAIL	cmd/v3CmdMgr.h	/^   CMD_OPT_FOPEN_FAIL = 3$/;"	e	enum:V3CmdOptionError
CMD_OPT_ILLEGAL	cmd/v3CmdMgr.h	/^   CMD_OPT_ILLEGAL    = 2,$/;"	e	enum:V3CmdOptionError
CMD_OPT_MISSING	cmd/v3CmdMgr.h	/^   CMD_OPT_MISSING    = 0,$/;"	e	enum:V3CmdOptionError
CMD_TYPE_BDD	cmd/v3CmdMgr.h	/^   CMD_TYPE_BDD         = 11,  \/\/ MODIFICATION FOR SoCV BDD$/;"	e	enum:V3CmdType
CMD_TYPE_COMMON	cmd/v3CmdMgr.h	/^   CMD_TYPE_COMMON      = 1,$/;"	e	enum:V3CmdType
CMD_TYPE_DEBUGFIX	cmd/v3CmdMgr.h	/^   CMD_TYPE_DEBUGFIX    = 10,$/;"	e	enum:V3CmdType
CMD_TYPE_EXTRACT	cmd/v3CmdMgr.h	/^   CMD_TYPE_EXTRACT     = 6,$/;"	e	enum:V3CmdType
CMD_TYPE_IO	cmd/v3CmdMgr.h	/^   CMD_TYPE_IO          = 2,$/;"	e	enum:V3CmdType
CMD_TYPE_MANIP	cmd/v3CmdMgr.h	/^   CMD_TYPE_MANIP       = 5,$/;"	e	enum:V3CmdType
CMD_TYPE_MODELCHKING	cmd/v3CmdMgr.h	/^   CMD_TYPE_MODELCHKING = 9,$/;"	e	enum:V3CmdType
CMD_TYPE_PRINT	cmd/v3CmdMgr.h	/^   CMD_TYPE_PRINT       = 3,$/;"	e	enum:V3CmdType
CMD_TYPE_REVEALED	cmd/v3CmdMgr.h	/^   CMD_TYPE_REVEALED    = 0,$/;"	e	enum:V3CmdType
CMD_TYPE_SIMULATE	cmd/v3CmdMgr.h	/^   CMD_TYPE_SIMULATE    = 7,$/;"	e	enum:V3CmdType
CMD_TYPE_SYNTHESIS	cmd/v3CmdMgr.h	/^   CMD_TYPE_SYNTHESIS   = 4,$/;"	e	enum:V3CmdType
CMD_TYPE_TOTAL	cmd/v3CmdMgr.h	/^   CMD_TYPE_TOTAL       = 12   \/\/ MODIFICATION FOR SoCV BDD$/;"	e	enum:V3CmdType
CMD_TYPE_VERIFY	cmd/v3CmdMgr.h	/^   CMD_TYPE_VERIFY      = 8,$/;"	e	enum:V3CmdType
CMap	eng/minisat/SolverTypes.h	/^class CMap$/;"	c
COBJS	bdd/test/Makefile	/^COBJS     = $(addsuffix .o, $(basename $(CSRCS)))$/;"	m
COBJS	eng/minisat/Makefile	/^COBJS      = $(CSRCS:.cc=.o) $(DSRCS:.cc=.o)$/;"	m
COPTIMIZE	eng/minisat/Makefile	/^COPTIMIZE ?= -O3$/;"	m
CRef	eng/minisat/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t
CRefHash	eng/minisat/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:CMap
CRef_Undef	eng/minisat/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	v
CSRCS	bdd/test/Makefile	/^CSRCS     = $(wildcard *.cpp) $(wildcard *.c)$/;"	m
CSRCS	eng/minisat/Makefile	/^CSRCS      = $(wildcard $(PWD)\/*.cc) $/;"	m
CXX	bdd/test/Makefile	/^CXX       = g++$/;"	m
CXX	bdd/test/Makefile	/^CXX       = g++_new$/;"	m
CXX	eng/minisat/Makefile	/^CXX       ?= g++$/;"	m
Cache	bdd/myHash.h	/^   Cache() : _size(0), _cache(0) {}$/;"	f	class:Cache
Cache	bdd/myHash.h	/^   Cache(size_t s) : _size(0), _cache(0) { init(s); }$/;"	f	class:Cache
Cache	bdd/myHash.h	/^class Cache$/;"	c
Cache	bdd/test/myHash.h	/^   Cache() : _size(0), _cache(0) {}$/;"	f	class:Cache
Cache	bdd/test/myHash.h	/^   Cache(size_t s) : _size(0), _cache(0) { init(s); }$/;"	f	class:Cache
Cache	bdd/test/myHash.h	/^class Cache$/;"	c
CacheNode	bdd/myHash.h	/^typedef pair<CacheKey, CacheData> CacheNode;$/;"	t	class:Cache
CacheNode	bdd/test/myHash.h	/^typedef pair<CacheKey, CacheData> CacheNode;$/;"	t	class:Cache
Clause	eng/minisat/SolverTypes.h	/^    Clause(const Clause& from, bool use_extra){$/;"	f	class:Clause
Clause	eng/minisat/SolverTypes.h	/^    Clause(const vec<Lit>& ps, bool use_extra, bool learnt) {$/;"	f	class:Clause
Clause	eng/minisat/SolverTypes.h	/^class Clause {$/;"	c
ClauseAllocator	eng/minisat/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:ClauseAllocator
ClauseAllocator	eng/minisat/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : ra(start_cap), extra_clause_field(false){}$/;"	f	class:ClauseAllocator
ClauseAllocator	eng/minisat/SolverTypes.h	/^class ClauseAllocator$/;"	c
ClauseIterator	eng/minisat/SolverTypes.h	/^    ClauseIterator(const ClauseAllocator& _ca, const CRef* _crefs) : ca(_ca), crefs(_crefs){}$/;"	f	class:ClauseIterator
ClauseIterator	eng/minisat/SolverTypes.h	/^class ClauseIterator {$/;"	c
DCOBJS	eng/minisat/Makefile	/^DCOBJS     = $(addsuffix d,  $(COBJS))$/;"	m
DIR_MOD_MASK	util/v3FileUtil.h	21;"	d
DO_STD_ITE	bdd/bddMgrV.cpp	104;"	d	file:
DSRCS	eng/minisat/Makefile	/^DSRCS      = $(foreach dir, $(DEPDIR), $(filter-out $(MROOT)\/$(dir)\/Main.cc, $(wildcard $(MROOT)\/$(dir)\/*.cc)))$/;"	m
DeepEqual	eng/minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s
DeepHash	eng/minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s
DoubleOption	eng/minisat/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:DoubleOption
DoubleOption	eng/minisat/Options.h	/^class DoubleOption : public Option$/;"	c
DoubleRange	eng/minisat/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:DoubleRange
DoubleRange	eng/minisat/Options.h	/^struct DoubleRange {$/;"	s
EXEC	bdd/test/Makefile	/^EXEC      = testBdd$/;"	m
EXEC	eng/minisat/Makefile	/^EXEC      ?= $(notdir $(PWD))$/;"	m
EXTHDRS	adt/Makefile	/^EXTHDRS   = v3BitVec.h  v3Graph.h  v3Hash.h  v3Map.h  v3Queue.h  v3Stack.h  v3Bucket.h  v3List.h  v3Misc.h  v3Set.h  v3Vec.h$/;"	m
EXTHDRS	alg/Makefile	/^EXTHDRS   = v3AlgCmd.h  v3AlgGeneralize.h  v3AlgSim.h  v3AlgSimulate.h  v3AlgType.h$/;"	m
EXTHDRS	bdd/Makefile	/^EXTHDRS   = bddMgrV.h bddNodeV.h myHash.h$/;"	m
EXTHDRS	cmd/Makefile	/^EXTHDRS	= v3CmdComm.h v3CmdMgr.h$/;"	m
EXTHDRS	dfx/Makefile	/^EXTHDRS   = v3DfxCmd.h  v3DfxSimplify.h  v3DfxTrace.h$/;"	m
EXTHDRS	ext/Makefile	/^EXTHDRS   = v3ExtType.h  v3ExtUtil.h  v3Formula.h  v3LTLFormula.h  v3NtkElaborate.h  v3Property.h$/;"	m
EXTHDRS	io/Makefile	/^EXTHDRS   = v3NtkParser.h  v3NtkWriter.h$/;"	m
EXTHDRS	main/Makefile	/^EXTHDRS	= $/;"	m
EXTHDRS	ntk/Makefile	/^EXTHDRS   = v3NtkCmd.h v3Ntk.h v3NtkHandler.h v3NtkInput.h v3NtkSimplify.h v3NtkUtil.h v3NtkHash.h v3NtkRewrite.h v3NtkStrash.h v3Type.h$/;"	m
EXTHDRS	prove/Makefile	/^EXTHDRS   = $/;"	m
EXTHDRS	stg/Makefile	/^EXTHDRS   = v3StgCmd.h v3StgExtract.h v3StgFSM.h v3StgSDG.h$/;"	m
EXTHDRS	svr/Makefile	/^EXTHDRS   = v3SvrBase.h  v3SvrBoolector.h  v3SvrHandler.h  v3SvrMiniSat.h  v3SvrSatHelper.h  v3SvrType.h$/;"	m
EXTHDRS	trans/Makefile	/^EXTHDRS   = v3BvBlastAig.h v3BvBlastAigHelper.h v3BvBlastBv.h v3NtkExpand.h v3NtkFlatten.h v3NtkMiter.h v3TransCmd.h$/;"	m
EXTHDRS	util/Makefile	/^EXTHDRS = v3FileUtil.h  v3HashUtil.h  v3IntType.h  v3Msg.h  v3NumUtil.h  v3StrUtil.h  v3Usage.h$/;"	m
EXTHDRS	v3mc/Makefile	/^EXTHDRS   = v3MCCmd.h v3MCEngine.h v3MCMain.h$/;"	m
EXTHDRS	vrf/Makefile	/^EXTHDRS   = v3VrfBase.h v3VrfCmd.h v3VrfIPDR.h v3VrfMPDR.h v3VrfKLive.h v3VrfSIM.h v3VrfCITP.h v3VrfFITP.h v3VrfResult.h v3VrfSEC.h v3VrfUMC.h v3VrfBMC.h v3VrfShared.h$/;"	m
EXTINCDIR	bdd/test/Makefile	/^EXTINCDIR = ..\/..\/..\/include$/;"	m
Equal	eng/minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s
Hash	adt/v3Hash.h	/^   typedef tr1::unordered_map<Key, Data, HashFcn, EqualKey, Alloc> Hash;$/;"	t	struct:V3HashMap
Hash	adt/v3Hash.h	/^   typedef tr1::unordered_set<Key, HashFcn, EqualKey, Alloc> Hash;$/;"	t	struct:V3HashSet
Hash	bdd/myHash.h	/^   Hash() : _numBuckets(0), _buckets(0) {}$/;"	f	class:Hash
Hash	bdd/myHash.h	/^   Hash(size_t b) : _numBuckets(0), _buckets(0) { init(b); }$/;"	f	class:Hash
Hash	bdd/myHash.h	/^class Hash$/;"	c
Hash	bdd/test/myHash.h	/^   Hash() : _numBuckets(0), _buckets(0) {}$/;"	f	class:Hash
Hash	bdd/test/myHash.h	/^   Hash(size_t b) : _numBuckets(0), _buckets(0) { init(b); }$/;"	f	class:Hash
Hash	bdd/test/myHash.h	/^class Hash$/;"	c
Hash	eng/minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s
HashNode	bdd/myHash.h	/^typedef pair<HashKey, HashData> HashNode;$/;"	t	class:Hash
HashNode	bdd/test/myHash.h	/^typedef pair<HashKey, HashData> HashNode;$/;"	t	class:Hash
HashTable	eng/minisat/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:CMap
Heap	eng/minisat/Heap.h	/^    Heap(const Comp& c, MkIndex _index = MkIndex()) : indices(_index), lt(c) {}$/;"	f	class:Heap
Heap	eng/minisat/Heap.h	/^class Heap {$/;"	c
IDX_MASK	adt/v3BitVec.cpp	/^static const unsigned char IDX_MASK[]  = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };$/;"	v	file:
Int64Option	eng/minisat/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Int64Option
Int64Option	eng/minisat/Options.h	/^class Int64Option : public Option$/;"	c
Int64Range	eng/minisat/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Int64Range
Int64Range	eng/minisat/Options.h	/^struct Int64Range {$/;"	s
IntMap	eng/minisat/IntMap.h	/^        explicit IntMap(MkIndex _index = MkIndex()) : index(_index){}$/;"	f	class:IntMap
IntMap	eng/minisat/IntMap.h	/^    class IntMap {$/;"	c
IntOption	eng/minisat/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:IntOption
IntOption	eng/minisat/Options.h	/^class IntOption : public Option$/;"	c
IntRange	eng/minisat/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:IntRange
IntRange	eng/minisat/Options.h	/^struct IntRange {$/;"	s
IntSet	eng/minisat/IntMap.h	/^    class IntSet$/;"	c
Key	eng/minisat/Queue.h	/^    typedef T Key;$/;"	t	class:Queue
LFLAGS	eng/minisat/Makefile	/^LFLAGS    ?= -Wall$/;"	m
LIBDIR	bdd/test/Makefile	/^LIBDIR    = ..\/..\/..\/lib$/;"	m
LMap	eng/minisat/SolverTypes.h	/^template<class T> class LMap : public IntMap<Lit, T, MkIndexLit>{};$/;"	c
LSet	eng/minisat/SolverTypes.h	/^class LSet : public IntSet<Lit, MkIndexLit>{};$/;"	c
LessThan_default	eng/minisat/Sort.h	/^struct LessThan_default {$/;"	s
List	adt/v3List.h	/^   typedef std::list<T> List;$/;"	t	struct:V3List
Lit	eng/minisat/SolverTypes.h	/^struct Lit {$/;"	s
MOD_WORD	adt/v3BitVec.cpp	/^static const unsigned char MOD_WORD    = 0x07;$/;"	v	file:
MSG_DBG	util/v3Msg.h	/^   MSG_DBG = 3,$/;"	e	enum:V3MsgType
MSG_ERR	util/v3Msg.h	/^   MSG_ERR = 1,$/;"	e	enum:V3MsgType
MSG_IFO	util/v3Msg.h	/^   MSG_IFO = 4$/;"	e	enum:V3MsgType
MSG_LOG	util/v3Msg.h	/^   MSG_LOG = 0,$/;"	e	enum:V3MsgType
MSG_WAR	util/v3Msg.h	/^   MSG_WAR = 2,$/;"	e	enum:V3MsgType
MSolver	eng/minisat/Solver.h	/^typedef Solver MSolver;$/;"	t
MYCLK_TCK	util/v3Usage.h	25;"	d
MYCLK_TCK	util/v3Usage.h	26;"	d
MY_HASH_H	bdd/myHash.h	10;"	d
MY_HASH_H	bdd/test/myHash.h	10;"	d
Map	adt/v3Map.h	/^   typedef std::map<Key, Data, Compare, Alloc> Map;$/;"	t	struct:V3Map
Map	eng/minisat/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Map
Map	eng/minisat/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Map
Map	eng/minisat/Map.h	/^class Map {$/;"	c
Minisat_Alg_h	eng/minisat/Alg.h	22;"	d
Minisat_Alloc_h	eng/minisat/Alloc.h	22;"	d
Minisat_Dimacs_h	eng/minisat/Dimacs.h	22;"	d
Minisat_Heap_h	eng/minisat/Heap.h	22;"	d
Minisat_IntMap_h	eng/minisat/IntMap.h	20;"	d
Minisat_IntTypes_h	eng/minisat/IntTypes.h	21;"	d
Minisat_Map_h	eng/minisat/Map.h	21;"	d
Minisat_Options_h	eng/minisat/Options.h	21;"	d
Minisat_ParseUtils_h	eng/minisat/ParseUtils.h	22;"	d
Minisat_Queue_h	eng/minisat/Queue.h	22;"	d
Minisat_Rnd_h	eng/minisat/Rnd.h	20;"	d
Minisat_SolverTypes_h	eng/minisat/SolverTypes.h	23;"	d
Minisat_Solver_h	eng/minisat/Solver.h	22;"	d
Minisat_Sort_h	eng/minisat/Sort.h	22;"	d
Minisat_System_h	eng/minisat/System.h	22;"	d
Minisat_Vec_h	eng/minisat/Vec.h	22;"	d
Minisat_XAlloc_h	eng/minisat/XAlloc.h	22;"	d
MkIndexDefault	eng/minisat/IntMap.h	/^    template<class T> struct MkIndexDefault {$/;"	s
MkIndexLit	eng/minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	s
Msg	main/main.cpp	/^V3MsgMgr Msg;$/;"	v
MsgTypeString	util/v3Msg.h	/^      vector<string> MsgTypeString;$/;"	m	class:V3MsgMgr
Msgs	util/v3Msg.h	/^      vector<V3Msg*> Msgs;$/;"	m	class:V3MsgMgr
OccLists	eng/minisat/SolverTypes.h	/^    OccLists(const Deleted& d, MkIndex _index = MkIndex()) :$/;"	f	class:OccLists
OccLists	eng/minisat/SolverTypes.h	/^class OccLists$/;"	c
Option	eng/minisat/Options.h	/^    Option(const char* name_, $/;"	f	class:Option
Option	eng/minisat/Options.h	/^class Option$/;"	c
OptionLt	eng/minisat/Options.h	/^    struct OptionLt {$/;"	s	class:Option
OutOfMemoryException	eng/minisat/XAlloc.h	/^class OutOfMemoryException{};$/;"	c
P2CMapON	ntk/v3NtkHandler.h	/^      static inline const bool P2CMapON()  { return _extVerbosity & 8ul;  }$/;"	f	class:V3NtkHandler
PCOBJS	eng/minisat/Makefile	/^PCOBJS     = $(addsuffix p,  $(COBJS))$/;"	m
PKGFLAG	adt/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	alg/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	bdd/Makefile	/^PKGFLAG   =$/;"	m
PKGFLAG	cmd/Makefile	/^PKGFLAG	=$/;"	m
PKGFLAG	dfx/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	ext/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	io/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	main/Makefile	/^PKGFLAG	=$/;"	m
PKGFLAG	ntk/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	prove/Makefile	/^PKGFLAG   =$/;"	m
PKGFLAG	stg/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	svr/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	trans/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	util/Makefile	/^PKGFLAG = $/;"	m
PKGFLAG	v3mc/Makefile	/^PKGFLAG   = $/;"	m
PKGFLAG	vrf/Makefile	/^PKGFLAG   = $/;"	m
PROVE_CMD_H_	prove/proveCmd.h	10;"	d
PWD	eng/minisat/Makefile	/^PWD        = $(shell pwd)$/;"	m
Pair	eng/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Map
QUTERTL_HEADER	eng/quteRTL/quteRTL.h	9;"	d
QUTE_ADD_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_ADD_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_AND_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_AND_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_BUF_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_BUF_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_CONST_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_CONST_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_DFF_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_DFF_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_DIV_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_DIV_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_DLAT_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_DLAT_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_EQUALITY_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_EQUALITY_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_GEQ_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_GEQ_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_GREATER_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_GREATER_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_INV_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_INV_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_LEQ_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_LEQ_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_LESS_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_LESS_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MEMORY_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MEMORY_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MERGE_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MERGE_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MODULE_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MODULE_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MODULO_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MODULO_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MULT_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MULT_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_MUX_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_MUX_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_NAND_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_NAND_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_NOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_NOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_OR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_OR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_PIO_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_PIO_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_PI_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_PI_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_PO_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_PO_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_AND_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_AND_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_NAND_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_NAND_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_NOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_NOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_OR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_OR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_XNOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_XNOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_RED_XOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_RED_XOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_SHL_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_SHL_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_SHR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_SHR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_SPLIT_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_SPLIT_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_SUB_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_SUB_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_TOTAL_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_TOTAL_CELL$/;"	e	enum:QuteRTL_API_CellType
QUTE_XNOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_XNOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
QUTE_XOR_CELL	eng/quteRTL/quteRTL.h	/^   QUTE_XOR_CELL,$/;"	e	enum:QuteRTL_API_CellType
Queue	adt/v3Queue.h	/^   typedef std::queue<T> Queue;$/;"	t	struct:V3Queue
Queue	eng/minisat/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Queue
Queue	eng/minisat/Queue.h	/^class Queue {$/;"	c
QuteRTL_API_CellType	eng/quteRTL/quteRTL.h	/^enum QuteRTL_API_CellType$/;"	g
RCOBJS	eng/minisat/Makefile	/^RCOBJS     = $(addsuffix r,  $(COBJS))$/;"	m
Ref	eng/minisat/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:RegionAllocator
Ref_Undef	eng/minisat/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:RegionAllocator::__anon5
RegionAllocator	eng/minisat/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:RegionAllocator
RegionAllocator	eng/minisat/Alloc.h	/^class RegionAllocator$/;"	c
Set	adt/v3Set.h	/^   typedef std::set<Key, Compare, Alloc> Set;$/;"	t	struct:V3Set
ShrinkStackElem	eng/minisat/Solver.h	/^        ShrinkStackElem(uint32_t _i, Lit _l) : i(_i), l(_l){}$/;"	f	struct:Solver::ShrinkStackElem
ShrinkStackElem	eng/minisat/Solver.h	/^    struct ShrinkStackElem {$/;"	s	class:Solver
Size	eng/minisat/Vec.h	/^    typedef _Size Size;$/;"	t	class:vec
Solver	eng/minisat/Solver.h	/^class Solver {$/;"	c
Stack	adt/v3Stack.h	/^   typedef std::stack<T> Stack;$/;"	t	struct:V3Stack
StdEndLine	util/v3Msg.h	/^      typedef ostream& (*StdEndLine)(ostream&);  \/\/ overload operator << for std::endl$/;"	t	class:V3Msg
StreamBuffer	eng/minisat/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0){$/;"	f	class:StreamBuffer
StreamBuffer	eng/minisat/ParseUtils.h	/^class StreamBuffer {$/;"	c
StringOption	eng/minisat/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:StringOption
StringOption	eng/minisat/Options.h	/^class StringOption : public Option$/;"	c
TARGET	main/Makefile	/^TARGET	= ..\/..\/$(EXEC)$/;"	m
TrailIterator	eng/minisat/SolverTypes.h	/^    TrailIterator(const Lit* _lits) : lits(_lits){}$/;"	f	class:TrailIterator
TrailIterator	eng/minisat/SolverTypes.h	/^class TrailIterator {$/;"	c
Unit_Size	eng/minisat/Alloc.h	/^    enum { Unit_Size = sizeof(T) };$/;"	e	enum:RegionAllocator::__anon6
Unit_Size	eng/minisat/SolverTypes.h	/^    enum { Unit_Size = RegionAllocator<uint32_t>::Unit_Size };$/;"	e	enum:ClauseAllocator::__anon3
V3AigNtk	ntk/v3Ntk.h	/^typedef V3Ntk     V3AigNtk;$/;"	t
V3AigParser	io/v3AigParser.cpp	/^V3NtkInput* const V3AigParser(const char* fileName, const bool& symbol) {$/;"	f
V3AigSDG	stg/v3StgSDG.cpp	/^V3AigSDG::V3AigSDG(V3NtkHandler* const handler) : V3SDG(handler) {$/;"	f	class:V3AigSDG
V3AigSDG	stg/v3StgSDG.h	/^class V3AigSDG : public V3SDG {$/;"	c
V3AigSimDataVec	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecS>::Vec             V3AigSimDataVec;$/;"	t
V3AigSimRecord	alg/v3AlgType.h	/^typedef pair<V3NetId, V3BitVecS>          V3AigSimRecord;$/;"	t
V3AigSimRecordVec	alg/v3AlgType.h	/^typedef V3Vec<V3AigSimRecord>::Vec        V3AigSimRecordVec;$/;"	t
V3AigSimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3AigSimDataVec>::Vec       V3AigSimTraceVec;$/;"	t
V3AigWriter	io/v3AigWriter.cpp	/^void V3AigWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol) {$/;"	f
V3AlgAigGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::V3AlgAigGeneralize(const V3NtkHandler* const handler) : V3AlgAigSimulate(handler), V3AlgGeneralize() {$/;"	f	class:V3AlgAigGeneralize
V3AlgAigGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgAigGeneralize : public V3AlgAigSimulate, public V3AlgGeneralize {$/;"	c
V3AlgAigSimulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::V3AlgAigSimulate(const V3NtkHandler* const handler) : V3AlgSimulate(handler) {$/;"	f	class:V3AlgAigSimulate
V3AlgAigSimulate	alg/v3AlgSimulate.h	/^class V3AlgAigSimulate : public V3AlgSimulate$/;"	c
V3AlgBvGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::V3AlgBvGeneralize(const V3NtkHandler* const handler) : V3AlgBvSimulate(handler), V3AlgGeneralize() {$/;"	f	class:V3AlgBvGeneralize
V3AlgBvGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgBvGeneralize : public V3AlgBvSimulate, public V3AlgGeneralize {$/;"	c
V3AlgBvSimulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::V3AlgBvSimulate(const V3NtkHandler* const handler) : V3AlgSimulate(handler) {$/;"	f	class:V3AlgBvSimulate
V3AlgBvSimulate	alg/v3AlgSimulate.h	/^class V3AlgBvSimulate : public V3AlgSimulate$/;"	c
V3AlgGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::V3AlgGeneralize() {$/;"	f	class:V3AlgGeneralize
V3AlgGeneralize	alg/v3AlgGeneralize.h	/^class V3AlgGeneralize {$/;"	c
V3AlgSimulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::V3AlgSimulate(const V3NtkHandler* const handler) : _handler(handler) {$/;"	f	class:V3AlgSimulate
V3AlgSimulate	alg/v3AlgSimulate.h	/^class V3AlgSimulate$/;"	c
V3AsyncDFFName	ntk/v3Type.h	/^const string V3AsyncDFFName   = "v3_Async_FF_Net_";$/;"	v
V3AsyncMuxName	ntk/v3Type.h	/^const string V3AsyncMuxName   = "v3_Async_MUX_Net_";$/;"	v
V3AuxExpansionName	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxExpansionName   = V3ExpansionName;$/;"	m	class:V3NtkHandler	file:
V3AuxExpansionName	ntk/v3NtkHandler.h	/^      static string        V3AuxExpansionName;$/;"	m	class:V3NtkHandler
V3AuxHierSeparator	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxHierSeparator   = V3HierSeparator;$/;"	m	class:V3NtkHandler	file:
V3AuxHierSeparator	ntk/v3NtkHandler.h	/^      static string        V3AuxHierSeparator;$/;"	m	class:V3NtkHandler
V3AuxNameBitPrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameBitPrefix   = V3NameBitPrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameBitPrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameBitPrefix;$/;"	m	class:V3NtkHandler
V3AuxNameBitSuffix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameBitSuffix   = V3NameBitSuffix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameBitSuffix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameBitSuffix;$/;"	m	class:V3NtkHandler
V3AuxNameInvPrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNameInvPrefix   = V3NameInvPrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNameInvPrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNameInvPrefix;$/;"	m	class:V3NtkHandler
V3AuxNetNamePrefix	ntk/v3NtkHandler.cpp	/^string V3NtkHandler::V3AuxNetNamePrefix   = V3NetNamePrefix;$/;"	m	class:V3NtkHandler	file:
V3AuxNetNamePrefix	ntk/v3NtkHandler.h	/^      static string        V3AuxNetNamePrefix;$/;"	m	class:V3NtkHandler
V3BVXId	ntk/v3Ntk.h	/^typedef uint32_t     V3BVXId;$/;"	t
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const V3BitVec& b) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const char* exp) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::V3BitVec(const unsigned& s) {$/;"	f	class:V3BitVec
V3BitVec	adt/v3BitVec.h	/^class V3BitVec$/;"	c
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS() { clear(); }$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const V3BitVecS& v) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const V3BitVecX& v) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::V3BitVecS(const uint64_t& zeros, const uint64_t& ones) {$/;"	f	class:V3BitVecS
V3BitVecS	adt/v3BitVec.h	/^class V3BitVecS$/;"	c
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVec& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVecS& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const V3BitVecX& b) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::V3BitVecX(const unsigned& s) {$/;"	f	class:V3BitVecX
V3BitVecX	adt/v3BitVec.h	/^class V3BitVecX$/;"	c
V3BitVecXVec	ntk/v3Ntk.h	/^typedef V3Vec<V3BitVecX*   >::Vec   V3BitVecXVec;$/;"	t
V3BoolTable	adt/v3Misc.h	/^typedef V3Vec<V3BoolVec >::Vec   V3BoolTable;$/;"	t
V3BoolVec	adt/v3Misc.h	/^typedef V3Vec<bool      >::Vec   V3BoolVec;$/;"	t
V3BtorExpTable	svr/v3SvrType.h	/^typedef V3Vec<V3BtorExpVec>::Vec    V3BtorExpTable;$/;"	t
V3BtorExpVec	svr/v3SvrType.h	/^typedef V3Vec<BtorExp*>::Vec        V3BtorExpVec;$/;"	t
V3BtorLexVec	io/v3BtorParser.cpp	/^typedef V3Vec<string>::Vec    V3BtorLexVec;$/;"	t	file:
V3BtorParser	io/v3BtorParser.cpp	/^V3NtkInput* const V3BtorParser(const char* fileName, const bool& symbol) {$/;"	f
V3BtorWriter	io/v3BtorWriter.cpp	/^void V3BtorWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol) {$/;"	f
V3BucketList	adt/v3Bucket.h	/^      V3BucketList(const uint32_t& size = 0) { _size = 0; _bestIndex = 0; _elements.clear(); init(size); }$/;"	f	class:V3BucketList
V3BucketList	adt/v3Bucket.h	/^class V3BucketList {$/;"	c
V3BusId	ntk/v3Ntk.h	/^typedef uint32_t     V3BusId;$/;"	t
V3BusIdHash	ntk/v3Ntk.h	/^typedef V3HashMap<uint64_t,   V3BusId>::Hash V3BusIdHash;$/;"	t
V3BusPair	ntk/v3Ntk.h	/^typedef V3PairType   V3BusPair;$/;"	t
V3BusPairVec	ntk/v3Ntk.h	/^typedef V3Vec<V3BusPair    >::Vec   V3BusPairVec;$/;"	t
V3BvBlastAig	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::V3BvBlastAig(V3NtkHandler* const p) $/;"	f	class:V3BvBlastAig
V3BvBlastAig	trans/v3BvBlastAig.h	/^class V3BvBlastAig : public V3NtkHandler$/;"	c
V3BvBlastBv	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::V3BvBlastBv(V3NtkHandler* const p) : V3NtkHandler(p) {$/;"	f	class:V3BvBlastBv
V3BvBlastBv	trans/v3BvBlastBv.h	/^class V3BvBlastBv : public V3NtkHandler$/;"	c
V3BvBlastBvMap	trans/v3BvBlastBv.h	/^typedef V3Map<uint32_t, uint32_t>::Map    V3BvBlastBvMap;$/;"	t
V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::V3BvNtk() : V3Ntk() {$/;"	f	class:V3BvNtk
V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::V3BvNtk(const V3BvNtk& ntk) : V3Ntk(ntk) {$/;"	f	class:V3BvNtk
V3BvNtk	ntk/v3Ntk.h	/^class V3BvNtk : public V3Ntk$/;"	c
V3BvSimDataVec	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecX>::Vec             V3BvSimDataVec;$/;"	t
V3BvSimNetId	alg/v3AlgType.h	/^typedef pair<V3NetId, uint32_t>           V3BvSimNetId;$/;"	t
V3BvSimNetVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimNetId>::Vec          V3BvSimNetVec;$/;"	t
V3BvSimRecord	alg/v3AlgType.h	/^typedef pair<V3NetId, V3BitVecX>          V3BvSimRecord;$/;"	t
V3BvSimRecordVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimRecord>::Vec         V3BvSimRecordVec;$/;"	t
V3BvSimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3BvSimDataVec>::Vec        V3BvSimTraceVec;$/;"	t
V3CITPCube	vrf/v3VrfCITP.h	/^      V3CITPCube(const V3CITPCube& c) : _nextCube(0) { _stateId = c._stateId; _signature = c._signature; }$/;"	f	class:V3CITPCube
V3CITPCube	vrf/v3VrfCITP.h	/^      V3CITPCube(const V3CITPCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3CITPCube
V3CITPCube	vrf/v3VrfCITP.h	/^class V3CITPCube$/;"	c
V3CITPCubeCompare	vrf/v3VrfCITP.h	/^struct V3CITPCubeCompare {$/;"	s
V3CITPCubeList	vrf/v3VrfCITP.h	/^typedef V3Set<V3CITPCube*, V3CITPCubeCompare>::Set   V3CITPCubeList;$/;"	t
V3CITPFrame	vrf/v3VrfCITP.cpp	/^V3CITPFrame::V3CITPFrame() {$/;"	f	class:V3CITPFrame
V3CITPFrame	vrf/v3VrfCITP.h	/^class V3CITPFrame$/;"	c
V3CITPFrameVec	vrf/v3VrfCITP.h	/^typedef V3Vec<V3CITPFrame*>::Vec          V3CITPFrameVec;$/;"	t
V3CexTrace	ext/v3Property.h	/^      V3CexTrace(const uint32_t& s) : _size(s) { _init = 0; _data.clear(); _data.reserve(s); }$/;"	f	class:V3CexTrace
V3CexTrace	ext/v3Property.h	/^class V3CexTrace$/;"	c
V3CexTraceParser	ext/v3ExtIO.cpp	/^V3CexTrace* const V3CexTraceParser(const V3NtkHandler* const handler, const string& fileName) {$/;"	f
V3CexTraceVisualizer	ext/v3ExtIO.cpp	/^void V3CexTraceVisualizer(const V3NtkHandler* const handler, const V3CexTrace* const cex, const string& fileName) {$/;"	f
V3CexTraceWriter	ext/v3ExtIO.cpp	/^void V3CexTraceWriter(const V3NtkHandler* const handler, const V3CexTrace* const cex, const string& fileName) {$/;"	f
V3CmdCompare	cmd/v3CmdMgr.h	/^struct V3CmdCompare { bool operator() (const V3CmdExec* a, const V3CmdExec* b) const { return (*a < *b); } };$/;"	s
V3CmdExec	cmd/v3CmdMgr.h	/^      V3CmdExec(V3CmdType t) : _cmdType(t) {}$/;"	f	class:V3CmdExec
V3CmdExec	cmd/v3CmdMgr.h	/^class V3CmdExec$/;"	c
V3CmdExecSet	cmd/v3CmdMgr.h	/^typedef map<V3CmdType, V3CmdExecSubSet*>  V3CmdExecSet;$/;"	t
V3CmdExecStatus	cmd/v3CmdMgr.h	/^enum V3CmdExecStatus$/;"	g
V3CmdExecSubSet	cmd/v3CmdMgr.h	/^typedef set<V3CmdExec*, V3CmdCompare>     V3CmdExecSubSet;$/;"	t
V3CmdMgr	cmd/v3CmdMgr.cpp	/^V3CmdMgr::V3CmdMgr(const string& p) : _defaultPrompt(p) {$/;"	f	class:V3CmdMgr
V3CmdMgr	cmd/v3CmdMgr.h	/^class V3CmdMgr $/;"	c
V3CmdOptionError	cmd/v3CmdMgr.h	/^enum V3CmdOptionError$/;"	g
V3CmdType	cmd/v3CmdMgr.h	/^enum V3CmdType$/;"	g
V3CmdTypeString	cmd/v3CmdMgr.h	/^const string V3CmdTypeString[] = {$/;"	v
V3ConstHash	ntk/v3Ntk.h	/^typedef V3HashMap<string,     V3BVXId>::Hash V3ConstHash;$/;"	t
V3Constraint	ext/v3Property.cpp	/^V3Constraint::V3Constraint(V3NtkHandler* const handler, V3FSM* const fsm) $/;"	f	class:V3Constraint
V3Constraint	ext/v3Property.cpp	/^V3Constraint::V3Constraint(V3NtkHandler* const handler, const uint32_t& start, const uint32_t& end) $/;"	f	class:V3Constraint
V3Constraint	ext/v3Property.h	/^class V3Constraint$/;"	c
V3ConstraintVec	ext/v3Property.h	/^typedef V3Vec<V3Constraint*>::Vec   V3ConstraintVec;$/;"	t
V3DblMAX	util/v3IntType.h	/^const double   V3DblMAX    = DBL_MAX;$/;"	v
V3DblVec	adt/v3Misc.h	/^typedef V3Vec<double    >::Vec   V3DblVec;$/;"	t
V3DfxCube	dfx/v3DfxTrace.h	/^      V3DfxCube(const uint32_t& f) : _frameId(f) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3DfxCube
V3DfxCube	dfx/v3DfxTrace.h	/^class V3DfxCube$/;"	c
V3DfxCubeCompare	dfx/v3DfxTrace.h	/^struct V3DfxCubeCompare {$/;"	s
V3DfxCubeList	dfx/v3DfxTrace.h	/^typedef V3Set<V3DfxCube*, V3DfxCubeCompare>::Set      V3DfxCubeList;$/;"	t
V3DirectedEdge	adt/v3Graph.h	/^   typedef pair<V3UI32Set, V3UI32Set>              V3DirectedEdge;$/;"	t	class:V3Graph
V3DirectedNode	adt/v3Graph.h	/^   typedef pair<T, V3DirectedEdge>                 V3DirectedNode;$/;"	t	class:V3Graph
V3ExpansionName	ntk/v3Type.h	/^const string V3ExpansionName  = "@";$/;"	v
V3FITPCube	vrf/v3VrfFITP.h	/^      V3FITPCube(const V3FITPCube& c) : _nextCube(0) { _stateId = c._stateId; _signature = c._signature; }$/;"	f	class:V3FITPCube
V3FITPCube	vrf/v3VrfFITP.h	/^      V3FITPCube(const V3FITPCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3FITPCube
V3FITPCube	vrf/v3VrfFITP.h	/^class V3FITPCube$/;"	c
V3FITPCubeCompare	vrf/v3VrfFITP.h	/^struct V3FITPCubeCompare {$/;"	s
V3FITPCubeList	vrf/v3VrfFITP.h	/^typedef V3Set<V3FITPCube*, V3FITPCubeCompare>::Set   V3FITPCubeList;$/;"	t
V3FITPFrame	vrf/v3VrfFITP.cpp	/^V3FITPFrame::V3FITPFrame() {$/;"	f	class:V3FITPFrame
V3FITPFrame	vrf/v3VrfFITP.h	/^class V3FITPFrame$/;"	c
V3FITPFrameVec	vrf/v3VrfFITP.h	/^typedef V3Vec<V3FITPFrame*>::Vec          V3FITPFrameVec;$/;"	t
V3FITPSvrData	vrf/v3VrfFITP.h	/^typedef V3Vec<size_t>::Vec                V3FITPSvrData;$/;"	t
V3FSM	stg/v3StgFSM.cpp	/^V3FSM::V3FSM(V3FSMSDGDB* const sdgDB, V3SvrBase* const solver) $/;"	f	class:V3FSM
V3FSM	stg/v3StgFSM.h	/^class V3FSM {$/;"	c
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const V3NetVec& outputs, const V3NetVec& targets) $/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const V3NetVec& targets) : _handler(handler),$/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::V3FSMExtract(V3NtkHandler* const handler, const string& fileName, const V3NetVec& targets) $/;"	f	class:V3FSMExtract
V3FSMExtract	stg/v3StgExtract.h	/^class V3FSMExtract {$/;"	c
V3FSMMap	ntk/v3NtkHandler.h	/^typedef V3Map<string, V3FSMExtract*>::Map V3FSMMap;$/;"	t
V3FSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::V3FSMSDG(const V3NetId& id) : _netId(id) {$/;"	f	class:V3FSMSDG
V3FSMSDG	stg/v3StgFSM.h	/^class V3FSMSDG {$/;"	c
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3NtkHandler* const handler, const V3StrTable& sdgSpec)$/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3SDG* const sdgMain, const V3NetVec& depVarList, V3SvrBase* const solver) $/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::V3FSMSDGDB(V3SDG* const sdgMain, const V3NetVec& depVarList, const V3SolverType& solverType) $/;"	f	class:V3FSMSDGDB
V3FSMSDGDB	stg/v3StgFSM.h	/^class V3FSMSDGDB {$/;"	c
V3FSMSDGDBList	stg/v3StgExtract.h	/^typedef V3Vec<V3FSMSDGDB*>::Vec     V3FSMSDGDBList;$/;"	t
V3FSMSDGList	stg/v3StgFSM.h	/^typedef V3Vec<V3FSMSDG*>::Vec             V3FSMSDGList;$/;"	t
V3FSMSDGMap	stg/v3StgFSM.h	/^typedef V3Map<uint32_t, V3FSMSDG*>::Map   V3FSMSDGMap;$/;"	t
V3FSMSDGSet	stg/v3StgFSM.h	/^typedef V3Set<V3FSMSDG*>::Set             V3FSMSDGSet;$/;"	t
V3FSMVec	stg/v3StgExtract.h	/^typedef V3Vec<V3FSM*>::Vec          V3FSMVec;$/;"	t
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const V3NetId& id) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const V3SimTraceVec& cexTrace, const double& strength) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const string& formulaExp) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(V3NtkHandler* const handler, const uint32_t& constrSize, const uint32_t& maxCard, const V3GateType& gateType, const uint32_t& noPIorFF) : _handler(handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.cpp	/^V3Formula::V3Formula(const V3Formula& formula) : _handler(formula._handler) {$/;"	f	class:V3Formula
V3Formula	ext/v3Formula.h	/^class V3Formula$/;"	c
V3FormulaList	ext/v3Formula.h	/^      typedef V3Vec<V3FormulaNode>::Vec      V3FormulaList;$/;"	t	class:V3Formula
V3FormulaNode	ext/v3Formula.h	/^      typedef pair<V3GateType, V3InputVec>   V3FormulaNode;$/;"	t	class:V3Formula
V3GateType	ntk/v3Type.h	/^enum V3GateType {$/;"	g
V3GateTypeStr	ntk/v3Type.h	/^const string V3GateTypeStr[] = {$/;"	v
V3GenBucket	alg/v3AlgGeneralize.cpp	/^V3GenBucket::V3GenBucket(const uint32_t& maxBucket, const uint32_t& maxData) {$/;"	f	class:V3GenBucket
V3GenBucket	alg/v3AlgGeneralize.h	/^class V3GenBucket {$/;"	c
V3GenComp	alg/v3AlgGeneralize.h	/^      struct V3GenComp {$/;"	s	class:V3GenStruct
V3GenCubeList	alg/v3AlgGeneralize.h	/^      typedef V3Vec<V3UI32Set>::Vec                V3GenCubeList;$/;"	t	class:V3GenStruct
V3GenStruct	alg/v3AlgGeneralize.cpp	/^V3GenStruct::V3GenStruct(const uint32_t& varSize, const V3NetVec& baseCube) {$/;"	f	class:V3GenStruct
V3GenStruct	alg/v3AlgGeneralize.h	/^class V3GenStruct {$/;"	c
V3GenVarOrder	alg/v3AlgGeneralize.h	/^      typedef V3Set<V3GenVarPair, V3GenComp>::Set  V3GenVarOrder;$/;"	t	class:V3GenStruct
V3GenVarPair	alg/v3AlgGeneralize.h	/^      typedef pair<V3NetId, uint32_t>              V3GenVarPair;$/;"	t	class:V3GenStruct
V3Graph	adt/v3Graph.h	/^V3Graph<T>::V3Graph() { clearGraph(); }$/;"	f	class:V3Graph
V3Graph	adt/v3Graph.h	/^class V3Graph {$/;"	c
V3Handler	ntk/v3NtkHandler.cpp	/^V3Handler::V3Handler() {$/;"	f	class:V3Handler
V3Handler	ntk/v3NtkHandler.h	/^class V3Handler$/;"	c
V3HandlerVec	ntk/v3NtkHandler.h	/^typedef V3Vec<V3NtkHandler*>::Vec         V3HandlerVec;$/;"	t
V3HashMap	adt/v3Hash.h	/^struct V3HashMap {$/;"	s
V3HashSet	adt/v3Hash.h	/^struct V3HashSet {$/;"	s
V3HierSeparator	ntk/v3Type.h	/^const string V3HierSeparator  = ".";$/;"	v
V3IPDRCube	vrf/v3VrfIPDR.h	/^      V3IPDRCube(const V3IPDRCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3IPDRCube
V3IPDRCube	vrf/v3VrfIPDR.h	/^class V3IPDRCube$/;"	c
V3IPDRCubeCompare	vrf/v3VrfIPDR.h	/^struct V3IPDRCubeCompare {$/;"	s
V3IPDRCubeList	vrf/v3VrfIPDR.h	/^typedef V3Set<V3IPDRCube*, V3IPDRCubeCompare>::Set   V3IPDRCubeList;$/;"	t
V3IPDRFrame	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::V3IPDRFrame() {$/;"	f	class:V3IPDRFrame
V3IPDRFrame	vrf/v3VrfIPDR.h	/^class V3IPDRFrame$/;"	c
V3IPDRFrameVec	vrf/v3VrfIPDR.h	/^typedef V3Vec<V3IPDRFrame*>::Vec             V3IPDRFrameVec;$/;"	t
V3IPDRSvrList	vrf/v3VrfIPDR.h	/^typedef V3Vec<V3SvrBase*>::Vec               V3IPDRSvrList;$/;"	t
V3IPDRTimedCube	vrf/v3VrfIPDR.h	/^typedef pair<uint32_t, V3IPDRCube*>          V3IPDRTimedCube;$/;"	t
V3IdxStrHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<uint32_t, string>::Hash V3IdxStrHash;$/;"	t
V3IncBucketList	adt/v3Bucket.h	/^      V3IncBucketList(const uint32_t& size = 0) { _size = 0; _bestIndex = 0; _elements.clear(); init(size); }$/;"	f	class:V3IncBucketList
V3IncBucketList	adt/v3Bucket.h	/^class V3IncBucketList {$/;"	c
V3IndexField	adt/v3Graph.h	/^   typedef typename V3Vec<V3UI32Set>::Vec          V3IndexField;$/;"	t	class:V3Graph
V3IndexFlow	adt/v3Graph.h	/^   typedef typename V3Queue<V3UI32Queue>::Queue    V3IndexFlow;$/;"	t	class:V3Graph
V3InputTable	ntk/v3Ntk.h	/^typedef V3Vec<V3InputVec   >::Vec   V3InputTable;$/;"	t
V3InputVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NetType    >::Vec   V3InputVec;$/;"	t
V3IntMAX	util/v3IntType.h	/^const uint32_t V3IntMAX    = UINT_MAX;$/;"	v
V3IntVec	adt/v3Misc.h	/^typedef V3Vec<int       >::Vec   V3IntVec;$/;"	t
V3L2SAssertName	ext/v3ExtType.h	/^const string V3L2SAssertName  = V3L2SPrefix + "Assertion_";$/;"	v
V3L2SGeneralID	ext/v3ExtType.h	/^const string V3L2SGeneralID   = V3L2SPrefix + v3Int2Str(time(NULL));$/;"	v
V3L2SInLoopName	ext/v3ExtType.h	/^const string V3L2SInLoopName  = V3L2SGeneralID + "_InLoop_Latch";$/;"	v
V3L2SLatchONName	ext/v3ExtType.h	/^const string V3L2SLatchONName = V3L2SGeneralID + "_Shadow_Latch_ON";$/;"	v
V3L2SLoopedName	ext/v3ExtType.h	/^const string V3L2SLoopedName  = V3L2SGeneralID + "_Looped";$/;"	v
V3L2SOracleName	ext/v3ExtType.h	/^const string V3L2SOracleName  = V3L2SGeneralID + "_Loop_Oracle";$/;"	v
V3L2SPCheckName	ext/v3ExtType.h	/^const string V3L2SPCheckName  = V3L2SPrefix + "F_not_P_Latch_";$/;"	v
V3L2SPrefix	ext/v3ExtType.h	/^const string V3L2SPrefix      = "v3_L2S_";$/;"	v
V3L2SShadowName	ext/v3ExtType.h	/^const string V3L2SShadowName  = V3L2SPrefix + "Shadow_Latch_";$/;"	v
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(V3NtkHandler* const handler, const V3NetId& id, const bool& safe, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(V3NtkHandler* const handler, const string& ltlFormulaExp, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::V3LTLFormula(const V3LTLFormula& ltlFormula, const string& name) $/;"	f	class:V3LTLFormula
V3LTLFormula	ext/v3LTLFormula.h	/^class V3LTLFormula$/;"	c
V3LTLFormulaList	ext/v3LTLFormula.h	/^      typedef V3Vec<V3LTLFormulaNode>::Vec   V3LTLFormulaList;$/;"	t	class:V3LTLFormula
V3LTLFormulaNode	ext/v3LTLFormula.h	/^      typedef pair<V3LTLOpType, V3PtrVec>    V3LTLFormulaNode;$/;"	t	class:V3LTLFormula
V3LTLFormulaVec	ext/v3NtkElaborate.h	/^      typedef V3Vec<V3LTLFormula*>::Vec   V3LTLFormulaVec;$/;"	t	class:V3NtkElaborate
V3LTLOpType	ext/v3LTLFormula.h	/^enum V3LTLOpType {$/;"	g
V3List	adt/v3List.h	/^struct V3List {$/;"	s
V3LivenessPrefix	ext/v3ExtType.h	/^const string V3LivenessPrefix = "v3_Liveness_";$/;"	v
V3MCEngineList	v3mc/v3MCMain.h	/^typedef V3Vec<V3MCEngineType>::Vec        V3MCEngineList;$/;"	t
V3MCEngineType	v3mc/v3MCEngine.h	/^enum V3MCEngineType$/;"	g
V3MCEngineTypeStr	v3mc/v3MCEngine.h	/^const string V3MCEngineTypeStr[] = $/;"	v
V3MCMainParam	v3mc/v3MCMain.h	/^struct V3MCMainParam$/;"	s
V3MCMainType	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	g
V3MCMainTypeStr	v3mc/v3MCMain.h	/^const string V3MCMainTypeStr[] = { "V3MC_SAFE", "V3MC_LIVE", "V3MC_L2S", "V3MC_TYPE_TOTAL" };$/;"	v
V3MCParam	v3mc/v3MCMain.h	/^struct V3MCParam$/;"	s
V3MCResource	v3mc/v3MCMain.cpp	/^V3MCResource::V3MCResource(const V3UI32Vec& c, const V3UI32Vec& p) : V3VrfShared() {$/;"	f	class:V3MCResource
V3MCResource	v3mc/v3MCMain.h	/^class V3MCResource : public V3VrfShared$/;"	c
V3MCResult	v3mc/v3MCMain.cpp	/^V3MCResult::V3MCResult(const uint32_t& size) {$/;"	f	class:V3MCResult
V3MCResult	v3mc/v3MCMain.h	/^class V3MCResult : public V3VrfShared$/;"	c
V3MC_BMC	v3mc/v3MCEngine.h	/^   V3MC_BMC,$/;"	e	enum:V3MCEngineType
V3MC_CITP	v3mc/v3MCEngine.h	/^   V3MC_CITP,$/;"	e	enum:V3MCEngineType
V3MC_CITP_F_I	v3mc/v3MCEngine.h	/^   V3MC_CITP_F_I,$/;"	e	enum:V3MCEngineType
V3MC_CITP_I	v3mc/v3MCEngine.h	/^   V3MC_CITP_I,$/;"	e	enum:V3MCEngineType
V3MC_CITP_REC	v3mc/v3MCEngine.h	/^   V3MC_CITP_REC,$/;"	e	enum:V3MCEngineType
V3MC_FITP	v3mc/v3MCEngine.h	/^   V3MC_FITP,$/;"	e	enum:V3MCEngineType
V3MC_IDLE	v3mc/v3MCEngine.h	/^   V3MC_IDLE = 0,$/;"	e	enum:V3MCEngineType
V3MC_IND	v3mc/v3MCEngine.h	/^   V3MC_IND,$/;"	e	enum:V3MCEngineType
V3MC_IPDR	v3mc/v3MCEngine.h	/^   V3MC_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_CITP	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_CITP,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_CITP_REC	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_CITP_REC,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_FITP	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_FITP,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_IPDR	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_KLIVE_MPDR	v3mc/v3MCEngine.h	/^   V3MC_KLIVE_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_L2S	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_LIVE	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_MPDR	v3mc/v3MCEngine.h	/^   V3MC_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SAFE	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_SEC_BMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_BMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_IPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_MPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_BMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_BMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_IPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_IPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_MPDR	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_MPDR,$/;"	e	enum:V3MCEngineType
V3MC_SEC_SYN_UMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_SYN_UMC,$/;"	e	enum:V3MCEngineType
V3MC_SEC_UMC	v3mc/v3MCEngine.h	/^   V3MC_SEC_UMC,$/;"	e	enum:V3MCEngineType
V3MC_SIM	v3mc/v3MCEngine.h	/^   V3MC_SIM,$/;"	e	enum:V3MCEngineType
V3MC_TOTAL	v3mc/v3MCEngine.h	/^   V3MC_TOTAL$/;"	e	enum:V3MCEngineType
V3MC_TYPE_TOTAL	v3mc/v3MCMain.h	/^enum V3MCMainType { V3MC_SAFE = 0, V3MC_LIVE, V3MC_L2S, V3MC_TYPE_TOTAL };$/;"	e	enum:V3MCMainType
V3MC_UBC	v3mc/v3MCEngine.h	/^   V3MC_UBC,$/;"	e	enum:V3MCEngineType
V3MC_UMC	v3mc/v3MCEngine.h	/^   V3MC_UMC,$/;"	e	enum:V3MCEngineType
V3MPDRCube	vrf/v3VrfMPDR.h	/^      V3MPDRCube(const V3MPDRCube* const c) : _nextCube(c) { _stateId.clear(); _signature = 0; }$/;"	f	class:V3MPDRCube
V3MPDRCube	vrf/v3VrfMPDR.h	/^class V3MPDRCube$/;"	c
V3MPDRCubeCompare	vrf/v3VrfMPDR.h	/^struct V3MPDRCubeCompare {$/;"	s
V3MPDRCubeList	vrf/v3VrfMPDR.h	/^typedef V3Set<V3MPDRCube*, V3MPDRCubeCompare>::Set   V3MPDRCubeList;$/;"	t
V3MPDRFrame	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::V3MPDRFrame(const V3SvrData& a) : _activator(a) {$/;"	f	class:V3MPDRFrame
V3MPDRFrame	vrf/v3VrfMPDR.h	/^class V3MPDRFrame$/;"	c
V3MPDRFrameVec	vrf/v3VrfMPDR.h	/^typedef V3Vec<V3MPDRFrame*>::Vec          V3MPDRFrameVec;$/;"	t
V3MPDRTimedCube	vrf/v3VrfMPDR.h	/^typedef pair<uint32_t, V3MPDRCube*>       V3MPDRTimedCube;$/;"	t
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(const size_t a, const size_t b) {$/;"	f
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(const string& s) {$/;"	f
V3MakeHash	util/v3HashUtil.h	/^static inline size_t V3MakeHash(size_t a) {$/;"	f
V3Map	adt/v3Map.h	/^struct V3Map {$/;"	s
V3MiscType	ntk/v3Type.h	/^   V3MiscType(uint32_t t = 0, uint32_t m = 0) { type = t; misc = m; }$/;"	f	struct:V3MiscType
V3MiscType	ntk/v3Type.h	/^struct V3MiscType {  \/\/ 4 Bytes$/;"	s
V3Msg	util/v3Msg.h	/^      V3Msg(ostream& os) : _default(os) { _defaultON = true; _filename = ""; }$/;"	f	class:V3Msg
V3Msg	util/v3Msg.h	/^class V3Msg$/;"	c
V3MsgMgr	util/v3Msg.h	/^      V3MsgMgr() {$/;"	f	class:V3MsgMgr
V3MsgMgr	util/v3Msg.h	/^class V3MsgMgr$/;"	c
V3MsgType	util/v3Msg.h	/^enum V3MsgType$/;"	g
V3MuxEqual	ntk/v3NtkHash.h	/^typedef V3PairHashEqual<uint64_t, uint32_t>  V3MuxEqual;$/;"	t
V3MuxFcn	ntk/v3NtkHash.h	/^typedef V3PairHashFcn<uint64_t, uint32_t>    V3MuxFcn;$/;"	t
V3MuxHash	ntk/v3NtkHash.h	/^typedef V3HashMap<V3MuxKey,   V3NetId, V3MuxFcn, V3MuxEqual>::Hash   V3MuxHash;$/;"	t
V3MuxKey	ntk/v3NtkHash.h	/^typedef pair<uint64_t, uint32_t>             V3MuxKey;$/;"	t
V3MuxNetType2HashKey	ntk/v3NtkHash.h	/^inline const V3MuxKey V3MuxNetType2HashKey(const V3NetType& fId, const V3NetType& tId, const V3NetType& sId) {$/;"	f
V3NameBitPrefix	ntk/v3Type.h	/^const string V3NameBitPrefix  = "[";$/;"	v
V3NameBitSuffix	ntk/v3Type.h	/^const string V3NameBitSuffix  = "]";$/;"	v
V3NameInvPrefix	ntk/v3Type.h	/^const string V3NameInvPrefix  = "~";$/;"	v
V3NetId	ntk/v3Type.h	/^struct V3NetId {  \/\/ 4 Bytes$/;"	s
V3NetList	alg/v3AlgGeneralize.h	/^typedef V3List<V3NetId>::List    V3NetList;$/;"	t
V3NetNamePrefix	ntk/v3Type.h	/^const string V3NetNamePrefix  = "v3_Internal_Net_";$/;"	v
V3NetStrHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<uint32_t, string>::Hash V3NetStrHash;$/;"	t
V3NetTable	ntk/v3Ntk.h	/^typedef V3Vec<V3NetVec     >::Vec   V3NetTable;$/;"	t
V3NetType	ntk/v3Type.h	/^   V3NetType(const V3NetId& i) { id = i; }$/;"	f	union:V3NetType
V3NetType	ntk/v3Type.h	/^   V3NetType(uint32_t i = V3NtkUD) { value = i; }$/;"	f	union:V3NetType
V3NetType	ntk/v3Type.h	/^union V3NetType {  \/\/ 4 Bytes$/;"	u
V3NetType2HashKey	ntk/v3NtkHash.h	/^inline const uint32_t V3NetType2HashKey(const V3NetType& id) { return id.value; }$/;"	f
V3NetUD	ntk/v3Ntk.h	/^const V3NetId        V3NetUD = V3NetId::makeNetId();$/;"	v
V3NetVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NetId      >::Vec   V3NetVec;$/;"	t
V3NodeField	adt/v3Graph.h	/^   typedef typename V3Vec<V3NodeSet>::Vec          V3NodeField;$/;"	t	class:V3Graph
V3NodeFlow	adt/v3Graph.h	/^   typedef typename V3Stack<V3NodeLayer>::Stack    V3NodeFlow;$/;"	t	class:V3Graph
V3NodeIndexMap	adt/v3Graph.h	/^   typedef typename V3HashMap<T, uint32_t>::Hash   V3NodeIndexMap;$/;"	t	class:V3Graph
V3NodeLayer	adt/v3Graph.h	/^   typedef typename V3Queue<T>::Queue              V3NodeLayer;$/;"	t	class:V3Graph
V3NodeSet	adt/v3Graph.h	/^   typedef typename V3Set<T>::Set                  V3NodeSet;$/;"	t	class:V3Graph
V3NodeStack	adt/v3Graph.h	/^   typedef typename V3Stack<T>::Stack              V3NodeStack;$/;"	t	class:V3Graph
V3NodeVec	adt/v3Graph.h	/^   typedef typename V3Vec<V3DirectedNode>::Vec     V3NodeVec;$/;"	t	class:V3Graph
V3Ntk	ntk/v3Ntk.cpp	/^V3Ntk::V3Ntk() {$/;"	f	class:V3Ntk
V3Ntk	ntk/v3Ntk.h	/^class V3Ntk$/;"	c
V3NtkElaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::V3NtkElaborate(V3NtkHandler* const handler, const V3NetVec& targetNets)$/;"	f	class:V3NtkElaborate
V3NtkElaborate	ext/v3NtkElaborate.h	/^class V3NtkElaborate : public V3NtkHandler$/;"	c
V3NtkExpand	trans/v3NtkExpand.cpp	/^V3NtkExpand::V3NtkExpand(V3NtkHandler* const p, const uint32_t& cycle, const bool& init)$/;"	f	class:V3NtkExpand
V3NtkExpand	trans/v3NtkExpand.h	/^class V3NtkExpand : public V3NtkHandler$/;"	c
V3NtkFlatten	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::V3NtkFlatten(V3NtkHandler* const handler, const uint32_t& level) : V3NtkHandler(handler) {$/;"	f	class:V3NtkFlatten
V3NtkFlatten	trans/v3NtkFlatten.h	/^class V3NtkFlatten : public V3NtkHandler$/;"	c
V3NtkFromQuteRTL	io/v3NtkQuteRTL.cpp	/^V3NtkInput* const V3NtkFromQuteRTL(const char* fileName, const bool& isFileList, const bool& toFlatten, const bool& async2sync) {$/;"	f
V3NtkHandler	ntk/v3NtkHandler.cpp	/^V3NtkHandler::V3NtkHandler(V3NtkHandler* const p, V3Ntk* const ntk) : _handler(p) {$/;"	f	class:V3NtkHandler
V3NtkHandler	ntk/v3NtkHandler.h	/^class V3NtkHandler$/;"	c
V3NtkHierData	ntk/v3NtkHandler.h	/^            V3NtkHierData(V3NtkHandler* const n, const uint32_t& p) : _handler(n), _parentId(p) { _p2cMap.clear(); }$/;"	f	class:V3NtkHierInfo::V3NtkHierData
V3NtkHierData	ntk/v3NtkHandler.h	/^      class V3NtkHierData {$/;"	c	class:V3NtkHierInfo
V3NtkHierInfo	ntk/v3NtkHandler.h	/^      V3NtkHierInfo() { _hierInfo.clear(); _refIdMap.clear(); }$/;"	f	class:V3NtkHierInfo
V3NtkHierInfo	ntk/v3NtkHandler.h	/^class V3NtkHierInfo {$/;"	c
V3NtkInput	ntk/v3NtkInput.cpp	/^V3NtkInput::V3NtkInput(const bool& isAig, const string& name) : V3NtkHandler(0, createV3Ntk(!isAig)) {$/;"	f	class:V3NtkInput
V3NtkInput	ntk/v3NtkInput.h	/^class V3NtkInput : public V3NtkHandler$/;"	c
V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::V3NtkMiter(V3NtkHandler* const p1, V3NtkHandler* const p2, const V3UI32Vec& latchMap, const bool& merge, const string& n) $/;"	f	class:V3NtkMiter
V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::V3NtkMiter(V3NtkHandler* const p1, V3NtkHandler* const p2, const bool& merge, const string& n) $/;"	f	class:V3NtkMiter
V3NtkMiter	trans/v3NtkMiter.h	/^class V3NtkMiter : public V3NtkHandler$/;"	c
V3NtkModule	ntk/v3Ntk.h	/^      V3NtkModule(const V3NetVec& i, const V3NetVec& o) { _ref = 0; _inputs = i; _outputs = o; }$/;"	f	class:V3NtkModule
V3NtkModule	ntk/v3Ntk.h	/^class V3NtkModule$/;"	c
V3NtkModuleVec	ntk/v3Ntk.h	/^typedef V3Vec<V3NtkModule* >::Vec   V3NtkModuleVec;$/;"	t
V3NtkSimplify	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::V3NtkSimplify(V3NtkHandler* const handler) : V3NtkHandler(handler) {$/;"	f	class:V3NtkSimplify
V3NtkSimplify	ntk/v3NtkSimplify.h	/^class V3NtkSimplify : public V3NtkHandler$/;"	c
V3NtkUD	ntk/v3Type.h	/^const uint32_t V3NtkUD     = V3IntMAX;$/;"	v
V3OperatorMap	ext/v3Formula.h	/^typedef V3Map<string, pair<uint32_t, V3GateType> >::Map  V3OperatorMap;$/;"	t
V3OrderedNetType2HashKey	ntk/v3NtkHash.h	/^inline const uint64_t V3OrderedNetType2HashKey(const V3NetType& id1, const V3NetType& id2) {$/;"	f
V3PairHashEqual	adt/v3Hash.h	/^struct V3PairHashEqual {$/;"	s
V3PairHashFcn	adt/v3Hash.h	/^struct V3PairHashFcn {$/;"	s
V3PairType	ntk/v3Type.h	/^   V3PairType(uint32_t m, uint32_t l) { bus[0] = m; bus[1] = l; }$/;"	f	struct:V3PairType
V3PairType	ntk/v3Type.h	/^   V3PairType(uint64_t p) { pair = p; }$/;"	f	struct:V3PairType
V3PairType	ntk/v3Type.h	/^struct V3PairType {  \/\/ 8 Bytes$/;"	s
V3PlotNtkByDepth	io/v3NtkWriter.cpp	/^void V3PlotNtkByDepth(const V3NtkHandler* const handler, const char* fileName, const uint32_t& maxDepth, const V3NetVec& rootNets, const bool& monoChrome) {$/;"	f
V3PlotNtkByLevel	io/v3NtkWriter.cpp	/^void V3PlotNtkByLevel(const V3NtkHandler* const handler, const char* fileName, const uint32_t& maxLevel, const V3NetVec& rootNets, const bool& monoChrome) {$/;"	f
V3PortableType	adt/v3Misc.h	/^      V3PortableType(const uint32_t& s = 0, const uint32_t& f = 0) : _size(s), _shift(f) {$/;"	f	class:V3PortableType
V3PortableType	adt/v3Misc.h	/^class V3PortableType {$/;"	c
V3Property	ext/v3Property.cpp	/^V3Property::V3Property(V3LTLFormula* const formula) : _formula(formula) {$/;"	f	class:V3Property
V3Property	ext/v3Property.h	/^class V3Property$/;"	c
V3PropertyMap	ntk/v3NtkHandler.h	/^typedef V3Map<string, V3Property*>::Map   V3PropertyMap;$/;"	t
V3PropertyPrefix	ext/v3ExtType.h	/^const string V3PropertyPrefix = "P_";$/;"	v
V3PtrVec	adt/v3Misc.h	/^typedef V3Vec<size_t    >::Vec   V3PtrVec;$/;"	t
V3Queue	adt/v3Queue.h	/^struct V3Queue {$/;"	s
V3QuteRTLClockHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLClockHandler(V3NtkInput* const quteHandler, const V3NetVec& piList, V3NetVec& inputs) {$/;"	f
V3QuteRTLFFHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLFFHandler(V3NtkInput* const quteHandler, CktModule* const module, const bool& async2sync, V3NetVec& inputs) {$/;"	f
V3QuteRTLHandler	io/v3NtkQuteRTL.cpp	/^V3NtkInput* const V3QuteRTLHandler(CktModule* const& module, const bool& async2sync, V3NetVec& inputs, const string& instName) {$/;"	f
V3QuteRTLInputHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLInputHandler(V3NtkInput* const quteHandler, CktModule* const module, V3NetVec& piList) {$/;"	f
V3QuteRTLOutputHandler	io/v3NtkQuteRTL.cpp	/^const bool V3QuteRTLOutputHandler(V3NtkInput* const quteHandler, CktModule* const module, const bool& async2sync) {$/;"	f
V3RTLName	io/v3NtkWriter.h	18;"	d
V3RTLNameBase	io/v3NtkWriter.h	19;"	d
V3RTLNameById	io/v3NtkWriter.h	21;"	d
V3RTLNameOrId	io/v3NtkWriter.h	20;"	d
V3RTLParser	io/v3RTLParser.cpp	/^V3NtkInput* const V3RTLParser(const char* fileName) {$/;"	f
V3RTLSplitToken	io/v3RTLParser.cpp	/^typedef V3Vec<char>::Vec      V3RTLSplitToken;$/;"	t	file:
V3RTLWriter	io/v3RTLWriter.cpp	/^const bool V3RTLWriter(const V3NtkHandler* const handler, ofstream& output, const bool& symbol, const bool& initial, string prefix, V3StrVec& ioName) {$/;"	f
V3RTLWriter	io/v3RTLWriter.cpp	/^void V3RTLWriter(const V3NtkHandler* const handler, const char* fileName, const bool& symbol, const bool& initial) {$/;"	f
V3RepIdHash	ntk/v3Ntk.h	/^typedef V3HashMap<uint32_t,   V3NetId>::Hash V3RepIdHash;$/;"	t
V3SDG	stg/v3StgSDG.cpp	/^V3SDG::V3SDG(V3NtkHandler* const handler) : _handler(handler) {$/;"	f	class:V3SDG
V3SDG	stg/v3StgSDG.h	/^class V3SDG {$/;"	c
V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::V3SDGBase() {$/;"	f	class:V3SDGBase
V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::V3SDGBase(const V3SDGBase& node) {$/;"	f	class:V3SDGBase
V3SDGBase	stg/v3StgSDG.h	/^class V3SDGBase {$/;"	c
V3SDGClusters	stg/v3StgExtract.h	/^      typedef V3Vec<V3UI32Set>::Vec    V3SDGClusters;$/;"	t	class:V3FSMExtract
V3SDGMUX	stg/v3StgSDG.cpp	/^V3SDGMUX::V3SDGMUX(const V3NetId& id) : V3SDGNode(id), _tBase(new V3SDGBase()), _fBase(new V3SDGBase()) {$/;"	f	class:V3SDGMUX
V3SDGMUX	stg/v3StgSDG.h	/^class V3SDGMUX : public V3SDGNode {$/;"	c
V3SDGNode	stg/v3StgSDG.cpp	/^V3SDGNode::V3SDGNode(const V3NetId& id) : _netId(id), _base(new V3SDGBase()) {$/;"	f	class:V3SDGNode
V3SDGNode	stg/v3StgSDG.h	/^class V3SDGNode {$/;"	c
V3SDGNodeList	stg/v3StgSDG.h	/^typedef V3Vec<V3SDGNode*>::Vec   V3SDGNodeList;$/;"	t
V3SafeAdd	util/v3NumUtil.h	/^inline bool V3SafeAdd(T& a, const T b) {$/;"	f
V3SafeAdd	util/v3NumUtil.h	/^inline bool V3SafeAdd(const T a, const T b, T& c) {$/;"	f
V3SafeMult	util/v3NumUtil.h	/^inline bool V3SafeMult(T& a, const T b) {$/;"	f
V3SafeMult	util/v3NumUtil.h	/^inline bool V3SafeMult(const T a, const T b, T& c) {$/;"	f
V3SafetyPrefix	ext/v3ExtType.h	/^const string V3SafetyPrefix   = "v3_Safety_";$/;"	v
V3Set	adt/v3Set.h	/^struct V3Set {$/;"	s
V3SimTrace	alg/v3AlgType.h	/^typedef V3Vec<V3BitVecX>::Vec             V3SimTrace;$/;"	t
V3SimTraceVec	alg/v3AlgType.h	/^typedef V3Vec<V3SimTrace>::Vec            V3SimTraceVec;$/;"	t
V3SolverType	svr/v3SvrHandler.h	/^enum V3SolverType$/;"	g
V3SolverTypeStr	svr/v3SvrHandler.h	/^const string V3SolverTypeStr[] = $/;"	v
V3Stack	adt/v3Stack.h	/^struct V3Stack {$/;"	s
V3Stat	util/v3Usage.h	/^      V3Stat(const string& name, V3Stat* const ref = 0) : _statName(name), _refStat(ref) {$/;"	f	class:V3Stat
V3Stat	util/v3Usage.h	/^class V3Stat$/;"	c
V3Str2BoolFuncPtr	ntk/v3NtkInput.h	/^typedef const bool(*V3Str2BoolFuncPtr) (const string&);$/;"	t
V3StrIdxHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<string, uint32_t>::Hash V3StrIdxHash;$/;"	t
V3StrNetHash	ntk/v3NtkHandler.h	/^typedef V3HashMap<string, V3NetId>::Hash  V3StrNetHash;$/;"	t
V3StrSet	adt/v3Misc.h	/^typedef V3Set<string    >::Set   V3StrSet;$/;"	t
V3StrTable	adt/v3Misc.h	/^typedef V3Vec<V3StrVec  >::Vec   V3StrTable;$/;"	t
V3StrVec	adt/v3Misc.h	/^typedef V3Vec<string    >::Vec   V3StrVec;$/;"	t
V3StringVec	ntk/v3NtkInput.h	/^typedef V3Vec<string     >::Vec  V3StringVec;$/;"	t
V3SvrBase	svr/v3SvrBase.cpp	/^V3SvrBase::V3SvrBase(const V3Ntk* const ntk, const bool& freeBound) : _ntk(ntk), _freeBound(freeBound) {$/;"	f	class:V3SvrBase
V3SvrBase	svr/v3SvrBase.h	/^class V3SvrBase$/;"	c
V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::V3SvrBoolector(const V3Ntk* const ntk, const bool& freeBound) : V3SvrBase(ntk, freeBound) {$/;"	f	class:V3SvrBoolector
V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::V3SvrBoolector(const V3SvrBoolector& solver) : V3SvrBase(solver._ntk, solver._freeBound) {$/;"	f	class:V3SvrBoolector
V3SvrBoolector	svr/v3SvrBoolector.h	/^class V3SvrBoolector : public V3SvrBase$/;"	c
V3SvrData	svr/v3SvrType.h	/^typedef size_t                      V3SvrData;$/;"	t
V3SvrDataSet	svr/v3SvrType.h	/^typedef V3Set<V3SvrData>::Set       V3SvrDataSet;$/;"	t
V3SvrDataTable	svr/v3SvrType.h	/^typedef V3Vec<V3SvrDataVec>::Vec    V3SvrDataTable;$/;"	t
V3SvrDataVec	svr/v3SvrType.h	/^typedef V3Vec<V3SvrData>::Vec       V3SvrDataVec;$/;"	t
V3SvrMLitData	svr/v3SvrType.h	/^typedef V3Vec<Lit>::Vec             V3SvrMLitData;$/;"	t
V3SvrMVarData	svr/v3SvrType.h	/^typedef V3Vec<Var>::Vec             V3SvrMVarData;$/;"	t
V3SvrMVarTable	svr/v3SvrType.h	/^typedef V3Vec<V3SvrMVarData>::Vec   V3SvrMVarTable;$/;"	t
V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::V3SvrMiniSat(const V3Ntk* const ntk, const bool& freeBound) : V3SvrBase(ntk, freeBound) {$/;"	f	class:V3SvrMiniSat
V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::V3SvrMiniSat(const V3SvrMiniSat& solver) : V3SvrBase(solver._ntk, solver._freeBound) {$/;"	f	class:V3SvrMiniSat
V3SvrMiniSat	svr/v3SvrMiniSat.h	/^class V3SvrMiniSat : public V3SvrBase$/;"	c
V3TraceSimplify	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::V3TraceSimplify(V3NtkHandler* const handler, const V3CexTrace& cex) : _handler(handler) {$/;"	f	class:V3TraceSimplify
V3TraceSimplify	dfx/v3DfxSimplify.h	/^class V3TraceSimplify$/;"	c
V3TypeBTOR	io/v3BtorWriter.cpp	/^const string V3TypeBTOR[] = {$/;"	v
V3TypeRTL	io/v3RTLWriter.cpp	/^const string V3TypeRTL[] = {$/;"	v
V3TypeVec	ntk/v3Ntk.h	/^typedef V3Vec<V3MiscType   >::Vec   V3TypeVec;$/;"	t
V3UI32Hash	ntk/v3NtkHash.h	/^typedef V3HashMap<uint32_t,   V3NetId                      >::Hash   V3UI32Hash;$/;"	t
V3UI32LessOrEq	adt/v3Misc.h	/^struct V3UI32LessOrEq { const bool operator() (const T& i, const T& j) const { return i <= j; } };$/;"	s
V3UI32Queue	adt/v3Misc.h	/^typedef V3Queue<uint32_t>::Queue V3UI32Queue;$/;"	t
V3UI32Set	adt/v3Misc.h	/^typedef V3Set<uint32_t  >::Set   V3UI32Set;$/;"	t
V3UI32Stack	adt/v3Misc.h	/^typedef V3Stack<uint32_t>::Stack V3UI32Stack;$/;"	t
V3UI32Table	adt/v3Misc.h	/^typedef V3Vec<V3UI32Vec >::Vec   V3UI32Table;$/;"	t
V3UI32Vec	adt/v3Misc.h	/^typedef V3Vec<uint32_t  >::Vec   V3UI32Vec;$/;"	t
V3UI64Hash	ntk/v3NtkHash.h	/^typedef V3HashMap<uint64_t,   V3NetId                      >::Hash   V3UI64Hash;$/;"	t
V3UI64LSB	ntk/v3Type.h	24;"	d
V3UI64MSB	ntk/v3Type.h	23;"	d
V3UI64Pair	ntk/v3Type.h	22;"	d
V3UI64Type	ntk/v3Type.h	21;"	d
V3UI64Vec	adt/v3Misc.h	/^typedef V3Vec<uint64_t  >::Vec   V3UI64Vec;$/;"	t
V3UnorderedNetType2HashKey	ntk/v3NtkHash.h	/^inline const uint64_t V3UnorderedNetType2HashKey(const V3NetType& id1, const V3NetType& id2) {$/;"	f
V3Usage	util/v3Usage.h	/^      V3Usage() {$/;"	f	class:V3Usage
V3Usage	util/v3Usage.h	/^class V3Usage $/;"	c
V3Vec	adt/v3Vec.h	/^struct V3Vec {$/;"	s
V3VrfBMC	vrf/v3VrfBMC.cpp	/^V3VrfBMC::V3VrfBMC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfBMC
V3VrfBMC	vrf/v3VrfBMC.h	/^class V3VrfBMC : public V3VrfBase$/;"	c
V3VrfBase	vrf/v3VrfBase.cpp	/^V3VrfBase::V3VrfBase(const V3NtkHandler* const handler) {$/;"	f	class:V3VrfBase
V3VrfBase	vrf/v3VrfBase.h	/^class V3VrfBase$/;"	c
V3VrfCITP	vrf/v3VrfCITP.cpp	/^V3VrfCITP::V3VrfCITP(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfCITP
V3VrfCITP	vrf/v3VrfCITP.h	/^class V3VrfCITP : public V3VrfBase$/;"	c
V3VrfFITP	vrf/v3VrfFITP.cpp	/^V3VrfFITP::V3VrfFITP(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfFITP
V3VrfFITP	vrf/v3VrfFITP.h	/^class V3VrfFITP : public V3VrfBase$/;"	c
V3VrfIPDR	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::V3VrfIPDR(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfIPDR
V3VrfIPDR	vrf/v3VrfIPDR.h	/^class V3VrfIPDR : public V3VrfBase$/;"	c
V3VrfKLive	vrf/v3VrfKLive.cpp	/^V3VrfKLive::V3VrfKLive(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfKLive
V3VrfKLive	vrf/v3VrfKLive.h	/^class V3VrfKLive : public V3VrfBase$/;"	c
V3VrfMPDR	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::V3VrfMPDR(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfMPDR
V3VrfMPDR	vrf/v3VrfMPDR.h	/^class V3VrfMPDR : public V3VrfBase$/;"	c
V3VrfResult	ext/v3Property.h	/^      V3VrfResult() { _cexOrInv = 0; }$/;"	f	class:V3VrfResult
V3VrfResult	ext/v3Property.h	/^class V3VrfResult$/;"	c
V3VrfResultVec	vrf/v3VrfShared.h	/^typedef V3Vec<V3VrfResult>::Vec  V3VrfResultVec;$/;"	t
V3VrfSEC	vrf/v3VrfSEC.cpp	/^V3VrfSEC::V3VrfSEC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfSEC
V3VrfSEC	vrf/v3VrfSEC.h	/^class V3VrfSEC : public V3VrfBase$/;"	c
V3VrfSIM	vrf/v3VrfSIM.cpp	/^V3VrfSIM::V3VrfSIM(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfSIM
V3VrfSIM	vrf/v3VrfSIM.h	/^class V3VrfSIM : public V3VrfBase$/;"	c
V3VrfShared	vrf/v3VrfShared.h	/^      V3VrfShared() { pthread_mutex_init(&_mutex, NULL); }$/;"	f	class:V3VrfShared
V3VrfShared	vrf/v3VrfShared.h	/^class V3VrfShared$/;"	c
V3VrfSharedBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::V3VrfSharedBound(const uint32_t& size, const bool& print) : _print(print) {$/;"	f	class:V3VrfSharedBound
V3VrfSharedBound	vrf/v3VrfShared.h	/^class V3VrfSharedBound : public V3VrfShared$/;"	c
V3VrfSharedInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::V3VrfSharedInv() {$/;"	f	class:V3VrfSharedInv
V3VrfSharedInv	vrf/v3VrfShared.h	/^class V3VrfSharedInv : public V3VrfShared$/;"	c
V3VrfSharedMem	vrf/v3VrfShared.h	/^      V3VrfSharedMem(const double& m) : V3VrfShared() { _maxMemory = m; }$/;"	f	class:V3VrfSharedMem
V3VrfSharedMem	vrf/v3VrfShared.h	/^class V3VrfSharedMem : public V3VrfShared$/;"	c
V3VrfSharedNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::V3VrfSharedNtk() {$/;"	f	class:V3VrfSharedNtk
V3VrfSharedNtk	vrf/v3VrfShared.h	/^class V3VrfSharedNtk : public V3VrfShared$/;"	c
V3VrfSharedNtkData	vrf/v3VrfShared.h	/^      struct V3VrfSharedNtkData$/;"	s	class:V3VrfSharedNtk
V3VrfSimTraceVec	vrf/v3VrfSEC.h	/^typedef V3Vec<V3SimTrace>::Vec   V3VrfSimTraceVec;$/;"	t
V3VrfUMC	vrf/v3VrfUMC.cpp	/^V3VrfUMC::V3VrfUMC(const V3NtkHandler* const handler) : V3VrfBase(handler) {$/;"	f	class:V3VrfUMC
V3VrfUMC	vrf/v3VrfUMC.h	/^class V3VrfUMC : public V3VrfBase$/;"	c
V3_ADT_HASH_H	adt/v3Hash.h	10;"	d
V3_ADT_LIST_H	adt/v3List.h	10;"	d
V3_ADT_MAP_H	adt/v3Map.h	10;"	d
V3_ADT_QUEUE_H	adt/v3Queue.h	10;"	d
V3_ADT_SET_H	adt/v3Set.h	10;"	d
V3_ADT_STACK_H	adt/v3Stack.h	10;"	d
V3_ADT_VEC_H	adt/v3Vec.h	10;"	d
V3_AIG_PARSER_C	io/v3AigParser.cpp	10;"	d	file:
V3_AIG_WRITER_H	io/v3AigWriter.cpp	10;"	d	file:
V3_ALG_CMD_C	alg/v3AlgCmd.cpp	10;"	d	file:
V3_ALG_CMD_H	alg/v3AlgCmd.h	10;"	d
V3_ALG_GENERALIZE_C	alg/v3AlgGeneralize.cpp	10;"	d	file:
V3_ALG_GENERALIZE_H	alg/v3AlgGeneralize.h	10;"	d
V3_ALG_SIMULATE_C	alg/v3AlgSimulate.cpp	10;"	d	file:
V3_ALG_SIMULATE_H	alg/v3AlgSimulate.h	10;"	d
V3_ALG_SIM_C	alg/v3AlgSim.cpp	10;"	d	file:
V3_ALG_SIM_H	alg/v3AlgSim.h	10;"	d
V3_ALG_TYPE_H	alg/v3AlgType.h	10;"	d
V3_BIT_VEC_C	adt/v3BitVec.cpp	10;"	d	file:
V3_BIT_VEC_H	adt/v3BitVec.h	10;"	d
V3_BTOR_PARSER_C	io/v3BtorParser.cpp	10;"	d	file:
V3_BTOR_WRITER_H	io/v3BtorWriter.cpp	10;"	d	file:
V3_BUCKET_H	adt/v3Bucket.h	10;"	d
V3_BV0	adt/v3BitVec.cpp	/^static const unsigned char V3_BV0   = '0';$/;"	v	file:
V3_BV1	adt/v3BitVec.cpp	/^static const unsigned char V3_BV1   = '1';$/;"	v	file:
V3_BVX	adt/v3BitVec.cpp	/^static const unsigned char V3_BVX   = 'X';$/;"	v	file:
V3_BV_BLAST_AIG_C	trans/v3BvBlastAig.cpp	10;"	d	file:
V3_BV_BLAST_AIG_H	trans/v3BvBlastAig.h	10;"	d
V3_BV_BLAST_AIG_HELPER_H	trans/v3BvBlastAigHelper.h	10;"	d
V3_BV_BLAST_BV_C	trans/v3BvBlastBv.cpp	10;"	d	file:
V3_BV_BLAST_BV_H	trans/v3BvBlastBv.h	10;"	d
V3_CITP_IMPROVED_RECYCLE	vrf/v3VrfCITP.cpp	25;"	d	file:
V3_CMD_COMM_C	cmd/v3CmdComm.cpp	10;"	d	file:
V3_CMD_COMM_H	cmd/v3CmdComm.h	10;"	d
V3_CMD_MGR_C	cmd/v3CmdMgr.cpp	10;"	d	file:
V3_CMD_MGR_H	cmd/v3CmdMgr.h	10;"	d
V3_COMMAND	cmd/v3CmdMgr.h	82;"	d
V3_DFX_CMD_C	dfx/v3DfxCmd.cpp	10;"	d	file:
V3_DFX_CMD_H	dfx/v3DfxCmd.h	10;"	d
V3_DFX_SIMPLIFY_C	dfx/v3DfxSimplify.cpp	10;"	d	file:
V3_DFX_SIMPLIFY_H	dfx/v3DfxSimplify.h	10;"	d
V3_DFX_TRACE_C	dfx/v3DfxTrace.cpp	10;"	d	file:
V3_DFX_TRACE_H	dfx/v3DfxTrace.h	10;"	d
V3_DFX_TRACE_RESTRICT_X	dfx/v3DfxTrace.cpp	19;"	d	file:
V3_EXT_ELABORATE_C	ext/v3ExtElaborate.cpp	10;"	d	file:
V3_EXT_IO_C	ext/v3ExtIO.cpp	10;"	d	file:
V3_EXT_TYPE_H	ext/v3ExtType.h	10;"	d
V3_EXT_UTIL_H	ext/v3ExtUtil.h	10;"	d
V3_FF	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_FILE_UTIL_H	util/v3FileUtil.h	10;"	d
V3_FITP_IMPROVED_RECYCLE	vrf/v3VrfFITP.cpp	26;"	d	file:
V3_FORMULA_C	ext/v3Formula.cpp	10;"	d	file:
V3_FORMULA_H	ext/v3Formula.h	10;"	d
V3_GATE_TOTAL	ntk/v3Type.h	/^   BV_NEQ, BV_GREATER, BV_LEQ, BV_LESS, V3_GATE_TOTAL                            \/\/ BV_EXTERNAL_ONLY$/;"	e	enum:V3GateType
V3_GRAPH_H	adt/v3Graph.h	10;"	d
V3_HASH_H	util/v3HashUtil.h	10;"	d
V3_INDENT	ntk/v3Type.h	/^const string   V3_INDENT   = "   ";$/;"	v
V3_INT_TYPE_H	util/v3IntType.h	10;"	d
V3_IPDR_USE_PROPAGATE_LOW_COST	vrf/v3VrfIPDR.cpp	19;"	d	file:
V3_LTL_FORMULA_C	ext/v3LTLFormula.cpp	10;"	d	file:
V3_LTL_FORMULA_H	ext/v3LTLFormula.h	10;"	d
V3_LTL_L_AND	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_L_IMPLY	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_L_NEG	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_P	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_TOTAL	ext/v3LTLFormula.h	/^   V3_LTL_L_NEG, V3_LTL_L_AND, V3_LTL_L_IMPLY, V3_LTL_TOTAL$/;"	e	enum:V3LTLOpType
V3_LTL_T_F	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_G	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_R	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_U	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_LTL_T_X	ext/v3LTLFormula.h	/^   V3_LTL_P = 0, V3_LTL_T_G, V3_LTL_T_F, V3_LTL_T_X, V3_LTL_T_U, V3_LTL_T_R,$/;"	e	enum:V3LTLOpType
V3_MAIN_C	main/main.cpp	10;"	d	file:
V3_MC_AIGER_C	v3mc/v3MCAiger.cpp	10;"	d	file:
V3_MC_CMD_C	v3mc/v3MCCmd.cpp	10;"	d	file:
V3_MC_CMD_H	v3mc/v3MCCmd.h	10;"	d
V3_MC_ELABORATE_C	v3mc/v3MCElaborate.cpp	10;"	d	file:
V3_MC_ENGINE_C	v3mc/v3MCEngine.cpp	10;"	d	file:
V3_MC_ENGINE_H	v3mc/v3MCEngine.h	10;"	d
V3_MC_MAIN_C	v3mc/v3MCMain.cpp	10;"	d	file:
V3_MC_MAIN_H	v3mc/v3MCMain.h	10;"	d
V3_MC_PROP_C	v3mc/v3MCProp.cpp	10;"	d	file:
V3_MC_REORDER_C	v3mc/v3MCReorder.cpp	10;"	d	file:
V3_MC_REPORT_C	v3mc/v3MCReport.cpp	10;"	d	file:
V3_MISC_H	adt/v3Misc.h	10;"	d
V3_MODULE	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_MPDR_USE_PROPAGATE_LOW_COST	vrf/v3VrfMPDR.cpp	21;"	d	file:
V3_MSG_H	util/v3Msg.h	10;"	d
V3_NTK_C	ntk/v3Ntk.cpp	10;"	d	file:
V3_NTK_C	ntk/v3NtkBdd.cpp	10;"	d	file:
V3_NTK_CMD_C	ntk/v3NtkCmd.cpp	10;"	d	file:
V3_NTK_CMD_H	ntk/v3NtkCmd.h	10;"	d
V3_NTK_CONSTRUCT_C	ntk/v3NtkConstruct.cpp	10;"	d	file:
V3_NTK_DUPLICATE_C	ntk/v3NtkDuplicate.cpp	10;"	d	file:
V3_NTK_ELABORATE_C	ext/v3NtkElaborate.cpp	10;"	d	file:
V3_NTK_ELABORATE_H	ext/v3NtkElaborate.h	10;"	d
V3_NTK_EXPAND_C	trans/v3NtkExpand.cpp	10;"	d	file:
V3_NTK_EXPAND_H	trans/v3NtkExpand.h	10;"	d
V3_NTK_FLATTEN_C	trans/v3NtkFlatten.cpp	10;"	d	file:
V3_NTK_FLATTEN_H	trans/v3NtkFlatten.h	10;"	d
V3_NTK_H	ntk/v3Ntk.h	10;"	d
V3_NTK_HANDLER_C	ntk/v3NtkHandler.cpp	10;"	d	file:
V3_NTK_HANDLER_H	ntk/v3NtkHandler.h	10;"	d
V3_NTK_HASH_H	ntk/v3NtkHash.h	10;"	d
V3_NTK_INPUT_C	ntk/v3NtkInput.cpp	10;"	d	file:
V3_NTK_INPUT_H	ntk/v3NtkInput.h	10;"	d
V3_NTK_MITER_C	trans/v3NtkMiter.cpp	10;"	d	file:
V3_NTK_MITER_H	trans/v3NtkMiter.h	10;"	d
V3_NTK_PARSER_H	io/v3NtkParser.h	10;"	d
V3_NTK_QUTERTL_C	io/v3NtkQuteRTL.cpp	10;"	d	file:
V3_NTK_REWRITE_C	ntk/v3NtkRewrite.cpp	10;"	d	file:
V3_NTK_REWRITE_H	ntk/v3NtkRewrite.h	10;"	d
V3_NTK_SIMPLIFY_C	ntk/v3NtkSimplify.cpp	10;"	d	file:
V3_NTK_SIMPLIFY_H	ntk/v3NtkSimplify.h	10;"	d
V3_NTK_STRASH_C	ntk/v3NtkStrash.cpp	10;"	d	file:
V3_NTK_STRASH_H	ntk/v3NtkStrash.h	10;"	d
V3_NTK_TRAVERSE_C	ntk/v3NtkTraverse.cpp	10;"	d	file:
V3_NTK_UTIL_H	ntk/v3NtkUtil.h	10;"	d
V3_NTK_WRITER_C	io/v3NtkWriter.cpp	10;"	d	file:
V3_NTK_WRITER_H	io/v3NtkWriter.h	10;"	d
V3_NUM_UTIL_H	util/v3NumUtil.h	10;"	d
V3_PI	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_PIO	ntk/v3Type.h	/^   V3_PI = 0, V3_PIO, V3_FF, V3_MODULE, AIG_NODE, AIG_FALSE,                     \/\/ PI, PIO, FF, MODULE, AIG GATES$/;"	e	enum:V3GateType
V3_PROPERTY_C	ext/v3Property.cpp	10;"	d	file:
V3_PROPERTY_H	ext/v3Property.h	10;"	d
V3_REWRITE_CONST_PROP_ENABLED	ntk/v3NtkRewrite.cpp	18;"	d	file:
V3_REWRITE_STRASH_DUAL_REPR	ntk/v3NtkRewrite.cpp	17;"	d	file:
V3_RTL_PARSER_C	io/v3RTLParser.cpp	10;"	d	file:
V3_RTL_WRITER_H	io/v3RTLWriter.cpp	10;"	d	file:
V3_SIM_GENERALIZATION_EARLY_QUIT	alg/v3AlgGeneralize.cpp	17;"	d	file:
V3_STG_CMD_C	stg/v3StgCmd.cpp	10;"	d	file:
V3_STG_CMD_H	stg/v3StgCmd.h	10;"	d
V3_STG_EXTRACT_C	stg/v3StgExtract.cpp	10;"	d	file:
V3_STG_EXTRACT_H	stg/v3StgExtract.h	10;"	d
V3_STG_FSM_C	stg/v3StgFSM.cpp	10;"	d	file:
V3_STG_FSM_H	stg/v3StgFSM.h	10;"	d
V3_STG_SDG_C	stg/v3StgSDG.cpp	10;"	d	file:
V3_STG_SDG_H	stg/v3StgSDG.h	10;"	d
V3_STR_UTIL_C	bdd/test/v3StrUtil.cpp	10;"	d	file:
V3_STR_UTIL_C	util/v3StrUtil.cpp	10;"	d	file:
V3_STR_UTIL_H	util/v3StrUtil.h	10;"	d
V3_SVR_BASE_C	svr/v3SvrBase.cpp	10;"	d	file:
V3_SVR_BASE_H	svr/v3SvrBase.h	10;"	d
V3_SVR_BOOLECTOR	svr/v3SvrHandler.h	/^   V3_SVR_BOOLECTOR  = 1,$/;"	e	enum:V3SolverType
V3_SVR_BOOLECTOR_H	svr/v3SvrBoolector.h	10;"	d
V3_SVR_HANDLER_C	svr/v3SvrHandler.cpp	10;"	d	file:
V3_SVR_HANDLER_H	svr/v3SvrHandler.h	10;"	d
V3_SVR_MINISAT	svr/v3SvrHandler.h	/^   V3_SVR_MINISAT    = 0,$/;"	e	enum:V3SolverType
V3_SVR_MSAT_C	svr/v3SvrMiniSat.cpp	10;"	d	file:
V3_SVR_MSAT_H	svr/v3SvrMiniSat.h	10;"	d
V3_SVR_SAT_HELPER_C	svr/v3SvrSatHelper.h	11;"	d
V3_SVR_TOTAL	svr/v3SvrHandler.h	/^   V3_SVR_TOTAL      = 2$/;"	e	enum:V3SolverType
V3_SVR_TYPE_H	svr/v3SvrType.h	10;"	d
V3_TRANS_CMD_C	trans/v3TransCmd.cpp	10;"	d	file:
V3_TRANS_CMD_H	trans/v3TransCmd.h	10;"	d
V3_TYPE_H	ntk/v3Type.h	10;"	d
V3_USAGE_H	util/v3Usage.h	10;"	d
V3_USE_BOOST_HASH	adt/v3Hash.h	13;"	d
V3_USE_NEW_SIM_GENERALIZATION	alg/v3AlgGeneralize.cpp	16;"	d	file:
V3_VRF_BASE_C	vrf/v3VrfBase.cpp	10;"	d	file:
V3_VRF_BASE_H	vrf/v3VrfBase.h	10;"	d
V3_VRF_BMC_C	vrf/v3VrfBMC.cpp	10;"	d	file:
V3_VRF_BMC_H	vrf/v3VrfBMC.h	10;"	d
V3_VRF_CITP_C	vrf/v3VrfCITP.cpp	11;"	d	file:
V3_VRF_CITP_H	vrf/v3VrfCITP.h	11;"	d
V3_VRF_CMD_C	vrf/v3VrfCmd.cpp	10;"	d	file:
V3_VRF_CMD_H	vrf/v3VrfCmd.h	10;"	d
V3_VRF_FITP_C	vrf/v3VrfFITP.cpp	11;"	d	file:
V3_VRF_FITP_H	vrf/v3VrfFITP.h	11;"	d
V3_VRF_IPDR_C	vrf/v3VrfIPDR.cpp	10;"	d	file:
V3_VRF_IPDR_H	vrf/v3VrfIPDR.h	10;"	d
V3_VRF_KLIVE_C	vrf/v3VrfKLive.cpp	10;"	d	file:
V3_VRF_KLIVE_H	vrf/v3VrfKLive.h	10;"	d
V3_VRF_MPDR_C	vrf/v3VrfMPDR.cpp	10;"	d	file:
V3_VRF_MPDR_H	vrf/v3VrfMPDR.h	10;"	d
V3_VRF_RESULT_C	vrf/v3VrfResult.cpp	10;"	d	file:
V3_VRF_RESULT_H	vrf/v3VrfResult.h	10;"	d
V3_VRF_SEC_C	vrf/v3VrfSEC.cpp	10;"	d	file:
V3_VRF_SEC_H	vrf/v3VrfSEC.h	10;"	d
V3_VRF_SHARED_C	vrf/v3VrfShared.cpp	10;"	d	file:
V3_VRF_SHARED_H	vrf/v3VrfShared.h	10;"	d
V3_VRF_SIM_C	vrf/v3VrfSIM.cpp	10;"	d	file:
V3_VRF_SIM_H	vrf/v3VrfSIM.h	10;"	d
V3_VRF_UMC_C	vrf/v3VrfUMC.cpp	10;"	d	file:
V3_VRF_UMC_H	vrf/v3VrfUMC.h	10;"	d
V3_XD	ntk/v3Type.h	/^   BV_MERGE, BV_EQUALITY, BV_GEQ, BV_SLICE, BV_CONST, V3_XD,                     \/\/ BV_(MODEL), BV_(COMP)$/;"	e	enum:V3GateType
VMap	eng/minisat/SolverTypes.h	/^template<class T> class VMap : public IntMap<Var, T>{};$/;"	c
Var	eng/minisat/SolverTypes.h	/^typedef int Var;$/;"	t
VarData	eng/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	s	class:Solver
VarOrderLt	eng/minisat/Solver.h	/^        VarOrderLt(const IntMap<Var, double>&  act) : activity(act) { }$/;"	f	struct:Solver::VarOrderLt
VarOrderLt	eng/minisat/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Solver
Vec	adt/v3Vec.h	/^   typedef std::vector<T> Vec;$/;"	t	struct:V3Vec
Watcher	eng/minisat/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Solver::Watcher
Watcher	eng/minisat/Solver.h	/^    struct Watcher {$/;"	s	class:Solver
WatcherDeleted	eng/minisat/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Solver::WatcherDeleted
WatcherDeleted	eng/minisat/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Solver
_1stSave	ext/v3NtkElaborate.h	/^      V3NetId           _1stSave;   \/\/ V3NetId of First Time Oracle ON for L2S$/;"	m	class:V3NtkElaborate
_BddMgrV	bdd/bddNodeV.cpp	/^BddMgrV* BddNodeV::_BddMgrV = 0;$/;"	m	class:BddNodeV	file:
_BddMgrV	bdd/bddNodeV.h	/^   static BddMgrV*          _BddMgrV;$/;"	m	class:BddNodeV
_BddMgrV	bdd/test/bddNodeV.h	/^   static BddMgrV*          _BddMgrV;$/;"	m	class:BddNodeV
_ConstList	ntk/v3Ntk.h	/^      V3NetVec       _ConstList;    \/\/ V3NetId of BV_CONST (AIG_FALSE)$/;"	m	class:V3Ntk
_FFList	ntk/v3Ntk.h	/^      V3NetVec       _FFList;       \/\/ V3NetId of FF$/;"	m	class:V3Ntk
_IOList	ntk/v3Ntk.h	/^      V3NetVec       _IOList[3];    \/\/ V3NetId of PI \/ PO \/ PIO$/;"	m	class:V3Ntk
_Solver	svr/v3SvrBoolector.h	/^      Btor*          _Solver;    \/\/ Pointer to a Boolector solver$/;"	m	class:V3SvrBoolector
_Solver	svr/v3SvrMiniSat.h	/^      MSolver*       _Solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:V3SvrMiniSat
_V3BusIdHash	ntk/v3Ntk.cpp	/^V3BusIdHash  V3BvNtk::_V3BusIdHash = V3BusIdHash();$/;"	m	class:V3BvNtk	file:
_V3BusIdHash	ntk/v3Ntk.h	/^      static V3BusIdHash   _V3BusIdHash;  \/\/ Global Hash for V3BusId of V3Slice for All V3BvNtk$/;"	m	class:V3BvNtk
_V3BusIdVec	ntk/v3Ntk.cpp	/^V3BusPairVec V3BvNtk::_V3BusIdVec  = V3BusPairVec();$/;"	m	class:V3BvNtk	file:
_V3BusIdVec	ntk/v3Ntk.h	/^      static V3BusPairVec  _V3BusIdVec;   \/\/ Global Vec for V3BusId to (MSB, LSB) Mapping$/;"	m	class:V3BvNtk
_V3ConstHash	ntk/v3Ntk.cpp	/^V3ConstHash  V3BvNtk::_V3ConstHash = V3ConstHash();$/;"	m	class:V3BvNtk	file:
_V3ConstHash	ntk/v3Ntk.h	/^      static V3ConstHash   _V3ConstHash;  \/\/ Global Hash for V3BitVecX of V3Const for All V3BvNtk$/;"	m	class:V3BvNtk
_V3ValueVec	ntk/v3Ntk.cpp	/^V3BitVecXVec V3BvNtk::_V3ValueVec  = V3BitVecXVec();$/;"	m	class:V3BvNtk	file:
_V3ValueVec	ntk/v3Ntk.h	/^      static V3BitVecXVec  _V3ValueVec;   \/\/ Global Vec for V3BVXId to V3BitVecX  Mapping$/;"	m	class:V3BvNtk
_activator	vrf/v3VrfMPDR.h	/^      V3SvrData      _activator;    \/\/ Activation Variable for Clause Indication$/;"	m	class:V3MPDRFrame
_allName	main/main.cpp	/^string V3Msg::_allName = "";$/;"	m	class:V3Msg	file:
_allName	util/v3Msg.h	/^      static string     _allName;$/;"	m	class:V3Msg
_allout	main/main.cpp	/^ofstream V3Msg::_allout;$/;"	m	class:V3Msg	file:
_allout	util/v3Msg.h	/^      static ofstream   _allout;$/;"	m	class:V3Msg
_assump	svr/v3SvrBoolector.h	/^      V3BtorExpVec   _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:V3SvrBoolector
_assump	svr/v3SvrMiniSat.h	/^      vec<Lit>       _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:V3SvrMiniSat
_bId	bdd/myHash.h	/^      size_t                     _bId;$/;"	m	class:Hash::iterator
_bId	bdd/test/myHash.h	/^      size_t                     _bId;$/;"	m	class:Hash::iterator
_base	stg/v3StgSDG.h	/^      V3SDGBase* const  _base;         \/\/ Base Dependency Structure$/;"	m	class:V3SDGNode
_baseCube	alg/v3AlgGeneralize.h	/^      V3NetVec          _baseCube;$/;"	m	class:V3GenStruct
_baseNtk	v3mc/v3MCMain.h	/^   V3NtkHandler*        _baseNtk;      \/\/ The Very Base Network Handler$/;"	m	struct:V3MCMainParam
_bddArr	bdd/bddMgrV.h	/^   BddArr           _bddArr;$/;"	m	class:BddMgrV
_bddArr	bdd/test/bddMgrV.h	/^   BddArr           _bddArr;$/;"	m	class:BddMgrV
_bddMap	bdd/bddMgrV.h	/^   BddMap           _bddMap;$/;"	m	class:BddMgrV
_bddMap	bdd/test/bddMgrV.h	/^   BddMap           _bddMap;$/;"	m	class:BddMgrV
_bestIndex	adt/v3Bucket.h	/^      uint32_t       _bestIndex;$/;"	m	class:V3BucketList
_bestIndex	adt/v3Bucket.h	/^      uint32_t       _bestIndex;$/;"	m	class:V3IncBucketList
_bestIndex	alg/v3AlgGeneralize.h	/^      uint32_t          _bestIndex; \/\/ The Lowest Non-empty Bucket$/;"	m	class:V3GenBucket
_bnId	bdd/myHash.h	/^      size_t                     _bnId;$/;"	m	class:Hash::iterator
_bnId	bdd/test/myHash.h	/^      size_t                     _bnId;$/;"	m	class:Hash::iterator
_bound	vrf/v3VrfShared.h	/^      V3UI32Vec         _bound;     \/\/ The Deep Bound of Each Property (V3NtkUD for Verified)$/;"	m	class:V3VrfSharedBound
_bucketIdx	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _bucketIdx; \/\/ The Index for Element Storage$/;"	m	class:V3GenBucket
_buckets	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _buckets;   \/\/ The First Element in the Bucket$/;"	m	class:V3GenBucket
_buckets	bdd/myHash.h	/^   vector<HashNode>*        _buckets;$/;"	m	class:Hash
_buckets	bdd/test/myHash.h	/^   vector<HashNode>*        _buckets;$/;"	m	class:Hash
_c2pMap	ext/v3NtkElaborate.h	/^      V3NetVec          _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkElaborate
_c2pMap	ntk/v3NtkSimplify.h	/^      V3NetVec    _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkSimplify
_c2pMap	trans/v3BvBlastAig.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3BvBlastAig
_c2pMap	trans/v3BvBlastBv.h	/^      V3UI32Vec         _c2pMap;       \/\/ Net Index Mapping From Current to Parent Ntk$/;"	m	class:V3BvBlastBv
_c2pMap	trans/v3NtkExpand.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkExpand
_c2pMap	trans/v3NtkFlatten.h	/^      V3NetVec       _c2pMap;    \/\/ V3NetId Mapping From Current to Parent Ntk$/;"	m	class:V3NtkFlatten
_c2pMap	vrf/v3VrfSEC.h	/^      V3NetVec          _c2pMap;             \/\/ Mapping from new to old$/;"	m	class:V3VrfSEC
_cache	bdd/myHash.h	/^   CacheNode*     _cache;$/;"	m	class:Cache
_cache	bdd/test/myHash.h	/^   CacheNode*     _cache;$/;"	m	class:Cache
_cexOrInv	ext/v3Property.h	/^      size_t         _cexOrInv;$/;"	m	class:V3VrfResult
_checkStat	vrf/v3VrfKLive.h	/^      V3Stat*           _checkStat;       \/\/ Formal Checking$/;"	m	class:V3VrfKLive
_checkStat	vrf/v3VrfSEC.h	/^      V3Stat*           _checkStat;          \/\/ Formal Checking$/;"	m	class:V3VrfSEC
_clusters	stg/v3StgExtract.h	/^      V3SDGClusters        _clusters;  \/\/ Variable Cluster Results$/;"	m	class:V3FSMExtract
_cmdLen	cmd/v3CmdMgr.h	/^      unsigned          _cmdLen;$/;"	m	class:V3CmdExec
_cmdLib	cmd/v3CmdMgr.h	/^      V3CmdExecSet   _cmdLib;                \/\/ All Available Commands$/;"	m	class:V3CmdMgr
_cmdType	cmd/v3CmdMgr.h	/^      V3CmdType         _cmdType;$/;"	m	class:V3CmdExec
_computedTable	bdd/bddMgrV.h	/^   BddCache         _computedTable;$/;"	m	class:BddMgrV
_computedTable	bdd/test/bddMgrV.h	/^   BddCache         _computedTable;$/;"	m	class:BddMgrV
_configs	stg/v3StgExtract.h	/^      unsigned short       _configs;   \/\/ Configurations$/;"	m	class:V3FSMExtract
_configs	stg/v3StgFSM.h	/^      unsigned char           _configs;   \/\/ Configurations$/;"	m	class:V3FSM
_configs	stg/v3StgFSM.h	/^      unsigned char           _configs;   \/\/ FSMSDG Construction Configurations  (2 Leading MSBs are reserved)$/;"	m	class:V3FSMSDGDB
_constr	v3mc/v3MCMain.h	/^   V3NetTable           _constr;       \/\/ Table of Constraints$/;"	m	struct:V3MCMainParam
_constr	vrf/v3VrfBase.h	/^      V3NetTable                 _constr;$/;"	m	class:V3VrfBase
_constr	vrf/v3VrfShared.h	/^         V3NetTable        _constr;       \/\/ Constraints$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_constrInfo	ext/v3Property.h	/^      const uint64_t       _constrInfo;$/;"	m	class:V3Constraint
_cpRatio	v3mc/v3MCMain.h	/^      V3DblVec                _cpRatio;      \/\/ Ratio of Cores to Property Size$/;"	m	class:V3MCResource
_cube2Var	alg/v3AlgGeneralize.h	/^      V3GenCubeList     _cube2Var;$/;"	m	class:V3GenStruct
_cubeList	vrf/v3VrfCITP.h	/^      V3CITPCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3CITPFrame
_cubeList	vrf/v3VrfFITP.h	/^      V3FITPCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3FITPFrame
_cubeList	vrf/v3VrfIPDR.h	/^      V3IPDRCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3IPDRFrame
_cubeList	vrf/v3VrfMPDR.h	/^      V3MPDRCubeList _cubeList;     \/\/ List of Cubes Blocked in this Frame$/;"	m	class:V3MPDRFrame
_curHandlerId	ntk/v3NtkHandler.h	/^      uint32_t       _curHandlerId;    \/\/ Id of Current Ntk Handler $/;"	m	class:V3Handler
_curRefIdVec	ntk/v3NtkHandler.h	/^      V3UI32Vec      _curRefIdVec;     \/\/ Current Ref Indices from Base Ntk$/;"	m	class:V3Handler
_curTime	stg/v3StgExtract.h	/^      double               _curTime;   \/\/ Time Used Currently on FSM Extraction$/;"	m	class:V3FSMExtract
_curVar	svr/v3SvrMiniSat.h	/^      Var            _curVar;    \/\/ Latest Fresh Variable$/;"	m	class:V3SvrMiniSat
_currentMem	util/v3Usage.h	/^      double   _currentMem;$/;"	m	class:V3Usage
_currentTick	util/v3Usage.h	/^      double   _currentTick;$/;"	m	class:V3Usage
_cutSignals	ntk/v3Ntk.h	/^      V3NetVec       _cutSignals;   \/\/ Signals on Current Cut$/;"	m	class:V3Ntk
_cutSize	stg/v3StgFSM.h	/^      uint32_t                _cutSize;   \/\/ Number of Cut Signals in terms of Total Bit Width$/;"	m	class:V3FSM
_cycle	alg/v3AlgSimulate.h	/^      uint32_t                   _cycle;$/;"	m	class:V3AlgSimulate
_cycle	trans/v3NtkExpand.h	/^      const uint32_t _cycle;     \/\/ Number of Cycles for Expansion$/;"	m	class:V3NtkExpand
_data	adt/v3BitVec.h	/^      unsigned char*    _data;$/;"	m	class:V3BitVec
_data	ext/v3Property.h	/^      V3SimTrace        _data;$/;"	m	class:V3CexTrace
_data	vrf/v3VrfShared.h	/^      V3Vec<V3VrfSharedNtkData>::Vec   _data;   \/\/ Verification Data for Optimized Networks$/;"	m	class:V3VrfSharedNtk
_data0	adt/v3BitVec.h	/^      uint64_t    _data0;$/;"	m	class:V3BitVecS
_data0	adt/v3BitVec.h	/^      unsigned char*    _data0;$/;"	m	class:V3BitVecX
_data1	adt/v3BitVec.h	/^      uint64_t    _data1;$/;"	m	class:V3BitVecS
_data1	adt/v3BitVec.h	/^      unsigned char*    _data1;$/;"	m	class:V3BitVecX
_debugBddAddr	bdd/bddNodeV.cpp	/^bool BddNodeV::_debugBddAddr = false;$/;"	m	class:BddNodeV	file:
_debugBddAddr	bdd/bddNodeV.h	/^   static bool             _debugBddAddr;$/;"	m	class:BddNodeV
_debugBddAddr	bdd/test/bddNodeV.h	/^   static bool             _debugBddAddr;$/;"	m	class:BddNodeV
_debugRefCount	bdd/bddNodeV.cpp	/^bool BddNodeV::_debugRefCount = false;$/;"	m	class:BddNodeV	file:
_debugRefCount	bdd/bddNodeV.h	/^   static bool             _debugRefCount;$/;"	m	class:BddNodeV
_debugRefCount	bdd/test/bddNodeV.h	/^   static bool             _debugRefCount;$/;"	m	class:BddNodeV
_default	util/v3Msg.h	/^      ostream&          _default;$/;"	m	class:V3Msg
_defaultON	util/v3Msg.h	/^      bool              _defaultON;$/;"	m	class:V3Msg
_defaultPrompt	cmd/v3CmdMgr.h	/^      const string   _defaultPrompt;         \/\/ Default Command Prompt$/;"	m	class:V3CmdMgr
_depFFCone	stg/v3StgSDG.h	/^      V3SDGBase*        _depFFCone;    \/\/ V3SDGBase of Dependent FaninFF Nodes$/;"	m	class:V3SDGBase
_depFFSet	stg/v3StgSDG.h	/^      V3UI32Set         _depFFSet;     \/\/ Dependent FF Nodes$/;"	m	class:V3SDGBase
_depGraph	stg/v3StgExtract.h	/^      V3Graph<uint32_t>    _depGraph;  \/\/ Variable Dependency Graph$/;"	m	class:V3FSMExtract
_depMuxCone	stg/v3StgSDG.h	/^      V3SDGBase*        _depMuxCone;   \/\/ V3SDGBase of Dependent FaninMuxFF Nodes$/;"	m	class:V3SDGBase
_depMuxSet	stg/v3StgSDG.h	/^      V3UI32Set         _depMuxSet;    \/\/ Dependent MUX Nodes$/;"	m	class:V3SDGBase
_depRetain	stg/v3StgExtract.h	/^      V3BoolVec            _depRetain; \/\/ Retained Depdendent Variables$/;"	m	class:V3FSMExtract
_depVars	stg/v3StgFSM.h	/^      V3UI32Set               _depVars;   \/\/ Dependent Variables of the FSM$/;"	m	class:V3FSMSDGDB
_dffValue	alg/v3AlgSimulate.h	/^      V3AigSimDataVec   _dffValue;     \/\/ Next State Simulation Value$/;"	m	class:V3AlgAigSimulate
_dffValue	alg/v3AlgSimulate.h	/^      V3BvSimDataVec    _dffValue;     \/\/ Next State Simulation Value$/;"	m	class:V3AlgBvSimulate
_distInit	stg/v3StgFSM.h	/^      V3UI32Vec               _distInit;  \/\/ The Shortest Step that the Node Id is Reachable from Initial States$/;"	m	class:V3FSM
_distTerm	stg/v3StgFSM.h	/^      V3UI32Vec               _distTerm;  \/\/ The Shortest Step that the Node Id is Reachable to Terminal States$/;"	m	class:V3FSM
_dofile	cmd/v3CmdMgr.h	/^      ifstream       _dofile;                \/\/ For Script Parsing$/;"	m	class:V3CmdMgr
_elements	adt/v3Bucket.h	/^      BucketList     _elements;$/;"	m	class:V3BucketList
_elements	adt/v3Bucket.h	/^      BucketList     _elements;$/;"	m	class:V3IncBucketList
_emptyCores	v3mc/v3MCMain.h	/^      uint32_t                _emptyCores;   \/\/ Number of Empty Cores$/;"	m	class:V3MCResource
_engineType	v3mc/v3MCMain.h	/^   V3MCEngineType       _engineType;   \/\/ Type of Verification Engine$/;"	m	struct:V3MCParam
_eventList	alg/v3AlgSimulate.h	/^      V3IncBucketList<V3NetId>   _eventList;$/;"	m	class:V3AlgSimulate
_extSolverType	vrf/v3VrfBase.cpp	/^V3SolverType    V3VrfBase::_extSolverType       = V3_SVR_TOTAL;$/;"	m	class:V3VrfBase	file:
_extSolverType	vrf/v3VrfBase.h	/^      static V3SolverType        _extSolverType;$/;"	m	class:V3VrfBase
_extVerbosity	ntk/v3NtkHandler.cpp	/^unsigned char V3NtkHandler::_extVerbosity = 0;$/;"	m	class:V3NtkHandler	file:
_extVerbosity	ntk/v3NtkHandler.h	/^      static unsigned char _extVerbosity;$/;"	m	class:V3NtkHandler
_extVerbosity	vrf/v3VrfBase.cpp	/^unsigned char   V3VrfBase::_extVerbosity        = 0;$/;"	m	class:V3VrfBase	file:
_extVerbosity	vrf/v3VrfBase.h	/^      static unsigned char       _extVerbosity;$/;"	m	class:V3VrfBase
_f	bdd/bddMgrV.h	/^   size_t       _f;$/;"	m	class:BddCacheKeyV
_f	bdd/test/bddMgrV.h	/^   size_t       _f;$/;"	m	class:BddCacheKeyV
_fBase	stg/v3StgSDG.h	/^      V3SDGBase* const  _fBase;        \/\/ Base Structure for False Part of MUX$/;"	m	class:V3SDGMUX
_fairConstrs	ext/v3Property.h	/^      V3ConstraintVec      _fairConstrs;$/;"	m	class:V3Property
_falseSDG	stg/v3StgFSM.h	/^      V3FSMSDGSet             _falseSDG;  \/\/ Set of SDG for the FALSE Part$/;"	m	class:V3FSMSDG
_falseSize	stg/v3StgFSM.h	/^      uint32_t                _falseSize; \/\/ Size of the False States$/;"	m	class:V3FSMSDG
_fanoutVec	alg/v3AlgSimulate.h	/^      V3NetTable                 _fanoutVec;$/;"	m	class:V3AlgSimulate
_ffGenStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _ffGenStat;$/;"	m	class:V3TraceSimplify
_ffUnrollStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _ffUnrollStat;$/;"	m	class:V3TraceSimplify
_ffValue	dfx/v3DfxSimplify.h	/^      V3SimTraceVec        _ffValue;$/;"	m	class:V3TraceSimplify
_filename	util/v3Msg.h	/^      string            _filename;$/;"	m	class:V3Msg
_formula	ext/v3Formula.h	/^      V3FormulaList           _formula;$/;"	m	class:V3Formula
_formula	ext/v3LTLFormula.h	/^      V3LTLFormulaList     _formula;$/;"	m	class:V3LTLFormula
_formula	ext/v3Property.h	/^      V3LTLFormula* const  _formula;$/;"	m	class:V3Property
_frameId	dfx/v3DfxTrace.h	/^      const uint32_t          _frameId;      \/\/ Counterexample Frame of the Cube$/;"	m	class:V3DfxCube
_freeBound	svr/v3SvrBase.h	/^      const bool           _freeBound; \/\/ Set FF Bounds Free$/;"	m	class:V3SvrBase
_fsm	ntk/v3NtkHandler.h	/^      V3FSMMap             _fsm;          \/\/ FSM List$/;"	m	class:V3NtkHandler
_fsmList	stg/v3StgExtract.h	/^      V3FSMVec             _fsmList;   \/\/ List Extracted FSMs from Each Cluster$/;"	m	class:V3FSMExtract
_g	bdd/bddMgrV.h	/^   size_t       _g;$/;"	m	class:BddCacheKeyV
_g	bdd/test/bddMgrV.h	/^   size_t       _g;$/;"	m	class:BddCacheKeyV
_genResult	alg/v3AlgGeneralize.h	/^      V3NetList            _genResult; \/\/ Generalization Result$/;"	m	class:V3AlgGeneralize
_generalStat	vrf/v3VrfCITP.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfCITP
_generalStat	vrf/v3VrfFITP.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfFITP
_generalStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfIPDR
_generalStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _generalStat;     \/\/ UNSAT Generalization$/;"	m	class:V3VrfMPDR
_globalClk	ntk/v3Ntk.h	/^      V3NetId        _globalClk;    \/\/ Global Clock Signal (Specified in RTL)$/;"	m	class:V3Ntk
_globalMisc	ntk/v3Ntk.h	/^      uint32_t       _globalMisc;   \/\/ Global Misc Data for V3NetId in Ntk$/;"	m	class:V3Ntk
_h	bdd/bddMgrV.h	/^   size_t       _h;$/;"	m	class:BddCacheKeyV
_h	bdd/test/bddMgrV.h	/^   size_t       _h;$/;"	m	class:BddCacheKeyV
_handler	alg/v3AlgSimulate.h	/^      const V3NtkHandler* const  _handler;$/;"	m	class:V3AlgSimulate
_handler	dfx/v3DfxSimplify.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3TraceSimplify
_handler	ext/v3Formula.h	/^      V3NtkHandler* const     _handler;$/;"	m	class:V3Formula
_handler	ext/v3LTLFormula.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3LTLFormula
_handler	ext/v3Property.h	/^      V3NtkHandler* const  _handler;$/;"	m	class:V3Constraint
_handler	ntk/v3NtkHandler.h	/^            V3NtkHandler* const  _handler;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_handler	ntk/v3NtkHandler.h	/^      V3NtkHandler* const  _handler;      \/\/ Parent Ntk Handler$/;"	m	class:V3NtkHandler
_handler	stg/v3StgExtract.h	/^      V3NtkHandler* const  _handler;   \/\/ Network that Extraction Works on$/;"	m	class:V3FSMExtract
_handler	stg/v3StgFSM.h	/^      V3NtkHandler* const     _handler;   \/\/ Network that FSMSDG Extracted From$/;"	m	class:V3FSMSDGDB
_handler	stg/v3StgSDG.h	/^      V3NtkHandler* const  _handler;   \/\/ Ntk Handler$/;"	m	class:V3SDG
_handler	v3mc/v3MCMain.h	/^   V3NtkHandler*        _handler;      \/\/ Base Elaborated Network Handler$/;"	m	struct:V3MCMainParam
_handler	vrf/v3VrfBase.h	/^      V3NtkHandler*              _handler;$/;"	m	class:V3VrfBase
_handler	vrf/v3VrfShared.h	/^         V3NtkHandler*     _handler;      \/\/ Network Handler$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_hasEvent	alg/v3AlgSimulate.h	/^      V3BoolVec                  _hasEvent;$/;"	m	class:V3AlgSimulate
_hash	bdd/myHash.h	/^      Hash<HashKey, HashData>*   _hash;$/;"	m	class:Hash::iterator
_hash	bdd/test/myHash.h	/^      Hash<HashKey, HashData>*   _hash;$/;"	m	class:Hash::iterator
_hierInfo	ntk/v3NtkHandler.h	/^      V3Vec<V3NtkHierData*>::Vec _hierInfo;$/;"	m	class:V3NtkHierInfo
_hierInfo	trans/v3NtkFlatten.h	/^      V3NtkHierInfo  _hierInfo;  \/\/ Hierarchical Information for Flattened Ntk$/;"	m	class:V3NtkFlatten
_history	cmd/v3CmdMgr.h	/^      vector<string> _history;               \/\/ Command History Copy$/;"	m	class:V3CmdMgr
_i	bdd/bddMgrV.h	/^   unsigned   _i;$/;"	m	class:BddHashKeyV
_i	bdd/test/bddMgrV.h	/^   unsigned   _i;$/;"	m	class:BddHashKeyV
_inLoop	ext/v3NtkElaborate.h	/^      V3NetId           _inLoop;    \/\/ V3NetId for the Formula "_1stSave || _saved"$/;"	m	class:V3NtkElaborate
_incDepth	vrf/v3VrfBMC.h	/^      uint32_t       _incDepth;     \/\/ Increment Depth (default = 1)$/;"	m	class:V3VrfBMC
_incDepth	vrf/v3VrfKLive.h	/^      uint32_t          _incDepth;        \/\/ Increment Depth$/;"	m	class:V3VrfKLive
_incDepth	vrf/v3VrfUMC.h	/^      uint32_t       _incDepth;     \/\/ Increment Depth (default = 1)$/;"	m	class:V3VrfUMC
_index	adt/v3Misc.h	/^      V3UI32Vec            _index;$/;"	m	class:V3PortableType
_init	alg/v3AlgSimulate.h	/^      uint32_t                   _init[2];$/;"	m	class:V3AlgSimulate
_init	ext/v3Property.h	/^      V3BitVecX*        _init;$/;"	m	class:V3CexTrace
_init	svr/v3SvrBoolector.h	/^      V3BtorExpVec   _init;      \/\/ Initial state Var storage$/;"	m	class:V3SvrBoolector
_init	svr/v3SvrMiniSat.h	/^      V3SvrMLitData  _init;      \/\/ Initial state Var storage$/;"	m	class:V3SvrMiniSat
_initMem	util/v3Usage.h	/^      double   _initMem;$/;"	m	class:V3Usage
_initState	bdd/bddMgrV.h	/^   BddNodeV         _initState;$/;"	m	class:BddMgrV
_initState	bdd/test/bddMgrV.h	/^   BddNodeV         _initState;$/;"	m	class:BddMgrV
_initSvrStat	vrf/v3VrfCITP.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfCITP
_initSvrStat	vrf/v3VrfFITP.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfFITP
_initSvrStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfIPDR
_initSvrStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _initSvrStat;     \/\/ CNF Computation$/;"	m	class:V3VrfMPDR
_initTime	v3mc/v3MCMain.h	/^   struct timeval       _initTime;     \/\/ Initial Time$/;"	m	struct:V3MCMainParam	typeref:struct:V3MCMainParam::timeval
_inputData	ntk/v3Ntk.h	/^      V3InputTable   _inputData;    \/\/ Fanin Table for V3NetId   (V3NetId, V3BVXId, V3BusId)$/;"	m	class:V3Ntk
_inputData	vrf/v3VrfIPDR.h	/^      V3BitVecX               _inputData;    \/\/ Primary Input \/ Inout Values$/;"	m	class:V3IPDRCube
_inputData	vrf/v3VrfMPDR.h	/^      V3BitVecX               _inputData;    \/\/ Primary Input \/ Inout Values$/;"	m	class:V3MPDRCube
_inputSize	v3mc/v3MCMain.h	/^   uint32_t             _inputSize;    \/\/ Number of Inputs in the Original Network$/;"	m	struct:V3MCMainParam
_inputs	ntk/v3Ntk.h	/^      V3NetVec    _inputs;$/;"	m	class:V3NtkModule
_insert	eng/minisat/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Map
_instRef	ntk/v3NtkHandler.h	/^      uint32_t             _instRef;$/;"	m	class:V3NtkHandler
_intVerbosity	ntk/v3NtkHandler.cpp	/^unsigned char V3NtkHandler::_intVerbosity = 0;$/;"	m	class:V3NtkHandler	file:
_intVerbosity	ntk/v3NtkHandler.h	/^      static unsigned char _intVerbosity;$/;"	m	class:V3NtkHandler
_inv	vrf/v3VrfShared.h	/^      V3NetTable        _inv;       \/\/ Cube Invariants (in terms of latch indices)$/;"	m	class:V3VrfSharedInv
_invConstrs	ext/v3Property.h	/^      V3ConstraintVec      _invConstrs;$/;"	m	class:V3Property
_invariants	ext/v3Property.h	/^      V3ConstraintVec      _invariants;$/;"	m	class:V3Property
_isBddBuilt	ntk/v3Ntk.h	/^      bool           _isBddBuilt;   \/\/ MODIFICATION FOR SoCV BDD$/;"	m	class:V3Ntk
_isFixed	bdd/bddMgrV.h	/^   bool             _isFixed;$/;"	m	class:BddMgrV
_isFixed	bdd/test/bddMgrV.h	/^   bool             _isFixed;$/;"	m	class:BddMgrV
_isFrozen	alg/v3AlgGeneralize.h	/^      V3BoolVec            _isFrozen;  \/\/ Frozen Net Table$/;"	m	class:V3AlgAigGeneralize
_itpAttr	vrf/v3VrfCITP.h	/^      unsigned char     _itpAttr;         \/\/ Specific Attributes for CITP$/;"	m	class:V3VrfCITP
_itpAttr	vrf/v3VrfFITP.h	/^      unsigned char     _itpAttr;         \/\/ Specific Attributes for FITP$/;"	m	class:V3VrfFITP
_itpBMCDepth	vrf/v3VrfCITP.h	/^      uint32_t          _itpBMCDepth;     \/\/ The Number of Unrolled Frames in BMC Solver$/;"	m	class:V3VrfCITP
_itpBMCDepth	vrf/v3VrfFITP.h	/^      uint32_t          _itpBMCDepth;     \/\/ The Number of Unrolled Frames in BMC Solver$/;"	m	class:V3VrfFITP
_itpBMCSvr	vrf/v3VrfCITP.h	/^      V3SvrBase*        _itpBMCSvr;       \/\/ The BMC SAT Solver (Counterexample Confirm)$/;"	m	class:V3VrfCITP
_itpBMCSvr	vrf/v3VrfFITP.h	/^      V3SvrBase*        _itpBMCSvr;       \/\/ The BMC SAT Solver (Counterexample Confirm)$/;"	m	class:V3VrfFITP
_itpBad	vrf/v3VrfCITP.h	/^      V3CITPCube*       _itpBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfCITP
_itpBad	vrf/v3VrfFITP.h	/^      V3FITPCube*       _itpBad;          \/\/ Cube for the Bad State (I0)$/;"	m	class:V3VrfFITP
_itpBadCount	vrf/v3VrfCITP.h	/^      uint32_t          _itpBadCount;     \/\/ Max Bad Cubes to be Blocked for a Given Cube$/;"	m	class:V3VrfCITP
_itpBadCount	vrf/v3VrfFITP.h	/^      uint32_t          _itpBadCount;     \/\/ Max Bad Cubes to be Blocked for a Given Cube$/;"	m	class:V3VrfFITP
_itpBadCubeStr	vrf/v3VrfCITP.h	/^      V3StrSet          _itpBadCubeStr;   \/\/ Expressions for Pending Bad Cubes$/;"	m	class:V3VrfCITP
_itpBadCubeStr	vrf/v3VrfFITP.h	/^      V3StrSet          _itpBadCubeStr;   \/\/ Expressions for Pending Bad Cubes$/;"	m	class:V3VrfFITP
_itpBlockCubes	vrf/v3VrfCITP.h	/^      V3NetTable        _itpBlockCubes;   \/\/ Blocking Cubes for Interpolants$/;"	m	class:V3VrfCITP
_itpBlockCubes	vrf/v3VrfFITP.h	/^      V3NetTable        _itpBlockCubes;   \/\/ Blocking Cubes for Interpolants$/;"	m	class:V3VrfFITP
_itpForceUAct	vrf/v3VrfCITP.h	/^      V3SvrData         _itpForceUAct;    \/\/ Activation Variable to Force Unreachability$/;"	m	class:V3VrfCITP
_itpForceUAct	vrf/v3VrfFITP.h	/^      V3SvrData         _itpForceUAct;    \/\/ Activation Variable to Force Unreachability$/;"	m	class:V3VrfFITP
_itpFrame	vrf/v3VrfCITP.h	/^      V3CITPFrameVec    _itpFrame;        \/\/ List of Frames (Ri') in CITP$/;"	m	class:V3VrfCITP
_itpFrame	vrf/v3VrfFITP.h	/^      V3FITPFrameVec    _itpFrame;        \/\/ List of Frames (Ri') in FITP$/;"	m	class:V3VrfFITP
_itpGSt	vrf/v3VrfCITP.h	/^      V3GenStruct*      _itpGSt;          \/\/ Generalization Struct$/;"	m	class:V3VrfCITP
_itpGSt	vrf/v3VrfFITP.h	/^      V3GenStruct*      _itpGSt;          \/\/ Generalization Struct$/;"	m	class:V3VrfFITP
_itpGen	vrf/v3VrfCITP.h	/^      V3AlgGeneralize*  _itpGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfCITP
_itpGen	vrf/v3VrfFITP.h	/^      V3AlgGeneralize*  _itpGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfFITP
_itpITPSvr	vrf/v3VrfCITP.h	/^      V3SvrBase*        _itpITPSvr;       \/\/ The ITP SAT Solver (Reachability Containment)$/;"	m	class:V3VrfCITP
_itpITPSvr	vrf/v3VrfFITP.h	/^      V3SvrBase*        _itpITPSvr;       \/\/ The ITP SAT Solver (Reachability Containment)$/;"	m	class:V3VrfFITP
_itpPriority	vrf/v3VrfCITP.h	/^      V3UI32Vec         _itpPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfCITP
_itpPriority	vrf/v3VrfFITP.h	/^      V3UI32Vec         _itpPriority;     \/\/ Priority List for Cut Signals$/;"	m	class:V3VrfFITP
_itpReuse	vrf/v3VrfCITP.h	/^      V3CITPFrameVec    _itpReuse;        \/\/ List of Frames Computed Before$/;"	m	class:V3VrfCITP
_itpReuse	vrf/v3VrfFITP.h	/^      V3FITPFrameVec    _itpReuse;        \/\/ List of Frames Computed Before$/;"	m	class:V3VrfFITP
_itpSim	vrf/v3VrfCITP.h	/^      V3AlgSimulate*    _itpSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfCITP
_itpSim	vrf/v3VrfFITP.h	/^      V3AlgSimulate*    _itpSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfFITP
_klChecker	vrf/v3VrfKLive.h	/^      V3VrfBase*        _klChecker;       \/\/ Formal Engine for KLiveness$/;"	m	class:V3VrfKLive
_klHandler	vrf/v3VrfKLive.h	/^      V3NtkHandler*     _klHandler;       \/\/ KLiveness Network Handler$/;"	m	class:V3VrfKLive
_klNetList	vrf/v3VrfKLive.h	/^      V3NetVec          _klNetList;       \/\/ List of V3NetId for K-Liveness Signals$/;"	m	class:V3VrfKLive
_klNtk	vrf/v3VrfKLive.h	/^      V3Ntk*            _klNtk;           \/\/ KLiveness Network$/;"	m	class:V3VrfKLive
_l	bdd/bddMgrV.h	/^   size_t     _l;$/;"	m	class:BddHashKeyV
_l	bdd/test/bddMgrV.h	/^   size_t     _l;$/;"	m	class:BddHashKeyV
_lastHandlerId	ntk/v3NtkHandler.h	/^      uint32_t       _lastHandlerId;   \/\/ Id of Last Ntk Handler $/;"	m	class:V3Handler
_lastRefIdVec	ntk/v3NtkHandler.h	/^      V3UI32Vec      _lastRefIdVec;    \/\/ Last Ref Indices from Base Ntk$/;"	m	class:V3Handler
_latchSize	v3mc/v3MCMain.h	/^   uint32_t             _latchSize;    \/\/ Number of Latches in the Original Network$/;"	m	struct:V3MCMainParam
_left	bdd/bddNodeV.h	/^   BddNodeV              _left;$/;"	m	class:BddNodeVInt
_left	bdd/test/bddNodeV.h	/^   BddNodeV              _left;$/;"	m	class:BddNodeVInt
_level	alg/v3AlgSimulate.h	/^      uint32_t                   _level;$/;"	m	class:V3AlgSimulate
_levelData	alg/v3AlgSimulate.h	/^      V3UI32Vec                  _levelData;$/;"	m	class:V3AlgSimulate
_list	adt/v3Misc.h	/^      V3PtrVec             _list;$/;"	m	class:V3PortableType
_looped	ext/v3NtkElaborate.h	/^      V3NetId           _looped;    \/\/ V3NetId for Loop Found in L2S$/;"	m	class:V3NtkElaborate
_mainParam	v3mc/v3MCMain.h	/^   V3MCMainParam*       _mainParam;    \/\/ Parameter of the Main Thread$/;"	m	struct:V3MCParam
_mandCmd	cmd/v3CmdMgr.h	/^      vector<string>    _mandCmd;$/;"	m	class:V3CmdExec
_maxDepth	vrf/v3VrfBase.h	/^      uint32_t                   _maxDepth;$/;"	m	class:V3VrfBase
_maxMemory	v3mc/v3MCMain.h	/^   double               _maxMemory;    \/\/ Total Available Memory$/;"	m	struct:V3MCMainParam
_maxMemory	vrf/v3VrfShared.h	/^      double               _maxMemory;    \/\/ Memory Bound$/;"	m	class:V3VrfSharedMem
_maxSize	stg/v3StgExtract.h	/^      uint32_t             _maxSize;   \/\/ Max Allowed State Size for Each FSM$/;"	m	class:V3FSMExtract
_maxSize	stg/v3StgFSM.h	/^      uint32_t                _maxSize;   \/\/ Maximum Allowed Number of States$/;"	m	class:V3FSMSDGDB
_maxTime	stg/v3StgExtract.h	/^      double               _maxTime;   \/\/ Maximum Time Usage on FSM Extraction$/;"	m	class:V3FSMExtract
_maxTime	v3mc/v3MCMain.h	/^   double               _maxTime;      \/\/ Runtime Limit$/;"	m	struct:V3MCMainParam
_maxTime	vrf/v3VrfBase.h	/^      double                     _maxTime;$/;"	m	class:V3VrfBase
_mexCandidate	stg/v3StgSDG.h	/^      V3BoolVec         _mexCandidate; \/\/ Mutex Candidates for MUX Candidates$/;"	m	class:V3AigSDG
_mirror	ext/v3NtkElaborate.h	/^      V3UI32Hash        _mirror;    \/\/ Mirror V3NetId for the Delay Operator$/;"	m	class:V3NtkElaborate
_mirrorBound	v3mc/v3MCMain.h	/^   V3VrfSharedBound*    _mirrorBound;  \/\/ Mirror Bound of Checkers$/;"	m	struct:V3MCMainParam
_mutex	vrf/v3VrfShared.h	/^      pthread_mutex_t         _mutex;        \/\/ Mutex for a Specific Type of Shared Data$/;"	m	class:V3VrfShared
_muxCandidate	stg/v3StgSDG.h	/^      V3UI32Vec         _muxCandidate; \/\/ MUX Candidates on AIG Network$/;"	m	class:V3AigSDG
_name	ext/v3LTLFormula.h	/^      const string         _name;$/;"	m	class:V3LTLFormula
_nameHash	ntk/v3NtkHandler.h	/^      V3StrNetHash         _nameHash;     \/\/ Hash Table for V3NetId from External Signal Name$/;"	m	class:V3NtkHandler
_netHash	ext/v3NtkElaborate.h	/^      V3PortableType    _netHash;   \/\/ Hash Table for Ntk Elaboration$/;"	m	class:V3NtkElaborate
_netHash	ntk/v3NtkHandler.h	/^      V3NetStrHash         _netHash;      \/\/ Hash Table for External Signal Name from V3NetId$/;"	m	class:V3NtkHandler
_netId	stg/v3StgFSM.h	/^      const V3NetId           _netId;     \/\/ Embraced NetId in V3SDGBase$/;"	m	class:V3FSMSDG
_netId	stg/v3StgSDG.h	/^      const V3NetId     _netId;        \/\/ NetId Corresponding to Ntk$/;"	m	class:V3SDGNode
_netWidth	ntk/v3Ntk.h	/^      V3UI32Vec            _netWidth;     \/\/ Width of Bit-Vector V3NetId$/;"	m	class:V3BvNtk
_nextCube	vrf/v3VrfCITP.h	/^      const V3CITPCube* const _nextCube;     \/\/ Successor State in the Successor Interpolant$/;"	m	class:V3CITPCube
_nextCube	vrf/v3VrfFITP.h	/^      const V3FITPCube* const _nextCube;     \/\/ Successor State in the Successor Interpolant$/;"	m	class:V3FITPCube
_nextCube	vrf/v3VrfIPDR.h	/^      const V3IPDRCube* const _nextCube;     \/\/ Successor Proof Obligation$/;"	m	class:V3IPDRCube
_nextCube	vrf/v3VrfMPDR.h	/^      const V3MPDRCube* const _nextCube;     \/\/ Successor Proof Obligation$/;"	m	class:V3MPDRCube
_nextData	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _nextData;  \/\/ The Next (bwd pointer) Element$/;"	m	class:V3GenBucket
_nextOpId	ext/v3NtkElaborate.h	/^      V3NetId           _nextOpId;  \/\/ Delay NetId for the Delay Operator$/;"	m	class:V3NtkElaborate
_nodeIndexMap	adt/v3Graph.h	/^      V3NodeIndexMap       _nodeIndexMap;$/;"	m	class:V3Graph
_nodeList	adt/v3Graph.h	/^      V3NodeVec            _nodeList;$/;"	m	class:V3Graph
_nodeList	stg/v3StgSDG.h	/^      V3SDGNodeList        _nodeList;  \/\/ List of SDG Nodes for Care Signals$/;"	m	class:V3SDG
_nodeV	bdd/bddNodeV.h	/^   size_t                  _nodeV;$/;"	m	class:BddNodeV
_nodeV	bdd/test/bddNodeV.h	/^   size_t                  _nodeV;$/;"	m	class:BddNodeV
_ntk	ntk/v3NtkHandler.h	/^      V3Ntk*               _ntk;          \/\/ Ntk Derived From Parent$/;"	m	class:V3NtkHandler
_ntk	svr/v3SvrBase.h	/^      const V3Ntk* const   _ntk;       \/\/ Network Under Verification$/;"	m	class:V3SvrBase
_ntkData	svr/v3SvrBoolector.h	/^      V3BtorExpTable _ntkData;   \/\/ Mapping between V3NetId and Solver Data$/;"	m	class:V3SvrBoolector
_ntkData	svr/v3SvrMiniSat.h	/^      V3SvrMVarTable _ntkData;   \/\/ Mapping between V3NetId and Solver Data$/;"	m	class:V3SvrMiniSat
_ntkGenStat	vrf/v3VrfKLive.h	/^      V3Stat*           _ntkGenStat;      \/\/ Network Generation$/;"	m	class:V3VrfKLive
_ntkHandlerList	ntk/v3NtkHandler.h	/^      V3HandlerVec   _ntkHandlerList;  \/\/ Ntk Handler List$/;"	m	class:V3Handler
_ntkModule	ntk/v3Ntk.h	/^      V3NtkModuleVec _ntkModule;    \/\/ Module Instance for Hierarchical Ntk$/;"	m	class:V3Ntk
_ntkName	ntk/v3NtkHandler.h	/^      string               _ntkName;      \/\/ Name of Input Ntk  (Need not to be unique)$/;"	m	class:V3NtkHandler
_ntkName	trans/v3NtkMiter.h	/^      const string   _ntkName;$/;"	m	class:V3NtkMiter
_numBuckets	bdd/myHash.h	/^   size_t                   _numBuckets;$/;"	m	class:Hash
_numBuckets	bdd/test/myHash.h	/^   size_t                   _numBuckets;$/;"	m	class:Hash
_numOfCores	v3mc/v3MCMain.h	/^      V3UI32Vec               _numOfCores;   \/\/ Total Available Cores$/;"	m	class:V3MCResource
_one	bdd/bddNodeV.cpp	/^BddNodeV BddNodeV::_one;$/;"	m	class:BddNodeV	file:
_one	bdd/bddNodeV.h	/^   static BddNodeV          _one;$/;"	m	class:BddNodeV
_one	bdd/test/bddNodeV.h	/^   static BddNodeV          _one;$/;"	m	class:BddNodeV
_opTable	ext/v3Formula.cpp	/^V3OperatorMap V3Formula::_opTable   = V3Formula::initializeOperatorMap();$/;"	m	class:V3Formula	file:
_opTable	ext/v3Formula.h	/^      static V3OperatorMap    _opTable;$/;"	m	class:V3Formula
_optCmd	cmd/v3CmdMgr.h	/^      vector<string>    _optCmd;$/;"	m	class:V3CmdExec
_orderMap	alg/v3AlgSimulate.h	/^      V3NetVec                   _orderMap;$/;"	m	class:V3AlgSimulate
_outIndexHash	ntk/v3NtkHandler.h	/^      V3IdxStrHash         _outIndexHash; \/\/ Hash Table for Output Names from Output Indices$/;"	m	class:V3NtkHandler
_outNameHash	ntk/v3NtkHandler.h	/^      V3StrIdxHash         _outNameHash;  \/\/ Hash Table for Primary Outputs from Output Names$/;"	m	class:V3NtkHandler
_outfile	util/v3Msg.h	/^      ofstream          _outfile;$/;"	m	class:V3Msg
_outputs	ntk/v3Ntk.h	/^      V3NetVec    _outputs;$/;"	m	class:V3NtkModule
_p2cMap	ext/v3NtkElaborate.h	/^      V3NetVec          _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkElaborate
_p2cMap	ntk/v3NtkHandler.h	/^            V3NetVec             _p2cMap;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_p2cMap	ntk/v3NtkSimplify.h	/^      V3NetVec    _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkSimplify
_p2cMap	trans/v3BvBlastAig.h	/^      V3NetTable     _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3BvBlastAig
_p2cMap	trans/v3BvBlastBv.h	/^      V3BvBlastBvMap    _p2cMap;       \/\/ Net Index Mapping From Parent to Current Ntk$/;"	m	class:V3BvBlastBv
_p2cMap	trans/v3NtkExpand.h	/^      V3NetTable     _p2cMap;    \/\/ V3NetId Mapping From Parent to Current Ntk$/;"	m	class:V3NtkExpand
_p2cMap	vrf/v3VrfSEC.h	/^      V3NetVec          _p2cMap;             \/\/ Mapping from old to new$/;"	m	class:V3VrfSEC
_pOutput	ext/v3NtkElaborate.h	/^      V3LTLFormulaVec   _pOutput;   \/\/ List of V3LTLFormula* for Corresponding Elaborated Output$/;"	m	class:V3NtkElaborate
_parentId	ntk/v3NtkHandler.h	/^            const uint32_t       _parentId;$/;"	m	class:V3NtkHierInfo::V3NtkHierData
_pdrActBackup	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrActBackup;    \/\/ Incremental Backup of _pdrActCount$/;"	m	class:V3VrfIPDR
_pdrActCount	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrActCount;     \/\/ List of Activation Variable Counts$/;"	m	class:V3VrfIPDR
_pdrActCount	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrActCount;     \/\/ Activation Variable Count$/;"	m	class:V3VrfMPDR
_pdrAttr	vrf/v3VrfIPDR.h	/^      unsigned char     _pdrAttr;         \/\/ Specific Attributes for MPDR$/;"	m	class:V3VrfIPDR
_pdrAttr	vrf/v3VrfMPDR.h	/^      unsigned char     _pdrAttr;         \/\/ Specific Attributes for MPDR$/;"	m	class:V3VrfMPDR
_pdrBackup	vrf/v3VrfIPDR.h	/^      V3IPDRFrameVec    _pdrBackup;       \/\/ Incremental Backup of _pdrFrame$/;"	m	class:V3VrfIPDR
_pdrBackup	vrf/v3VrfMPDR.h	/^      V3MPDRFrameVec    _pdrBackup;       \/\/ Backup Frames for Reachability Reuse$/;"	m	class:V3VrfMPDR
_pdrBad	vrf/v3VrfIPDR.h	/^      V3IPDRCube*       _pdrBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfIPDR
_pdrBad	vrf/v3VrfMPDR.h	/^      V3MPDRCube*       _pdrBad;          \/\/ Cube for the Bad State (!p)$/;"	m	class:V3VrfMPDR
_pdrFrame	vrf/v3VrfIPDR.h	/^      V3IPDRFrameVec    _pdrFrame;        \/\/ List of Frames (Ri) in Incremental PDR$/;"	m	class:V3VrfIPDR
_pdrFrame	vrf/v3VrfMPDR.h	/^      V3MPDRFrameVec    _pdrFrame;        \/\/ List of Frames (Ri) in Monolithic PDR$/;"	m	class:V3VrfMPDR
_pdrGen	vrf/v3VrfIPDR.h	/^      V3AlgGeneralize*  _pdrGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfIPDR
_pdrGen	vrf/v3VrfMPDR.h	/^      V3AlgGeneralize*  _pdrGen;          \/\/ Generalization Handler$/;"	m	class:V3VrfMPDR
_pdrInitConst	vrf/v3VrfIPDR.h	/^      V3BoolVec         _pdrInitConst;    \/\/ Initial State of a State Variable (whether it is a const)$/;"	m	class:V3VrfIPDR
_pdrInitConst	vrf/v3VrfMPDR.h	/^      V3BoolVec         _pdrInitConst;    \/\/ Initial State of a State Variable (whether it is a const)$/;"	m	class:V3VrfMPDR
_pdrInitValue	vrf/v3VrfIPDR.h	/^      V3BoolVec         _pdrInitValue;    \/\/ Initial State of a State Variable (value of the const)$/;"	m	class:V3VrfIPDR
_pdrInitValue	vrf/v3VrfMPDR.h	/^      V3BoolVec         _pdrInitValue;    \/\/ Initial State of a State Variable (value of the const)$/;"	m	class:V3VrfMPDR
_pdrPriority	vrf/v3VrfIPDR.h	/^      V3UI32Vec         _pdrPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfIPDR
_pdrPriority	vrf/v3VrfMPDR.h	/^      V3UI32Vec         _pdrPriority;     \/\/ Priority List for State Variables$/;"	m	class:V3VrfMPDR
_pdrRecycle	vrf/v3VrfIPDR.h	/^      uint32_t          _pdrRecycle;      \/\/ Upper Bound to Recycle$/;"	m	class:V3VrfIPDR
_pdrRecycle	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrRecycle;      \/\/ Upper Bound to Recycle$/;"	m	class:V3VrfMPDR
_pdrSim	vrf/v3VrfIPDR.h	/^      V3AlgSimulate*    _pdrSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfIPDR
_pdrSim	vrf/v3VrfMPDR.h	/^      V3AlgSimulate*    _pdrSim;          \/\/ Simulation Handler$/;"	m	class:V3VrfMPDR
_pdrSize	vrf/v3VrfIPDR.h	/^      uint32_t          _pdrSize;         \/\/ Input Size for the Instance$/;"	m	class:V3VrfIPDR
_pdrSize	vrf/v3VrfMPDR.h	/^      uint32_t          _pdrSize;         \/\/ Input Size for the Instance$/;"	m	class:V3VrfMPDR
_pdrSvr	vrf/v3VrfIPDR.h	/^      V3IPDRSvrList     _pdrSvr;          \/\/ List of Incremental SAT Solvers$/;"	m	class:V3VrfIPDR
_pdrSvr	vrf/v3VrfMPDR.h	/^      V3SvrBase*        _pdrSvr;          \/\/ The Monolithic SAT Solver$/;"	m	class:V3VrfMPDR
_pdrSvrBackup	vrf/v3VrfIPDR.h	/^      V3IPDRSvrList     _pdrSvrBackup;    \/\/ Incremental Backup of _pdrSvr$/;"	m	class:V3VrfIPDR
_pdrSvrData	vrf/v3VrfIPDR.h	/^      V3SvrData         _pdrSvrData;      \/\/ Solver Data of the Latest Activation Variable$/;"	m	class:V3VrfIPDR
_pdrSvrData	vrf/v3VrfMPDR.h	/^      V3SvrData         _pdrSvrData;      \/\/ Solver Data of the Latest Activation Variable$/;"	m	class:V3VrfMPDR
_peakMem	util/v3Usage.h	/^      double   _peakMem;$/;"	m	class:V3Usage
_periodUsedTime	util/v3Usage.h	/^      double   _periodUsedTime;$/;"	m	class:V3Usage
_piGenStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _piGenStat;$/;"	m	class:V3TraceSimplify
_piUnrollStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _piUnrollStat;$/;"	m	class:V3TraceSimplify
_piValue	dfx/v3DfxSimplify.h	/^      V3SimTraceVec        _piValue;$/;"	m	class:V3TraceSimplify
_preDepth	vrf/v3VrfBMC.h	/^      uint32_t       _preDepth;     \/\/ Pre-Run Depth (default = 0)$/;"	m	class:V3VrfBMC
_preDepth	vrf/v3VrfUMC.h	/^      uint32_t       _preDepth;     \/\/ Pre-Run Depth (default = 0)$/;"	m	class:V3VrfUMC
_prevData	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _prevData;  \/\/ The Prev (fwd pointer) Element$/;"	m	class:V3GenBucket
_print	vrf/v3VrfShared.h	/^      const bool        _print;     \/\/ Enable Deep Bound Printing (Only Valid for Single Property)$/;"	m	class:V3VrfSharedBound
_printMutex	vrf/v3VrfShared.cpp	/^pthread_mutex_t V3VrfShared::_printMutex  = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:V3VrfShared	file:
_printMutex	vrf/v3VrfShared.h	/^      static pthread_mutex_t  _printMutex;   \/\/ Mutex for Output Messages$/;"	m	class:V3VrfShared
_prompt	cmd/v3CmdMgr.h	/^      string         _prompt;                \/\/ Current Command Prompt$/;"	m	class:V3CmdMgr
_propagateStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _propagateStat;   \/\/ Propagation$/;"	m	class:V3VrfIPDR
_propagateStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _propagateStat;   \/\/ Propagation$/;"	m	class:V3VrfMPDR
_property	ntk/v3NtkHandler.h	/^      V3PropertyMap        _property;     \/\/ Property List$/;"	m	class:V3NtkHandler
_r	bdd/bddMgrV.h	/^   size_t     _r;$/;"	m	class:BddHashKeyV
_r	bdd/test/bddMgrV.h	/^   size_t     _r;$/;"	m	class:BddHashKeyV
_reachFail	stg/v3StgFSM.h	/^      V3BoolTable             _reachFail; \/\/ Transition Relation Table from Node Id to Node Id that are Unreachable$/;"	m	class:V3FSM
_reachStates	bdd/bddMgrV.h	/^   vector<BddNodeV> _reachStates;$/;"	m	class:BddMgrV
_reachStates	bdd/test/bddMgrV.h	/^   vector<BddNodeV> _reachStates;$/;"	m	class:BddMgrV
_reachSucc	stg/v3StgFSM.h	/^      V3BoolTable             _reachSucc; \/\/ Transition Relation Table from Node Id to Node Id that are Reachable$/;"	m	class:V3FSM
_ref	ntk/v3Ntk.h	/^      size_t      _ref;$/;"	m	class:V3NtkModule
_refCount	ntk/v3NtkHandler.h	/^      uint32_t             _refCount;$/;"	m	class:V3NtkHandler
_refCount	vrf/v3VrfShared.h	/^         uint32_t          _refCount;     \/\/ Reference Count$/;"	m	struct:V3VrfSharedNtk::V3VrfSharedNtkData
_refIdMap	ntk/v3NtkHandler.h	/^      V3Vec<V3PairType>::Vec     _refIdMap;$/;"	m	class:V3NtkHierInfo
_refStat	util/v3Usage.h	/^      V3Stat* const  _refStat;$/;"	m	class:V3Stat
_remaining	v3mc/v3MCMain.h	/^      V3UI32Vec               _remaining;    \/\/ Remaining Properties$/;"	m	class:V3MCResource
_res	v3mc/v3MCMain.h	/^   V3MCResource*        _res;          \/\/ Resource Data$/;"	m	struct:V3MCMainParam
_result	ext/v3Property.h	/^      V3VrfResult          _result;$/;"	m	class:V3Property
_result	v3mc/v3MCMain.h	/^      V3VrfResultVec    _result;    \/\/ Verification results (i.e. cex or inv, will be deleted after output)$/;"	m	class:V3MCResult
_result	v3mc/v3MCMain.h	/^   V3MCResult*          _result;       \/\/ Verification Results$/;"	m	struct:V3MCMainParam
_result	vrf/v3VrfBase.h	/^      V3VrfResultVec             _result;$/;"	m	class:V3VrfBase
_right	bdd/bddNodeV.h	/^   BddNodeV              _right;$/;"	m	class:BddNodeVInt
_right	bdd/test/bddNodeV.h	/^   BddNodeV              _right;$/;"	m	class:BddNodeVInt
_rootId	ext/v3Formula.h	/^      uint32_t                _rootId;$/;"	m	class:V3Formula
_rootId	ext/v3LTLFormula.h	/^      uint32_t             _rootId;$/;"	m	class:V3LTLFormula
_runTime	svr/v3SvrBase.h	/^      double               _runTime;   \/\/ Total Runtime in Solving$/;"	m	class:V3SvrBase
_saved	ext/v3NtkElaborate.h	/^      V3NetId           _saved;     \/\/ V3NetId of State Recorded Latch$/;"	m	class:V3NtkElaborate
_sdgDB	stg/v3StgFSM.h	/^      V3FSMSDGDB* const       _sdgDB;     \/\/ Main FSMSDGDB for FSM Extraction$/;"	m	class:V3FSM
_sdgDBList	stg/v3StgExtract.h	/^      V3FSMSDGDBList       _sdgDBList; \/\/ List of FSMSDGDB from Each Cluster$/;"	m	class:V3FSMExtract
_sdgList	stg/v3StgFSM.h	/^      V3FSMSDGList            _sdgList;   \/\/ List of Computed FSMSDGs for V3FSM$/;"	m	class:V3FSMSDGDB
_sdgMain	stg/v3StgExtract.h	/^      V3SDG* const         _sdgMain;   \/\/ Main SDG for Variable Clustering$/;"	m	class:V3FSMExtract
_sdgMain	stg/v3StgFSM.h	/^      V3SDG* const            _sdgMain;   \/\/ Main SDG Extracted from the Network$/;"	m	class:V3FSMSDGDB
_secCandidate	vrf/v3VrfSEC.h	/^      V3NetTable        _secCandidate;       \/\/ List of SEC Candidates$/;"	m	class:V3VrfSEC
_secCheckFail	vrf/v3VrfSEC.h	/^      V3BoolVec         _secCheckFail;       \/\/ List of Undecided Candidates$/;"	m	class:V3VrfSEC
_secChecker	vrf/v3VrfSEC.h	/^      V3VrfBase*        _secChecker;         \/\/ Formal Engine for SEC$/;"	m	class:V3VrfSEC
_secEQSize	vrf/v3VrfSEC.h	/^      uint32_t          _secEQSize;          \/\/ Number of Proven EQ Sets$/;"	m	class:V3VrfSEC
_secHandler	vrf/v3VrfSEC.h	/^      V3NtkHandler*     _secHandler;         \/\/ SEC Network Handler$/;"	m	class:V3VrfSEC
_secNtk	vrf/v3VrfSEC.h	/^      V3Ntk*            _secNtk;             \/\/ SEC Network$/;"	m	class:V3VrfSEC
_secSim	vrf/v3VrfSEC.h	/^      V3AlgSimulate*    _secSim;             \/\/ Simulator for SEC$/;"	m	class:V3VrfSEC
_shadow	ext/v3NtkElaborate.h	/^      V3NetVec          _shadow;    \/\/ V3NetId of Shadow Latches$/;"	m	class:V3NtkElaborate
_sharedBound	v3mc/v3MCMain.h	/^   V3VrfSharedBound*    _sharedBound;  \/\/ Shared Bound of Checkers$/;"	m	struct:V3MCMainParam
_sharedBound	vrf/v3VrfBase.h	/^      V3VrfSharedBound*          _sharedBound;$/;"	m	class:V3VrfBase
_sharedInv	v3mc/v3MCMain.h	/^   V3VrfSharedInv*      _sharedInv;    \/\/ Shared Cube Invariants$/;"	m	struct:V3MCMainParam
_sharedInv	vrf/v3VrfBase.h	/^      V3VrfSharedInv*            _sharedInv;$/;"	m	class:V3VrfBase
_sharedMem	v3mc/v3MCMain.h	/^   V3VrfSharedMem*      _sharedMem;    \/\/ Shared Memory Usage$/;"	m	struct:V3MCMainParam
_sharedMem	vrf/v3VrfBase.h	/^      V3VrfSharedMem*            _sharedMem;$/;"	m	class:V3VrfBase
_sharedNtk	v3mc/v3MCMain.h	/^   V3VrfSharedNtk*      _sharedNtk;    \/\/ Shared Network Data$/;"	m	struct:V3MCMainParam
_sharedNtk	vrf/v3VrfBase.h	/^      V3VrfSharedNtk*            _sharedNtk;$/;"	m	class:V3VrfBase
_shift	adt/v3Misc.h	/^      const uint32_t       _shift;$/;"	m	class:V3PortableType
_signature	dfx/v3DfxTrace.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3DfxCube
_signature	vrf/v3VrfCITP.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3CITPCube
_signature	vrf/v3VrfFITP.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3FITPCube
_signature	vrf/v3VrfIPDR.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3IPDRCube
_signature	vrf/v3VrfMPDR.h	/^      uint64_t                _signature;    \/\/ Subsumption Marker$/;"	m	class:V3MPDRCube
_simRecord	alg/v3AlgSimulate.h	/^      V3AigSimRecordVec _simRecord;    \/\/ Simulation Value Record$/;"	m	class:V3AlgAigSimulate
_simRecord	alg/v3AlgSimulate.h	/^      V3BvSimRecordVec  _simRecord;    \/\/ Simulation Value Record$/;"	m	class:V3AlgBvSimulate
_simStat	vrf/v3VrfSEC.h	/^      V3Stat*           _simStat;            \/\/ Simulation$/;"	m	class:V3VrfSEC
_simValue	alg/v3AlgSimulate.h	/^      V3AigSimDataVec   _simValue;     \/\/ Simulation Value for Ntk$/;"	m	class:V3AlgAigSimulate
_simValue	alg/v3AlgSimulate.h	/^      V3BvSimDataVec    _simValue;     \/\/ Simulation Value for Ntk$/;"	m	class:V3AlgBvSimulate
_simpStat	vrf/v3VrfSEC.h	/^      V3Stat*           _simpStat;           \/\/ Simplification$/;"	m	class:V3VrfSEC
_simulator	stg/v3StgFSM.h	/^      V3AlgSimulate* const    _simulator; \/\/ Simulator for (Semi-) Random Reachability Analysis$/;"	m	class:V3FSM
_size	adt/v3BitVec.h	/^      unsigned          _size;$/;"	m	class:V3BitVec
_size	adt/v3BitVec.h	/^      unsigned          _size;$/;"	m	class:V3BitVecX
_size	adt/v3Bucket.h	/^      uint32_t       _size;$/;"	m	class:V3BucketList
_size	adt/v3Bucket.h	/^      uint32_t       _size;$/;"	m	class:V3IncBucketList
_size	adt/v3Misc.h	/^      const uint32_t       _size;$/;"	m	class:V3PortableType
_size	bdd/myHash.h	/^   size_t         _size;$/;"	m	class:Cache
_size	bdd/test/myHash.h	/^   size_t         _size;$/;"	m	class:Cache
_size	ext/v3Property.h	/^      const uint32_t    _size;$/;"	m	class:V3CexTrace
_solveStat	vrf/v3VrfCITP.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfCITP
_solveStat	vrf/v3VrfFITP.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfFITP
_solveStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfIPDR
_solveStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _solveStat;       \/\/ SAT Solving$/;"	m	class:V3VrfMPDR
_solver	stg/v3StgFSM.h	/^      V3SvrBase* const        _solver;    \/\/ SAT Solver for Formal Confirmation$/;"	m	class:V3FSM
_solver	stg/v3StgFSM.h	/^      V3SvrBase* const        _solver;    \/\/ SAT Solver for Formal Confirmation$/;"	m	class:V3FSMSDGDB
_solver	vrf/v3VrfUMC.h	/^      V3SvrBase*     _solver;       \/\/ Single Instance SAT Solver$/;"	m	class:V3VrfUMC
_solverType	vrf/v3VrfBase.h	/^      V3SolverType               _solverType;$/;"	m	class:V3VrfBase
_solves	svr/v3SvrBase.h	/^      uint32_t             _solves;    \/\/ Number of Solve Called$/;"	m	class:V3SvrBase
_specuStat	vrf/v3VrfSEC.h	/^      V3Stat*           _specuStat;          \/\/ Speculative Reduction$/;"	m	class:V3VrfSEC
_startTime	util/v3Usage.h	/^      double         _startTime;$/;"	m	class:V3Stat
_statName	util/v3Usage.h	/^      const string   _statName;$/;"	m	class:V3Stat
_stateId	dfx/v3DfxTrace.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3DfxCube
_stateId	vrf/v3VrfCITP.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3CITPCube
_stateId	vrf/v3VrfFITP.h	/^      V3NetVec                _stateId;      \/\/ Cut Signal Index (id) with Value (cp)$/;"	m	class:V3FITPCube
_stateId	vrf/v3VrfIPDR.h	/^      V3NetVec                _stateId;      \/\/ State Variable Index (id) with Value (cp)$/;"	m	class:V3IPDRCube
_stateId	vrf/v3VrfMPDR.h	/^      V3NetVec                _stateId;      \/\/ State Variable Index (id) with Value (cp)$/;"	m	class:V3MPDRCube
_supports	bdd/bddMgrV.h	/^   vector<BddNodeV> _supports;$/;"	m	class:BddMgrV
_supports	bdd/test/bddMgrV.h	/^   vector<BddNodeV> _supports;$/;"	m	class:BddMgrV
_tBase	stg/v3StgSDG.h	/^      V3SDGBase* const  _tBase;        \/\/ Base Structure for True Part of MUX$/;"	m	class:V3SDGMUX
_target	dfx/v3DfxSimplify.h	/^      V3NetVec             _target;$/;"	m	class:V3TraceSimplify
_targetId	alg/v3AlgGeneralize.h	/^      V3NetVec             _targetId;  \/\/ Resolved Target NetId$/;"	m	class:V3AlgAigGeneralize
_targetId	alg/v3AlgGeneralize.h	/^      V3NetVec             _targetId;  \/\/ Resolved Target NetId$/;"	m	class:V3AlgBvGeneralize
_targets	alg/v3AlgSimulate.h	/^      V3NetVec                   _targets;$/;"	m	class:V3AlgSimulate
_terminal	bdd/bddNodeV.cpp	/^BddNodeVInt* BddNodeVInt::_terminal = 0;$/;"	m	class:BddNodeVInt	file:
_terminal	bdd/bddNodeV.h	/^   static BddNodeVInt*   _terminal;$/;"	m	class:BddNodeVInt
_terminal	bdd/test/bddNodeV.h	/^   static BddNodeVInt*   _terminal;$/;"	m	class:BddNodeVInt
_terminal	stg/v3StgFSM.h	/^      V3NetVec                _terminal;  \/\/ Set of Terminal (or Bug) States for the FSM$/;"	m	class:V3FSM
_terminals	stg/v3StgExtract.h	/^      V3NetVec             _terminals; \/\/ List of Terminal (Bug) States$/;"	m	class:V3FSMExtract
_ternaryStat	vrf/v3VrfCITP.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfCITP
_ternaryStat	vrf/v3VrfFITP.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfFITP
_ternaryStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfIPDR
_ternaryStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _ternaryStat;     \/\/ SAT Generalization$/;"	m	class:V3VrfMPDR
_threadIdx	v3mc/v3MCMain.h	/^   uint32_t             _threadIdx;    \/\/ Index of the Checker Thread$/;"	m	struct:V3MCParam
_timeAccum	util/v3Usage.h	/^      double         _timeAccum;$/;"	m	class:V3Stat
_totalMem	util/v3Usage.h	/^      double   _totalMem;$/;"	m	class:V3Usage
_totalStat	dfx/v3DfxSimplify.h	/^      V3Stat*              _totalStat;$/;"	m	class:V3TraceSimplify
_totalStat	vrf/v3VrfCITP.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfCITP
_totalStat	vrf/v3VrfFITP.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfFITP
_totalStat	vrf/v3VrfIPDR.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfIPDR
_totalStat	vrf/v3VrfKLive.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic$/;"	m	class:V3VrfKLive
_totalStat	vrf/v3VrfMPDR.h	/^      V3Stat*           _totalStat;       \/\/ Total Statistic (Should be Called Only Once)$/;"	m	class:V3VrfMPDR
_totalStat	vrf/v3VrfSEC.h	/^      V3Stat*           _totalStat;          \/\/ Total Statistic$/;"	m	class:V3VrfSEC
_totalUsedTime	util/v3Usage.h	/^      double   _totalUsedTime;$/;"	m	class:V3Usage
_tr	bdd/bddMgrV.h	/^   BddNodeV         _tr;$/;"	m	class:BddMgrV
_tr	bdd/test/bddMgrV.h	/^   BddNodeV         _tr;$/;"	m	class:BddMgrV
_traceData	alg/v3AlgSimulate.h	/^      V3AigSimTraceVec  _traceData;    \/\/ Simulation Input Sequence$/;"	m	class:V3AlgAigSimulate
_traceData	alg/v3AlgSimulate.h	/^      V3BvSimTraceVec   _traceData;    \/\/ Simulation Input Sequence$/;"	m	class:V3AlgBvSimulate
_traverse	alg/v3AlgGeneralize.h	/^      V3BoolVec            _traverse;  \/\/ Traversed Net Table$/;"	m	class:V3AlgAigGeneralize
_traverse	alg/v3AlgGeneralize.h	/^      V3BoolVec            _traverse;  \/\/ Traversed Net Table$/;"	m	class:V3AlgBvGeneralize
_tri	bdd/bddMgrV.h	/^   BddNodeV         _tri;$/;"	m	class:BddMgrV
_tri	bdd/test/bddMgrV.h	/^   BddNodeV         _tri;$/;"	m	class:BddMgrV
_trueSDG	stg/v3StgFSM.h	/^      V3FSMSDGSet             _trueSDG;   \/\/ Set of SDG for the TRUE Part$/;"	m	class:V3FSMSDG
_trueSize	stg/v3StgFSM.h	/^      uint32_t                _trueSize;  \/\/ Size of the True States$/;"	m	class:V3FSMSDG
_type	v3mc/v3MCMain.h	/^   V3MCMainType         _type;         \/\/ Type of the Main Thread$/;"	m	struct:V3MCMainParam
_typeMisc	ntk/v3Ntk.h	/^      V3TypeVec      _typeMisc;     \/\/ GateType with Misc Data$/;"	m	class:V3Ntk
_umcAttr	vrf/v3VrfUMC.h	/^      unsigned char  _umcAttr;      \/\/ Special Settings for UMC$/;"	m	class:V3VrfUMC
_undecided	alg/v3AlgGeneralize.h	/^      V3NetList            _undecided; \/\/ Extensibility Records$/;"	m	class:V3AlgGeneralize
_uniAssump	vrf/v3VrfUMC.h	/^      V3SvrDataTable _uniAssump;    \/\/ Assumptions to Enable Uniqueness for Every Pair [depth][uniIndex]$/;"	m	class:V3VrfUMC
_uniLatch	vrf/v3VrfUMC.h	/^      V3UI32Vec      _uniLatch;     \/\/ Upper Bound of Depth for the Existence of Latch in the Solver$/;"	m	class:V3VrfUMC
_uniList	vrf/v3VrfUMC.h	/^      V3UI32Vec      _uniList;      \/\/ List of Uniqueness Bounds  (Indexed by uniIndex)$/;"	m	class:V3VrfUMC
_uniqueTable	bdd/bddMgrV.h	/^   BddHash          _uniqueTable;$/;"	m	class:BddMgrV
_uniqueTable	bdd/test/bddMgrV.h	/^   BddHash          _uniqueTable;$/;"	m	class:BddMgrV
_unsvd	vrf/v3VrfShared.h	/^      uint32_t          _unsvd;     \/\/ Number of Unsolved Properties$/;"	m	class:V3VrfSharedBound
_usedCores	v3mc/v3MCMain.h	/^      V3UI32Vec               _usedCores;    \/\/ Occupied Core Numbers$/;"	m	class:V3MCResource
_var2Cube	alg/v3AlgGeneralize.h	/^      V3UI32Table       _var2Cube;$/;"	m	class:V3GenStruct
_varOrder	alg/v3AlgGeneralize.h	/^      V3GenVarOrder     _varOrder;$/;"	m	class:V3GenStruct
_varValue	alg/v3AlgGeneralize.h	/^      V3UI32Vec         _varValue;$/;"	m	class:V3GenStruct
_vrfNtk	vrf/v3VrfBase.h	/^      V3Ntk*                     _vrfNtk;$/;"	m	class:V3VrfBase
_zero	bdd/bddNodeV.cpp	/^BddNodeV BddNodeV::_zero;$/;"	m	class:BddNodeV	file:
_zero	bdd/bddNodeV.h	/^   static BddNodeV          _zero;$/;"	m	class:BddNodeV
_zero	bdd/test/bddNodeV.h	/^   static BddNodeV          _zero;$/;"	m	class:BddNodeV
abs	eng/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Clause::__anon2
abstractLevel	eng/minisat/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Solver
abstraction	eng/minisat/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Clause
act	eng/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Clause::__anon2
activity	eng/minisat/Solver.h	/^        const IntMap<Var, double>&  activity;$/;"	m	struct:Solver::VarOrderLt
activity	eng/minisat/Solver.h	/^    VMap<double>        activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Solver
activity	eng/minisat/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Clause
add	adt/v3Bucket.h	/^V3BucketList<T>::add(const uint32_t& index, const T& t) {$/;"	f	class:V3BucketList
add	adt/v3Bucket.h	/^V3IncBucketList<T>::add(const V3UI32Vec& iList, const Bucket& tList) {$/;"	f	class:V3IncBucketList
add	adt/v3Bucket.h	/^V3IncBucketList<T>::add(const uint32_t& index, const T& t) {$/;"	f	class:V3IncBucketList
addBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::addBddNodeV(const string& str, size_t n)$/;"	f	class:BddMgrV
addBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::addBddNodeV(unsigned id, size_t n)$/;"	f	class:BddMgrV
addBlockedCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::addBlockedCube(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
addBlockedCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::addBlockedCube(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
addBlockedCube	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addBlockedCube(const V3IPDRTimedCube& cube) {$/;"	f	class:V3VrfIPDR
addBlockedCube	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addBlockedCube(const V3MPDRTimedCube& cube) {$/;"	f	class:V3VrfMPDR
addBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addBoundedVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
addClause	eng/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Solver
addClause	eng/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Solver
addClause	eng/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Solver
addClause	eng/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }$/;"	f	class:Solver
addClause	eng/minisat/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Solver
addCubeToSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addCubeToSolver(const uint32_t& frame, const V3NetVec& state, const uint32_t& d) {$/;"	f	class:V3VrfIPDR
addCubeToSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addCubeToSolver(const V3NetVec& state, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
addEmptyClause	eng/minisat/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Solver
addFalseSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::addFalseSDG(V3FSMSDG* const& s) {$/;"	f	class:V3FSMSDG
addFrameInfoToSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::addFrameInfoToSolver(const uint32_t& f) {$/;"	f	class:V3VrfMPDR
addHistory	cmd/v3CmdMgr.cpp	/^V3CmdMgr::addHistory(char* cmd) {$/;"	f	class:V3CmdMgr
addLastFrameInfoToSolvers	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::addLastFrameInfoToSolvers() {$/;"	f	class:V3VrfIPDR
addSimpleBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addSimpleBoundedVerifyData(V3NetId id, uint32_t depth) {$/;"	f	class:V3SvrBase
addSimulationTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::addSimulationTrace(const V3CexTrace& cex, const bool& checkValid) {$/;"	f	class:V3VrfSEC
addSimulationTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::addSimulationTrace(const V3SimTrace& initData, const V3VrfSimTraceVec& traceData, const bool& checkValid) {$/;"	f	class:V3VrfSEC
addTrueSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::addTrueSDG(V3FSMSDG* const& s) {$/;"	f	class:V3FSMSDG
addUniqueness	vrf/v3VrfUMC.cpp	/^V3VrfUMC::addUniqueness(const uint32_t& depth, const uint32_t& uIndex, const bool& force) {$/;"	f	class:V3VrfUMC
addVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::addVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_ADD_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_ADD_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_ADD_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_ADD_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_ADD_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_ADD_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_AND_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_AND_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_AND_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_AND_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_CONST_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_CONST_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_CONST_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_CONST_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_CONST_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_CONST_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_DIV_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_DIV_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_DIV_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_DIV_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_DIV_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_DIV_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_EQUALITY_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_EQUALITY_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_EQUALITY_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_EQUALITY_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_EQUALITY_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_EQUALITY_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_FALSE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_FALSE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_FALSE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_FALSE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_FALSE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_FF_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_FF_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_FF_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_FF_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_FF_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_FF_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_GEQ_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_GEQ_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_GEQ_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_GEQ_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_GEQ_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_GEQ_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MERGE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MERGE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MERGE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MERGE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MERGE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MERGE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MODULO_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MODULO_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MODULO_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MODULO_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MODULO_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MODULO_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MULT_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MULT_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MULT_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MULT_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MULT_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MULT_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_MUX_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_MUX_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_MUX_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_MUX_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_MUX_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_MUX_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_PI_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_PI_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_PI_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_PI_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_PI_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_PI_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_AND_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_AND_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_AND_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_AND_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_AND_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_OR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_OR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_OR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_OR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_OR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_OR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_RED_XOR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_RED_XOR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_RED_XOR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_RED_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_RED_XOR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_RED_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SHL_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SHL_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SHL_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SHL_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SHL_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SHL_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SHR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SHR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SHR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SHR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SHR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SHR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SLICE_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SLICE_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SLICE_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SLICE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SLICE_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SLICE_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_SUB_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_SUB_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_SUB_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_SUB_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_SUB_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_SUB_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_XOR_Formula	svr/v3SvrBase.cpp	/^V3SvrBase::add_XOR_Formula(const V3NetId& outNet, const uint32_t& depth) {$/;"	f	class:V3SvrBase
add_XOR_Formula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::add_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
add_XOR_Formula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::add_XOR_Formula(const V3NetId& out, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
add_tmp	eng/minisat/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Solver
ael	eng/minisat/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:RegionAllocator
ael	eng/minisat/SolverTypes.h	/^    CRef          ael       (const Clause* t){ return ra.ael((uint32_t*)t); }$/;"	f	class:ClauseAllocator
aiger_decode	io/v3AigParser.cpp	/^unsigned aiger_decode(FILE* file) {$/;"	f
aiger_getnoneofch	io/v3AigParser.cpp	/^unsigned char aiger_getnoneofch(FILE* file) {$/;"	f
aiger_symbol	io/v3AigParser.cpp	/^bool aiger_symbol(FILE* file, unsigned char& c, uint32_t& index, string& name) {$/;"	f
all0	adt/v3BitVec.cpp	/^V3BitVec::all0() const {$/;"	f	class:V3BitVec
all0	adt/v3BitVec.cpp	/^V3BitVecX::all0() const {$/;"	f	class:V3BitVecX
all1	adt/v3BitVec.cpp	/^V3BitVec::all1() const {$/;"	f	class:V3BitVec
all1	adt/v3BitVec.cpp	/^V3BitVecX::all1() const {$/;"	f	class:V3BitVecX
allX	adt/v3BitVec.cpp	/^V3BitVecX::allX() const {$/;"	f	class:V3BitVecX
allX	adt/v3BitVec.h	/^      inline const bool allX() const { return !_data0 && !_data1; }$/;"	f	class:V3BitVecS
alloc	eng/minisat/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:RegionAllocator
alloc	eng/minisat/SolverTypes.h	/^    CRef alloc(const Clause& from)$/;"	f	class:ClauseAllocator
alloc	eng/minisat/SolverTypes.h	/^    CRef alloc(const vec<Lit>& ps, bool learnt = false)$/;"	f	class:ClauseAllocator
allocSolver	svr/v3SvrHandler.cpp	/^V3SvrBase* const allocSolver(const V3SolverType& type, const V3Ntk* const ntk, const bool& freeBound) {$/;"	f
analyze_stack	eng/minisat/Solver.h	/^    vec<ShrinkStackElem>analyze_stack;$/;"	m	class:Solver
analyze_toclear	eng/minisat/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Solver
and_2	svr/v3SvrSatHelper.h	/^inline void and_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
and_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId and_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
and_red	svr/v3SvrSatHelper.h	/^inline void and_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
and_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId and_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
append	eng/minisat/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f
applyAuxNetNamePrefix	ntk/v3NtkHandler.cpp	/^V3NtkHandler::applyAuxNetNamePrefix(const string& name) {$/;"	f	class:V3NtkHandler
assertBoundedVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::assertBoundedVerifyData(const V3NetVec& assertIdVec, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assertImplyUnion	svr/v3SvrBase.cpp	/^V3SvrBase::assertImplyUnion(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
assertImplyUnion	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertImplyUnion(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
assertImplyUnion	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
assertInit	svr/v3SvrBase.cpp	/^V3SvrBase::assertInit() {$/;"	f	class:V3SvrBase
assertInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertInit() {$/;"	f	class:V3SvrBoolector
assertInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertInit() {$/;"	f	class:V3SvrMiniSat
assertProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assertProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assertProperty(const size_t& var_exp, const bool& invert) {$/;"	f	class:V3SvrBase
assertProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
assertProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assertProperty(const size_t& exp, const bool& invert) {$/;"	f	class:V3SvrBoolector
assertProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
assertProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assertProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrMiniSat
assigns	eng/minisat/Solver.h	/^    VMap<lbool>         assigns;          \/\/ The current assignments.$/;"	m	class:Solver
assumeInit	svr/v3SvrBase.cpp	/^V3SvrBase::assumeInit() {$/;"	f	class:V3SvrBase
assumeInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeInit() {$/;"	f	class:V3SvrBoolector
assumeInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeInit() {$/;"	f	class:V3SvrMiniSat
assumeProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBase
assumeProperty	svr/v3SvrBase.cpp	/^V3SvrBase::assumeProperty(const size_t& var_exp, const bool& invert) {$/;"	f	class:V3SvrBase
assumeProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
assumeProperty	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeProperty(const size_t& exp, const bool& invert) {$/;"	f	class:V3SvrBoolector
assumeProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeProperty(const V3NetId& id, const bool& invert, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
assumeProperty	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeProperty(const size_t& var, const bool& invert) {$/;"	f	class:V3SvrMiniSat
assumeReachability	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::assumeReachability(const unsigned& k) {$/;"	f	class:V3VrfMPDR
assumeRelease	svr/v3SvrBase.cpp	/^V3SvrBase::assumeRelease() {$/;"	f	class:V3SvrBase
assumeRelease	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assumeRelease() {$/;"	f	class:V3SvrBoolector
assumeRelease	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assumeRelease() { _assump.clear(); }$/;"	f	class:V3SvrMiniSat
assump_solve	svr/v3SvrBase.cpp	/^V3SvrBase::assump_solve() {$/;"	f	class:V3SvrBase
assump_solve	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::assump_solve() {$/;"	f	class:V3SvrBoolector
assump_solve	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::assump_solve() {$/;"	f	class:V3SvrMiniSat
assumptions	eng/minisat/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Solver
assureLookahead	eng/minisat/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:StreamBuffer
asynch_interrupt	eng/minisat/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Solver
attachNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::attachNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
attachToNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const attachToNtk(V3NtkHandler* const handler, V3Ntk* const ntk, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& c2pMap, V3PortableType& netHash) {$/;"	f
begin	bdd/myHash.h	/^   iterator begin() const {$/;"	f	class:Hash
begin	bdd/test/myHash.h	/^   iterator begin() const {$/;"	f	class:Hash
begin	eng/minisat/IntMap.h	/^        V*       begin  ()       { return &map[0]; }$/;"	f	class:IntMap
begin	eng/minisat/IntMap.h	/^        const V* begin  () const { return &map[0]; }$/;"	f	class:IntMap
begin	eng/minisat/Options.h	/^    double begin;$/;"	m	struct:DoubleRange
begin	eng/minisat/Options.h	/^    int begin;$/;"	m	struct:IntRange
begin	eng/minisat/Options.h	/^    int64_t begin;$/;"	m	struct:Int64Range
begin_inclusive	eng/minisat/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:DoubleRange
bfsIndexFaninConeFF	ntk/v3NtkTraverse.cpp	/^void bfsIndexFaninConeFF(V3Ntk* const ntk, V3NetVec& ffList, const V3NetId& pId, V3BoolVec& m) {$/;"	f
bfsIndexFaninConeFF	ntk/v3NtkTraverse.cpp	/^void bfsIndexFaninConeFF(V3Ntk* const ntk, V3NetVec& ffList, const V3NetVec& sourceNets) {$/;"	f
bfsUpdateBackwardReachability	stg/v3StgFSM.cpp	/^V3FSM::bfsUpdateBackwardReachability() {$/;"	f	class:V3FSM
bfsUpdateForwardReachability	stg/v3StgFSM.cpp	/^V3FSM::bfsUpdateForwardReachability() {$/;"	f	class:V3FSM
bitBlast_ADD	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_ADD(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_AND	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_AND(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_CONST	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_CONST(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_DIV	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_DIV(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_DIV_MODULO	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_DIV_MODULO(const V3BvNtk* const ntk, const V3NetId& id, const bool& setRemainder) {$/;"	f	class:V3BvBlastAig
bitBlast_EQUALITY	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_EQUALITY(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_FF	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_FF(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_GEQ	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_GEQ(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MERGE	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MERGE(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MODULO	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MODULO(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MULT	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MULT(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_MUX	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_MUX(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_AND	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_AND(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_OR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_OR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_RED_XOR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_RED_XOR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SHL	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SHL(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SHR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SHR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SLICE	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SLICE(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_SUB	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_SUB(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
bitBlast_XOR	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::bitBlast_XOR(const V3BvNtk* const ntk, const V3NetId& id) {$/;"	f	class:V3BvBlastAig
blockBadCubes	vrf/v3VrfCITP.cpp	/^V3VrfCITP::blockBadCubes(const uint32_t& index) {$/;"	f	class:V3VrfCITP
blockBadCubes	vrf/v3VrfFITP.cpp	/^V3VrfFITP::blockBadCubes(const uint32_t& index) {$/;"	f	class:V3VrfFITP
blockNewCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::blockNewCube() {$/;"	f	class:V3VrfCITP
blockNewCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::blockNewCube() {$/;"	f	class:V3VrfFITP
blocker	eng/minisat/Solver.h	/^        Lit  blocker;$/;"	m	struct:Solver::Watcher
borrow_2	svr/v3SvrSatHelper.h	/^inline void borrow_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& B)$/;"	f
borrow_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId borrow_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& B)$/;"	f
borrow_2_woB	svr/v3SvrSatHelper.h	/^inline void borrow_2_woB(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
borrow_2_woB	trans/v3BvBlastAigHelper.h	/^inline const V3NetId borrow_2_woB(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
bucket	eng/minisat/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Map
bucket	eng/minisat/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:CMap
bucketNum	bdd/myHash.h	/^   size_t bucketNum(const HashKey& k) const {$/;"	f	class:Hash
bucketNum	bdd/test/myHash.h	/^   size_t bucketNum(const HashKey& k) const {$/;"	f	class:Hash
bucket_count	eng/minisat/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Map
bucket_count	eng/minisat/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:CMap
buckets	adt/v3Bucket.h	/^      inline const uint32_t buckets() const { return _elements.size(); }$/;"	f	class:V3BucketList
buckets	adt/v3Bucket.h	/^      inline const uint32_t buckets() const { return _elements.size(); }$/;"	f	class:V3IncBucketList
budgetOff	eng/minisat/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Solver
buf	eng/minisat/ParseUtils.h	/^    unsigned char* buf;$/;"	m	class:StreamBuffer
buf	eng/minisat/Queue.h	/^    vec<T>  buf;$/;"	m	class:Queue
buf	svr/v3SvrSatHelper.h	/^inline void buf(Solver* SS, const Lit& a, const Lit& b)$/;"	f
buf	trans/v3BvBlastAigHelper.h	/^inline const V3NetId buf(V3Ntk* const ntk, const V3NetId& a)$/;"	f
buffer_size	eng/minisat/ParseUtils.h	/^    enum { buffer_size = 64*1024 };$/;"	e	enum:StreamBuffer::__anon4
build	eng/minisat/Heap.h	/^    void build(const vec<K>& ns) {$/;"	f	class:Heap
buildBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::buildBdd(const V3NetId& netId) {$/;"	f	class:V3Ntk
buildNtkBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::buildNtkBdd() {$/;"	f	class:V3Ntk
buildPImage	prove/proveBdd.cpp	/^BddMgrV::buildPImage( int level )$/;"	f	class:BddMgrV
buildPInitialState	prove/proveBdd.cpp	/^BddMgrV::buildPInitialState()$/;"	f	class:BddMgrV
buildPTransRelation	prove/proveBdd.cpp	/^BddMgrV::buildPTransRelation()$/;"	f	class:BddMgrV
bus	ntk/v3Type.h	/^      uint32_t    bus[2];$/;"	m	union:V3PairType::__anon7
bv_and	adt/v3BitVec.cpp	/^V3BitVecS::bv_and(const V3BitVecS& v1, const bool& inv1, const V3BitVecS& v2, const bool& inv2) {$/;"	f	class:V3BitVecS
bv_concat	adt/v3BitVec.cpp	/^V3BitVecX::bv_concat(const V3BitVecX& a) const {$/;"	f	class:V3BitVecX
bv_cover	adt/v3BitVec.cpp	/^V3BitVecX::bv_cover(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_cover	adt/v3BitVec.h	/^      inline const bool bv_cover(const V3BitVecS& v) const { return !((_data0 & ~v._data0) | (_data1 & ~v._data1)); }$/;"	f	class:V3BitVecS
bv_divided_by	adt/v3BitVec.cpp	/^V3BitVecX::bv_divided_by(const V3BitVecX& b, const bool& setRemainder) {$/;"	f	class:V3BitVecX
bv_equal	adt/v3BitVec.cpp	/^V3BitVecX::bv_equal(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_full	adt/v3BitVec.h	/^      inline const bool bv_full() const { return (_data0 == 0ul || _data0 == ~0ul) && (_data1 == 0ul || _data1 == ~0ul); }$/;"	f	class:V3BitVecS
bv_geq	adt/v3BitVec.cpp	/^V3BitVecX::bv_geq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_gt	adt/v3BitVec.cpp	/^V3BitVecX::bv_gt(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_intersect	adt/v3BitVec.cpp	/^V3BitVecX::bv_intersect(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_leq	adt/v3BitVec.cpp	/^V3BitVecX::bv_leq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_lt	adt/v3BitVec.cpp	/^V3BitVecX::bv_lt(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
bv_red_and	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_and() const {$/;"	f	class:V3BitVecX
bv_red_or	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_or() const {$/;"	f	class:V3BitVecX
bv_red_xor	adt/v3BitVec.cpp	/^V3BitVecX::bv_red_xor() const {$/;"	f	class:V3BitVecX
bv_select	adt/v3BitVec.cpp	/^V3BitVecX::bv_select(const V3BitVecX& f, const V3BitVecX& t) const {$/;"	f	class:V3BitVecX
bv_slice	adt/v3BitVec.cpp	/^V3BitVecX::bv_slice(const unsigned& msb, const unsigned& lsb) const {$/;"	f	class:V3BitVecX
ca	eng/minisat/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Solver::WatcherDeleted
ca	eng/minisat/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Solver
ca	eng/minisat/SolverTypes.h	/^    const ClauseAllocator& ca;$/;"	m	class:ClauseIterator
calcAbstraction	eng/minisat/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Clause
callEmptyVirtual	util/v3Msg.h	/^static inline const int callEmptyVirtual(const string& functionName) {$/;"	f
cap	eng/minisat/Alloc.h	/^    uint32_t  cap;$/;"	m	class:RegionAllocator
cap	eng/minisat/Map.h	/^    int        cap;$/;"	m	class:Map
cap	eng/minisat/Vec.h	/^    Size cap;$/;"	m	class:vec
capacity	eng/minisat/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:RegionAllocator
capacity	eng/minisat/Vec.h	/^    int      capacity (void) const   { return cap; }$/;"	f	class:vec
capacity	eng/minisat/Vec.h	/^void vec<T,_Size>::capacity(Size min_cap) {$/;"	f	class:vec
carry_2	svr/v3SvrSatHelper.h	/^inline void carry_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& c)$/;"	f
carry_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId carry_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& c)$/;"	f
carry_2_woc	svr/v3SvrSatHelper.h	/^inline void carry_2_woc(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
carry_2_woc	trans/v3BvBlastAigHelper.h	/^inline const V3NetId carry_2_woc(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
category	eng/minisat/Options.h	/^    const char* category;$/;"	m	class:Option
ccmin_mode	eng/minisat/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Solver
check	bdd/myHash.h	/^   bool check(const HashKey& k, HashData& n) const {$/;"	f	class:Hash
check	bdd/test/myHash.h	/^   bool check(const HashKey& k, HashData& n) const {$/;"	f	class:Hash
check	stg/v3StgFSM.cpp	/^V3FSM::check(V3SvrBase* const solver) const {$/;"	f	class:V3FSM
checkBMCReachability	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkBMCReachability(const V3NetVec& state) {$/;"	f	class:V3VrfCITP
checkBMCReachability	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkBMCReachability(const V3NetVec& state) {$/;"	f	class:V3VrfFITP
checkCap	eng/minisat/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Map
checkCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkCmd(const string& check) const {$/;"	f	class:V3CmdExec
checkCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkCommonCounterexample	vrf/v3VrfBase.cpp	/^V3VrfBase::checkCommonCounterexample(const uint32_t& p, const V3CexTrace& cex) {$/;"	f	class:V3VrfBase
checkCommonProof	vrf/v3VrfBase.cpp	/^V3VrfBase::checkCommonProof(const uint32_t& p, const V3NetTable& invList, const bool& checkInitial) {$/;"	f	class:V3VrfBase
checkCompleteFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::checkCompleteFSMs() const {$/;"	f	class:V3FSMExtract
checkCounterExample	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkCounterExample() {$/;"	f	class:V3VrfCITP
checkCounterExample	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkCounterExample() {$/;"	f	class:V3VrfFITP
checkGarbage	eng/minisat/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Solver
checkGarbage	eng/minisat/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Solver
checkIteTerminal	bdd/bddMgrV.cpp	/^BddMgrV::checkIteTerminal$/;"	f	class:BddMgrV
checkMandCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkMandCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkMem	util/v3Usage.h	/^      const double checkMem() const {$/;"	f	class:V3Usage
checkOptCmd	cmd/v3CmdMgr.cpp	/^V3CmdExec::checkOptCmd(const string& check, size_t idx) const {$/;"	f	class:V3CmdExec
checkReachability	vrf/v3VrfCITP.cpp	/^V3VrfCITP::checkReachability(V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
checkReachability	vrf/v3VrfFITP.cpp	/^V3VrfFITP::checkReachability(const V3NetVec& state) {$/;"	f	class:V3VrfFITP
checkReachability	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::checkReachability(const uint32_t& frame, const V3NetVec& cubeState, const bool& extend) {$/;"	f	class:V3VrfIPDR
checkReachability	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::checkReachability(const uint32_t& frame, const V3NetVec& cubeState, const bool& extend) {$/;"	f	class:V3VrfMPDR
checkTick	util/v3Usage.h	/^      const double checkTick() const {$/;"	f	class:V3Usage
claBumpActivity	eng/minisat/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Solver
claDecayActivity	eng/minisat/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Solver
cla_inc	eng/minisat/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Solver
clauseWord32Size	eng/minisat/SolverTypes.h	/^    static uint32_t clauseWord32Size(int size, bool has_extra){$/;"	f	class:ClauseAllocator
clause_decay	eng/minisat/Solver.h	/^    double    clause_decay;$/;"	m	class:Solver
clauses	eng/minisat/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Solver
clausesBegin	eng/minisat/Solver.h	/^inline ClauseIterator Solver::clausesBegin() const { return ClauseIterator(ca, &clauses[0]); }$/;"	f	class:Solver
clausesEnd	eng/minisat/Solver.h	/^inline ClauseIterator Solver::clausesEnd  () const { return ClauseIterator(ca, &clauses[clauses.size()]); }$/;"	f	class:Solver
clauses_literals	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
clean	eng/minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::clean(const K& idx)$/;"	f	class:OccLists
cleanAll	eng/minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::cleanAll()$/;"	f	class:OccLists
clear	adt/v3BitVec.cpp	/^V3BitVec::clear() {$/;"	f	class:V3BitVec
clear	adt/v3BitVec.cpp	/^V3BitVecX::clear() {$/;"	f	class:V3BitVecX
clear	adt/v3BitVec.h	/^      inline void clear() { _data0 = _data1 = 0; }$/;"	f	class:V3BitVecS
clear	adt/v3Bucket.h	/^V3BucketList<T>::clear() {$/;"	f	class:V3BucketList
clear	adt/v3Bucket.h	/^V3IncBucketList<T>::clear() {$/;"	f	class:V3IncBucketList
clear	alg/v3AlgGeneralize.cpp	/^V3GenStruct::clear(const V3NetVec& baseCube) {$/;"	f	class:V3GenStruct
clear	eng/minisat/Heap.h	/^    void clear(bool dispose = false) $/;"	f	class:Heap
clear	eng/minisat/IntMap.h	/^        void     clear       (bool free = false){$/;"	f	class:IntSet
clear	eng/minisat/IntMap.h	/^        void     clear  (bool dispose = false) { map.clear(dispose); }$/;"	f	class:IntMap
clear	eng/minisat/Map.h	/^    void clear  () {$/;"	f	class:Map
clear	eng/minisat/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Queue
clear	eng/minisat/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:CMap
clear	eng/minisat/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:OccLists
clear	eng/minisat/Vec.h	/^void vec<T,_Size>::clear(bool dealloc) {$/;"	f	class:vec
clear	ext/v3Property.h	/^      inline void clear() { if (isCex()) delete getCexTrace(); \/*else if (isInv()) delete getIndInv();*\/ _cexOrInv = 0; }$/;"	f	class:V3VrfResult
clear	ntk/v3NtkHandler.h	/^      inline void clear() { clearMap(); _hierInfo.clear(); clearRefId(); }$/;"	f	class:V3NtkHierInfo
clearCubeList	vrf/v3VrfCITP.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3CITPFrame
clearCubeList	vrf/v3VrfIPDR.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3IPDRFrame
clearCubeList	vrf/v3VrfMPDR.h	/^      inline void clearCubeList() { _cubeList.clear(); }$/;"	f	class:V3MPDRFrame
clearCutSignals	ntk/v3Ntk.h	/^      inline void clearCutSignals() { _cutSignals.clear(); }$/;"	f	class:V3Ntk
clearDepFF	stg/v3StgSDG.h	/^      inline void clearDepFF() { _depFFSet.clear(); }$/;"	f	class:V3SDGBase
clearDepMux	stg/v3StgSDG.h	/^      inline void clearDepMux() { _depMuxSet.clear(); }$/;"	f	class:V3SDGBase
clearGraph	adt/v3Graph.h	/^V3Graph<T>::clearGraph() {$/;"	f	class:V3Graph
clearInterrupt	eng/minisat/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Solver
clearMap	ntk/v3NtkHandler.h	/^      inline void clearMap() { for (uint32_t i = 0; i < getNtkSize(); ++i) delete _hierInfo[i]; }$/;"	f	class:V3NtkHierInfo
clearRefId	ntk/v3NtkHandler.h	/^      inline void clearRefId() { _refIdMap.clear(); }$/;"	f	class:V3NtkHierInfo
clearResult	vrf/v3VrfBase.h	/^      inline void clearResult(const uint32_t& i) { assert (i < _result.size()); _result[i].clear(); }$/;"	f	class:V3VrfBase
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::clearSource(const V3NetId& id, const bool& random) {$/;"	f	class:V3AlgAigSimulate
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::clearSource(const V3NetId& id, const bool& random) {$/;"	f	class:V3AlgBvSimulate
clearSource	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::clearSource(const V3NetId& id, const bool& random) {}$/;"	f	class:V3AlgSimulate
clearState	vrf/v3VrfCITP.h	/^      inline void clearState() { _signature = 0; }$/;"	f	class:V3CITPCube
clearState	vrf/v3VrfFITP.h	/^      inline void clearState() { _signature = 0; }$/;"	f	class:V3FITPCube
closeDofile	cmd/v3CmdMgr.h	/^      void closeDofile() { _dofile.close(); _dofile.clear(); }$/;"	f	class:V3CmdMgr
collectFaninFF	stg/v3StgSDG.cpp	/^V3SDG::collectFaninFF(V3SDGBase* const node, V3SDGBase* const depNode) {$/;"	f	class:V3SDG
collectFaninMuxFF	stg/v3StgSDG.cpp	/^V3SDG::collectFaninMuxFF(V3SDGBase* const node, V3SDGBase* const depNode) {$/;"	f	class:V3SDG
collectLeafFormula	ext/v3Formula.cpp	/^V3Formula::collectLeafFormula(V3UI32Set& netSet) const {$/;"	f	class:V3Formula
collectLeafFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::collectLeafFormula(V3UI32Set& netSet) const {$/;"	f	class:V3LTLFormula
collectStateNets	stg/v3StgFSM.cpp	/^V3FSM::collectStateNets(V3FSMSDG* const sdg, V3UI32Set& stateNets) const {$/;"	f	class:V3FSM
collectStateNets	stg/v3StgFSM.cpp	/^V3FSM::collectStateNets(V3UI32Set& stateNets) const {$/;"	f	class:V3FSM
combineConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineConstraints(const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
combineConstraintsToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineConstraintsToOutputs(const uint32_t& pIndex, const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
combineConstraintsToOutputs	v3mc/v3MCElaborate.cpp	/^void combineConstraintsToOutputs(V3Ntk* const ntk, const V3UI32Vec& poList, const V3NetVec& constr) {$/;"	f
combineFSMInvariantsToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineFSMInvariantsToOutputs(const uint32_t& pIndex, V3FSM* const fsm) {$/;"	f	class:V3NtkElaborate
combineInvariantToOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::combineInvariantToOutputs(const uint32_t& pIndex, const V3NetVec& invList) {$/;"	f	class:V3NtkElaborate
compare_generate	trans/v3BvBlastAigHelper.h	/^inline const V3NetId compare_generate(V3Ntk* const ntk, const V3NetVec& e, const V3NetVec& c)$/;"	f
computeFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::computeFSMSDG(V3FSMSDG* const mux, V3NetVec& parentNets) {$/;"	f	class:V3FSMSDGDB
computeFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::computeFSMSDG(const V3NetId& id, V3NetVec& parentNets, const V3FSMSDGMap& siblingMap) {$/;"	f	class:V3FSMSDGDB
computeFanout	ntk/v3NtkTraverse.cpp	/^void computeFanout(V3Ntk* const ntk, V3NetTable& outputTable, const V3NetVec& targetNets) {$/;"	f
computeLatchBoundsForUniqueness	vrf/v3VrfUMC.cpp	/^V3VrfUMC::computeLatchBoundsForUniqueness(const uint32_t& depth) {$/;"	f	class:V3VrfUMC
computeLevel	ntk/v3NtkTraverse.cpp	/^const uint32_t computeLevel(V3Ntk* const ntk, V3UI32Vec& levelData, const V3NetVec& targetNets) {$/;"	f
computeSimTrace	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::computeSimTrace(const V3CexTrace& cex) {$/;"	f	class:V3TraceSimplify
computeTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::computeTrace(const V3CexTrace& cex, V3SimTrace& initData, V3VrfSimTraceVec& traceData) {$/;"	f	class:V3VrfSEC
computeTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::computeTrace(const V3SimTrace& initData, const V3VrfSimTraceVec& traceData, const uint32_t& idx) {$/;"	f	class:V3VrfSEC
computeTraceData	dfx/v3DfxTrace.cpp	/^void computeTraceData(V3NtkHandler* const handler, const V3CexTrace& cex, V3SimTraceVec& inVec, V3SimTraceVec& flopVec) {$/;"	f
conflict	eng/minisat/Solver.h	/^    LSet       conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Solver
conflict_budget	eng/minisat/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Solver
conflicts	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
consistencyCheck	vrf/v3VrfBase.cpp	/^V3VrfBase::consistencyCheck() const {$/;"	f	class:V3VrfBase
constructAigSDG	stg/v3StgSDG.cpp	/^V3AigSDG::constructAigSDG(const V3NetId& id, V3SDGBase* const n) {$/;"	f	class:V3AigSDG
constructBvSDG	stg/v3StgSDG.cpp	/^V3SDG::constructBvSDG(const V3NetId& id, V3SDGBase* const n) {$/;"	f	class:V3SDG
constructInputFSMSDG	stg/v3StgExtract.cpp	/^V3FSMExtract::constructInputFSMSDG(V3NtkHandler* const handler, const string& fileName) {$/;"	f	class:V3FSMExtract
constructSDG	stg/v3StgSDG.cpp	/^V3AigSDG::constructSDG(const V3NetId& id) {$/;"	f	class:V3AigSDG
constructSDG	stg/v3StgSDG.cpp	/^V3SDG::constructSDG(const V3NetId& id) {$/;"	f	class:V3SDG
constructStandardFSMSDG	stg/v3StgExtract.cpp	/^V3FSMExtract::constructStandardFSMSDG() {$/;"	f	class:V3FSMExtract
containNode	bdd/bddNodeV.cpp	/^BddNodeV::containNode(unsigned bLevel, unsigned eLevel) const$/;"	f	class:BddNodeV
containNodeRecur	bdd/bddNodeV.cpp	/^BddNodeV::containNodeRecur(unsigned bLevel, unsigned eLevel) const$/;"	f	class:BddNodeV
copy	adt/v3BitVec.cpp	/^V3BitVec::copy(V3BitVec& b) const {$/;"	f	class:V3BitVec
copy	adt/v3BitVec.cpp	/^V3BitVecX::copy(V3BitVecX& b) const {$/;"	f	class:V3BitVecX
copy	eng/minisat/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f
copy	eng/minisat/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f
copyTo	eng/minisat/IntMap.h	/^        void     copyTo (IntMap& to) const     { map.copyTo(to.map); to.index = index; }$/;"	f	class:IntMap
copyTo	eng/minisat/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (Size i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:vec
copyV3Ntk	ntk/v3NtkConstruct.cpp	/^V3Ntk* const copyV3Ntk(V3Ntk* const& ntk) {$/;"	f
countCube	bdd/bddNodeV.cpp	/^BddNodeV::countCube() const$/;"	f	class:BddNodeV
countCubeRecur	bdd/bddNodeV.cpp	/^BddNodeV::countCubeRecur(bool phase, map<size_t, size_t>& numCubeMap) const$/;"	f	class:BddNodeV
cp	ntk/v3Type.h	/^   uint32_t    cp :  1;$/;"	m	struct:V3NetId
cpuTime	eng/minisat/System.h	/^static inline double cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f
cpuTime	eng/minisat/System.h	/^static inline double cpuTime(void) {$/;"	f
createAigAndGate	ntk/v3NtkConstruct.cpp	/^const bool createAigAndGate(V3AigNtk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& id2) {$/;"	f
createAigFalseGate	ntk/v3NtkConstruct.cpp	/^const bool createAigFalseGate(V3AigNtk* const ntk, const V3NetId& id) {$/;"	f
createBvConstGate	ntk/v3NtkConstruct.cpp	/^const bool createBvConstGate(V3BvNtk* const ntk, const V3NetId& id, const string& value_exp) {$/;"	f
createBvMuxGate	ntk/v3NtkConstruct.cpp	/^const bool createBvMuxGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& fId, const V3NetId& tId, const V3NetId& sId) {$/;"	f
createBvPairGate	ntk/v3NtkConstruct.cpp	/^const bool createBvPairGate(V3BvNtk* const ntk, const V3GateType& type, const V3NetId& id, $/;"	f
createBvReducedGate	ntk/v3NtkConstruct.cpp	/^const bool createBvReducedGate(V3BvNtk* const ntk, const V3GateType& type, const V3NetId& id, const V3NetId& id1) {$/;"	f
createBvSliceGate	ntk/v3NtkConstruct.cpp	/^const bool createBvSliceGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& id1, uint32_t msb, uint32_t lsb) {$/;"	f
createClock	ntk/v3Ntk.cpp	/^V3Ntk::createClock(const V3NetId& id) {$/;"	f	class:V3Ntk
createConst	ntk/v3Ntk.cpp	/^V3Ntk::createConst(const V3NetId& id) {$/;"	f	class:V3Ntk
createConstrOutputs	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::createConstrOutputs(const V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
createGate	ntk/v3Ntk.cpp	/^V3Ntk::createGate(const V3GateType& type, const V3NetId& id) {$/;"	f	class:V3Ntk
createIOExtensionGate	ntk/v3NtkConstruct.cpp	/^const bool createIOExtensionGate(V3BvNtk* const ntk, const V3NetId& id, const V3NetId& id1) {$/;"	f
createInout	ntk/v3Ntk.cpp	/^V3Ntk::createInout(const V3NetId& id) {$/;"	f	class:V3Ntk
createInout	ntk/v3NtkConstruct.cpp	/^const bool createInout(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createInput	ntk/v3Ntk.cpp	/^V3Ntk::createInput(const V3NetId& id) {$/;"	f	class:V3Ntk
createInput	ntk/v3NtkConstruct.cpp	/^const bool createInput(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createLatch	ntk/v3Ntk.cpp	/^V3Ntk::createLatch(const V3NetId& id) {$/;"	f	class:V3Ntk
createModule	ntk/v3Ntk.cpp	/^V3Ntk::createModule(V3NtkModule* const module) {$/;"	f	class:V3Ntk
createModule	ntk/v3NtkConstruct.cpp	/^const bool createModule(V3Ntk* const ntk, const V3NetVec& inputs, const V3NetVec& outputs, $/;"	f
createNet	ntk/v3Ntk.cpp	/^V3BvNtk::createNet(const uint32_t& width) {$/;"	f	class:V3BvNtk
createNet	ntk/v3Ntk.cpp	/^V3Ntk::createNet(const uint32_t& width) {$/;"	f	class:V3Ntk
createNet	ntk/v3NtkConstruct.cpp	/^const V3NetId createNet(V3Ntk* const ntk, uint32_t width) {$/;"	f
createNet	ntk/v3NtkInput.cpp	/^V3NtkInput::createNet(const string& netName, uint32_t width) {$/;"	f	class:V3NtkInput
createNetExtensionGate	ntk/v3NtkConstruct.cpp	/^const V3NetId createNetExtensionGate(V3BvNtk* const ntk, const V3NetId& id, const uint32_t& width) {$/;"	f
createOutput	ntk/v3Ntk.cpp	/^V3Ntk::createOutput(const V3NetId& id) {$/;"	f	class:V3Ntk
createOutput	ntk/v3NtkConstruct.cpp	/^const bool createOutput(V3Ntk* const ntk, const V3NetId& id) {$/;"	f
createSDGFromSpec	stg/v3StgFSM.cpp	/^createSDGFromSpec(V3Ntk* const ntk, const V3StrVec& tokens, uint32_t& index) {$/;"	f
createSuccessor	ext/v3Formula.cpp	/^V3Formula::createSuccessor(V3NtkHandler* const handler) const {$/;"	f	class:V3Formula
createSuccessor	ext/v3LTLFormula.cpp	/^V3LTLFormula::createSuccessor(V3NtkHandler* const handler) const {$/;"	f	class:V3LTLFormula
createV3AndGate	ntk/v3NtkConstruct.cpp	/^const bool createV3AndGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& id2) {$/;"	f
createV3BufGate	ntk/v3NtkConstruct.cpp	/^const bool createV3BufGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1) {$/;"	f
createV3FFGate	ntk/v3NtkConstruct.cpp	/^const bool createV3FFGate(V3Ntk* const ntk, const V3NetId& id, const V3NetId& id1, const V3NetId& init_id) {$/;"	f
createV3Ntk	ntk/v3NtkConstruct.cpp	/^V3Ntk* const createV3Ntk(const bool& isBv) {$/;"	f
cref	eng/minisat/Solver.h	/^        CRef cref;$/;"	m	struct:Solver::Watcher
crefs	eng/minisat/SolverTypes.h	/^    const CRef*            crefs;$/;"	m	class:ClauseIterator
cycleSimulateResult	vrf/v3VrfResult.cpp	/^const int cycleSimulateResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
data	eng/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Map::Pair
data	eng/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Clause	typeref:union:Clause::__anon2
data	eng/minisat/Vec.h	/^    T*   data;$/;"	m	class:vec
dcBits	adt/v3BitVec.cpp	/^V3BitVecX::dcBits() const {$/;"	f	class:V3BitVecX
debug	eng/minisat/SolverTypes.h	/^    void debug(){$/;"	f	class:CMap
debugValues	stg/v3StgFSM.cpp	/^V3FSM::debugValues(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3FSM
decInstRef	ntk/v3NtkHandler.h	/^      inline void decInstRef() { assert (_instRef); --_instRef; }$/;"	f	class:V3NtkHandler
decOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::decOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
decRefCount	bdd/bddNodeV.h	/^   void decRefCount() { --_refCount; }$/;"	f	class:BddNodeVInt
decRefCount	bdd/test/bddNodeV.h	/^   void decRefCount() { --_refCount; }$/;"	f	class:BddNodeVInt
decRefCount	ntk/v3NtkHandler.h	/^      inline void decRefCount() { assert (_refCount); --_refCount; }$/;"	f	class:V3NtkHandler
dec_vars	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
decision	eng/minisat/Solver.h	/^    VMap<char>          decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Solver
decisionLevel	eng/minisat/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Solver
decisions	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
decodeStateToNetId	stg/v3StgFSM.cpp	/^V3FSM::decodeStateToNetId(const V3FSMSDG* const sdg, const uint32_t& state, V3NetVec& netIdVec) const {$/;"	f	class:V3FSM
decodeStateToNetId	stg/v3StgFSM.cpp	/^V3FSM::decodeStateToNetId(const uint32_t& state, V3NetVec& netIdVec) const {$/;"	f	class:V3FSM
decrease	eng/minisat/Heap.h	/^    void decrease  (K k) { assert(inHeap(k)); percolateUp  (indices[k]); }$/;"	f	class:Heap
deleteEdge	adt/v3Graph.h	/^V3Graph<T>::deleteEdge(const T& f, const T& t) {$/;"	f	class:V3Graph
deleted	eng/minisat/SolverTypes.h	/^    Deleted                  deleted;$/;"	m	class:OccLists
description	eng/minisat/Options.h	/^    const char* description;$/;"	m	class:Option
dfsBuildNtkFromQuteRTL	io/v3NtkQuteRTL.cpp	/^const V3NetId dfsBuildNtkFromQuteRTL(V3NtkInput* const quteHandler, CktOutPin* const OutPin, const bool& a2s) {$/;"	f
dfsComputeFanout	ntk/v3NtkTraverse.cpp	/^void dfsComputeFanout(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetTable& outputTable) {$/;"	f
dfsComputeLevel	ntk/v3NtkTraverse.cpp	/^void dfsComputeLevel(V3Ntk* const ntk, V3NetVec& orderMap, V3UI32Vec& levelData) {$/;"	f
dfsConstructConstAssignments	stg/v3StgExtract.cpp	/^const bool dfsConstructConstAssignments(V3Ntk* const ntk, const V3NetId& ffId, const V3NetId& id, bool ok, V3NetVec& stateNets) {$/;"	f
dfsGeneralOrder	ntk/v3NtkTraverse.cpp	/^void dfsGeneralOrder(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetVec& orderMap) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetId& pId, const V3BoolVec& insensitiveList, V3BoolVec& m) {$/;"	f
dfsMarkFaninCone	ntk/v3NtkTraverse.cpp	/^void dfsMarkFaninCone(V3Ntk* const ntk, const V3NetTable& idGroup, V3BoolTable& v) {$/;"	f
dfsNtkForGeneralOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForGeneralOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& allNets) {$/;"	f
dfsNtkForReductionOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForReductionOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& reduceLatch) {$/;"	f
dfsNtkForSimulationOrder	ntk/v3NtkTraverse.cpp	/^const uint32_t dfsNtkForSimulationOrder(V3Ntk* const ntk, V3NetVec& orderMap, const V3NetVec& targetNets, const bool& allNets) {$/;"	f
dfsOrder	ntk/v3NtkBdd.cpp	/^void V3Ntk::dfsOrder(const V3NetId& id, V3NetVec& nets) {$/;"	f	class:V3Ntk
dfsSimulationOrder	ntk/v3NtkTraverse.cpp	/^void dfsSimulationOrder(V3Ntk* const ntk, const V3NetId& pId, V3BoolVec& m, V3NetVec& orderMap) {$/;"	f
dirties	eng/minisat/SolverTypes.h	/^    vec<K>                   dirties;$/;"	m	class:OccLists
dirty	eng/minisat/SolverTypes.h	/^    IntMap<K, char, MkIndex> dirty;$/;"	m	class:OccLists
dotToPng	util/v3FileUtil.h	/^static inline void dotToPng(const string fileName) {$/;"	f
dotToPs	util/v3FileUtil.h	/^static inline void dotToPs(const string fileName) {$/;"	f
drand	eng/minisat/Rnd.h	/^static inline double drand(double& seed)$/;"	f
drand	eng/minisat/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Solver
drawBdd	bdd/bddMgrV.cpp	/^BddMgrV::drawBdd(const string& name, const string& fileName) const$/;"	f	class:BddMgrV
drawBdd	bdd/bddNodeV.cpp	/^BddNodeV::drawBdd(const string& name, ofstream& ofile) const$/;"	f	class:BddNodeV
drawBddRecur	bdd/bddNodeV.cpp	/^BddNodeV::drawBddRecur(ofstream& ofile) const$/;"	f	class:BddNodeV
duplicateGeneralInit	ntk/v3NtkDuplicate.cpp	/^void duplicateGeneralInit(V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& orderMap, const bool& reduceON) {$/;"	f
duplicateInputGates	ntk/v3NtkDuplicate.cpp	/^void duplicateInputGates(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateInputNets	ntk/v3NtkDuplicate.cpp	/^void duplicateInputNets(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap, V3NetVec& orderMap) {$/;"	f
duplicateNet	ntk/v3NtkDuplicate.cpp	/^const V3NetId duplicateNet(V3Ntk* const ntk, V3Ntk* const pNtk, const V3NetId& pId, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const duplicateNtk(V3NtkHandler* const handler, V3NetVec& p2cMap, V3NetVec& c2pMap) {$/;"	f
duplicateNtk	ntk/v3NtkDuplicate.cpp	/^void duplicateNtk(V3NtkHandler* const handler, V3Ntk* const ntk, V3NetVec& p2cMap, V3NetVec& c2pMap, V3NetVec& orderMap, V3PortableType& netHash, V3NtkHierInfo& hierInfo, const uint32_t& flattenLevel) {$/;"	f
duplicateReductionInit	ntk/v3NtkDuplicate.cpp	/^void duplicateReductionInit(V3Ntk* const ntk, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& orderMap) {$/;"	f
eagerMatch	eng/minisat/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f
elaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborate(V3LTLFormula* const ltlFormula) {$/;"	f	class:V3NtkElaborate
elaborateAigAndOrAndGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateAigAndOrAndGate(V3AigNtk* const ntk, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateAigFormula	ext/v3ExtElaborate.cpp	/^const V3NetId elaborateAigFormula(V3Formula* const formula, const uint32_t& rootIndex, V3PortableType& netHash) {$/;"	f
elaborateAigGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateAigGate(V3AigNtk* const ntk, const V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateBvFormula	ext/v3ExtElaborate.cpp	/^const V3NetId elaborateBvFormula(V3Formula* const formula, const uint32_t& rootIndex, V3PortableType& netHash) {$/;"	f
elaborateBvGate	ntk/v3NtkDuplicate.cpp	/^const V3NetId elaborateBvGate(V3BvNtk* const ntk, const V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
elaborateConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateConstraints(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMConstraints(V3FSM* const fsm, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMInvariants	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMInvariants(V3FSM* const fsm, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFSMState	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFSMState(const V3NetVec& stateNets, const bool& nextState) {$/;"	f	class:V3NtkElaborate
elaborateFairness	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFairness(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateFairnessL2S	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateFairnessL2S(V3Constraint* const constr, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateInvariants	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateInvariants(V3Constraint* const constr) {$/;"	f	class:V3NtkElaborate
elaborateL2S	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateL2S(const V3NetId& id) {$/;"	f	class:V3NtkElaborate
elaborateLTLFormula	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateLTLFormula(V3LTLFormula* const ltlFormula, const bool& l2s) {$/;"	f	class:V3NtkElaborate
elaborateLTLFormula	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateLTLFormula(V3LTLFormula* const ltlFormula, const uint32_t& rootIndex) {$/;"	f	class:V3NtkElaborate
elaborateLivenessNetwork	v3mc/v3MCElaborate.cpp	/^V3NtkHandler* const elaborateLivenessNetwork(V3NtkHandler* const handler, const V3UI32Vec& poList, V3NetTable& invConstr, V3NetTable& fairConstr) {$/;"	f
elaborateNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const elaborateNtk(V3NtkHandler* const handler, const V3NetVec& targetNets, V3NetVec& p2cMap, V3NetVec& c2pMap, V3PortableType& netHash) {$/;"	f
elaboratePOConstraints	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaboratePOConstraints(const uint32_t& start, const uint32_t& end, V3NetVec& constrList) {$/;"	f	class:V3NtkElaborate
elaborateProperties	v3mc/v3MCElaborate.cpp	/^V3NtkElaborate* const elaborateProperties(V3NtkHandler* const handler, V3StrVec& name, V3UI32Vec& prop, V3UI32Table& invc, V3UI32Table& fair, const bool& l2s, const bool& invc2Prop, const bool& safeOnly, const bool& liveOnly) {$/;"	f
elaborateProperty	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::elaborateProperty(V3Property* const p, V3NetVec& constrList, const bool& l2s) {$/;"	f	class:V3NtkElaborate
elaborateSafetyNetwork	v3mc/v3MCElaborate.cpp	/^V3NtkHandler* const elaborateSafetyNetwork(V3NtkHandler* const handler, const V3UI32Vec& poList, V3NetTable& invConstr) {$/;"	f
elems	eng/minisat/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Map
empty	bdd/myHash.h	/^   bool empty() const {$/;"	f	class:Hash
empty	bdd/test/myHash.h	/^   bool empty() const {$/;"	f	class:Hash
empty	eng/minisat/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Heap
enableConstructStandardFSM	stg/v3StgExtract.h	/^      inline void enableConstructStandardFSM()  { assert (!(_configs & 256ul)); _configs |= 256ul; }$/;"	f	class:V3FSMExtract
enableOmitNodesAllCombVars	stg/v3StgExtract.h	/^      inline void enableOmitNodesAllCombVars()  { assert (!(_configs & 16ul )); _configs |= 16ul;  }$/;"	f	class:V3FSMExtract
enableOmitNodesIndepToVars	stg/v3StgExtract.h	/^      inline void enableOmitNodesIndepToVars()  { assert (!(_configs & 32ul )); _configs |= 32ul;  }$/;"	f	class:V3FSMExtract
enableRenderNonEmptyStates	stg/v3StgExtract.h	/^      inline void enableRenderNonEmptyStates()  { assert (!(_configs & 64ul )); _configs |= 64ul;  }$/;"	f	class:V3FSMExtract
enableStopOnAllInitOrTerms	stg/v3StgExtract.h	/^      inline void enableStopOnAllInitOrTerms()  { assert (!(_configs & 128ul)); _configs |= 128ul; }$/;"	f	class:V3FSMExtract
encodeAllStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeAllStateFromSimulator() const {$/;"	f	class:V3FSM
encodeAllStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeAllStateFromSimulator(V3FSMSDG* const sdg) const {$/;"	f	class:V3FSM
encodeStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeStateFromSimulator() const {$/;"	f	class:V3FSM
encodeStateFromSimulator	stg/v3StgFSM.cpp	/^V3FSM::encodeStateFromSimulator(V3FSMSDG* const sdg) const {$/;"	f	class:V3FSM
encode_aig	io/v3AigWriter.cpp	/^void encode_aig(ofstream& output, int x) {$/;"	f
end	bdd/myHash.h	/^   iterator end() const {$/;"	f	class:Hash
end	bdd/test/myHash.h	/^   iterator end() const {$/;"	f	class:Hash
end	eng/minisat/IntMap.h	/^        V*       end    ()       { return &map[map.size()]; }$/;"	f	class:IntMap
end	eng/minisat/IntMap.h	/^        const V* end    () const { return &map[map.size()]; }$/;"	f	class:IntMap
end	eng/minisat/Options.h	/^    double end;$/;"	m	struct:DoubleRange
end	eng/minisat/Options.h	/^    int end;$/;"	m	struct:IntRange
end	eng/minisat/Options.h	/^    int64_t end;$/;"	m	struct:Int64Range
end	eng/minisat/Queue.h	/^    int     end;$/;"	m	class:Queue
end	util/v3Usage.h	/^      inline void end() { assert (_isStarted); _timeAccum += (clock() - _startTime) \/ CLOCKS_PER_SEC; _isStarted = 0; }$/;"	f	class:V3Stat
endLineON	vrf/v3VrfBase.h	/^      static inline const bool endLineON() { return intactON() &&  (4ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
end_inclusive	eng/minisat/Options.h	/^    bool  end_inclusive;$/;"	m	struct:DoubleRange
enqueue	eng/minisat/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Solver
equals	eng/minisat/Map.h	/^    E          equals;$/;"	m	class:Map
errorOption	cmd/v3CmdMgr.cpp	/^V3CmdExec::errorOption(V3CmdOptionError err, const string& opt) const {$/;"	f	class:V3CmdExec
evalCube	bdd/bddMgrV.cpp	/^BddMgrV::evalCube(const BddNodeV& node, const string& pattern) const$/;"	f	class:BddMgrV
exec	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::exec(const string& option) {$/;"	f	class:V3PlotTraceCmd
exec	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::exec(const string& option) {$/;"	f	class:V3SimNtkCmd
exec	bdd/bddCmd.cpp	/^BAndCmd::exec(const string& option)$/;"	f	class:BAndCmd
exec	bdd/bddCmd.cpp	/^BCofactorCmd::exec(const string& option)$/;"	f	class:BCofactorCmd
exec	bdd/bddCmd.cpp	/^BCompareCmd::exec(const string& option)$/;"	f	class:BCompareCmd
exec	bdd/bddCmd.cpp	/^BConstructCmd::exec(const string& option)$/;"	f	class:BConstructCmd
exec	bdd/bddCmd.cpp	/^BDrawCmd::exec(const string& option)$/;"	f	class:BDrawCmd
exec	bdd/bddCmd.cpp	/^BExistCmd::exec(const string& option)$/;"	f	class:BExistCmd
exec	bdd/bddCmd.cpp	/^BInvCmd::exec(const string& option)$/;"	f	class:BInvCmd
exec	bdd/bddCmd.cpp	/^BNandCmd::exec(const string& option)$/;"	f	class:BNandCmd
exec	bdd/bddCmd.cpp	/^BNorCmd::exec(const string& option)$/;"	f	class:BNorCmd
exec	bdd/bddCmd.cpp	/^BOrCmd::exec(const string& option)$/;"	f	class:BOrCmd
exec	bdd/bddCmd.cpp	/^BReportCmd::exec(const string& option)$/;"	f	class:BReportCmd
exec	bdd/bddCmd.cpp	/^BResetCmd::exec(const string& option)$/;"	f	class:BResetCmd
exec	bdd/bddCmd.cpp	/^BSetOrderCmd::exec(const string& option)$/;"	f	class:BSetOrderCmd
exec	bdd/bddCmd.cpp	/^BSetVarCmd::exec(const string& option)$/;"	f	class:BSetVarCmd
exec	bdd/bddCmd.cpp	/^BSimulateCmd::exec(const string& option)$/;"	f	class:BSimulateCmd
exec	bdd/bddCmd.cpp	/^BXnorCmd::exec(const string& option)$/;"	f	class:BXnorCmd
exec	bdd/bddCmd.cpp	/^BXorCmd::exec(const string& option)$/;"	f	class:BXorCmd
exec	cmd/v3CmdComm.cpp	/^V3DofileCmd::exec(const string& option) {     $/;"	f	class:V3DofileCmd
exec	cmd/v3CmdComm.cpp	/^V3HelpCmd::exec(const string& option) {$/;"	f	class:V3HelpCmd
exec	cmd/v3CmdComm.cpp	/^V3HistoryCmd::exec(const string& option) {$/;"	f	class:V3HistoryCmd
exec	cmd/v3CmdComm.cpp	/^V3LogFileCmd::exec(const string& option) {$/;"	f	class:V3LogFileCmd
exec	cmd/v3CmdComm.cpp	/^V3QuitCmd::exec(const string& option) {$/;"	f	class:V3QuitCmd
exec	cmd/v3CmdComm.cpp	/^V3UsageCmd::exec(const string& option) {     $/;"	f	class:V3UsageCmd
exec	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::exec(const string& option) {$/;"	f	class:V3OptTraceCmd
exec	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::exec(const string& option) {$/;"	f	class:V3TraceSimplifyCmd
exec	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::exec(const string& option) {$/;"	f	class:V3DuplicateNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::exec(const string& option) {$/;"	f	class:V3ListNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::exec(const string& option)$/;"	f	class:V3NetInfoCmd
exec	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::exec(const string& option) {$/;"	f	class:V3PlotNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::exec(const string& option) {$/;"	f	class:V3PrintNetCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::exec(const string& option) {$/;"	f	class:V3PrintNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::exec(const string& option) {$/;"	f	class:V3PrintVerbosityCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::exec(const string& option) {$/;"	f	class:V3ReadAIGCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::exec(const string& option) {$/;"	f	class:V3ReadBTORCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::exec(const string& option) {$/;"	f	class:V3ReadRTLCmd
exec	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::exec(const string& option) {$/;"	f	class:V3ReduceNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::exec(const string& option) {$/;"	f	class:V3RefNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::exec(const string& option) {$/;"	f	class:V3RewriteNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::exec(const string& option) {$/;"	f	class:V3SetNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::exec(const string& option) {$/;"	f	class:V3SetVerbosityCmd
exec	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::exec(const string& option) {$/;"	f	class:V3StrashNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::exec(const string& option) {$/;"	f	class:V3WorkNtkCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::exec(const string& option) {$/;"	f	class:V3WriteAIGCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::exec(const string& option) {$/;"	f	class:V3WriteBTORCmd
exec	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::exec(const string& option) {$/;"	f	class:V3WriteRTLCmd
exec	prove/proveCmd.cpp	/^PCheckPropertyCmd::exec(const string& option)$/;"	f	class:PCheckPropertyCmd
exec	prove/proveCmd.cpp	/^PImageCmd::exec(const string& option)$/;"	f	class:PImageCmd
exec	prove/proveCmd.cpp	/^PInitialStateCmd::exec(const string& option)$/;"	f	class:PInitialStateCmd
exec	prove/proveCmd.cpp	/^PTransRelationCmd::exec(const string& option)$/;"	f	class:PTransRelationCmd
exec	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::exec(const string& option) {$/;"	f	class:V3ElaborateFSMCmd
exec	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::exec(const string& option) {$/;"	f	class:V3ExtractFSMCmd
exec	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::exec(const string& option) {$/;"	f	class:V3PlotFSMCmd
exec	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::exec(const string& option) {$/;"	f	class:V3WriteFSMCmd
exec	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::exec(const string& option) {$/;"	f	class:V3BlastNtkCmd
exec	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::exec(const string& option) {$/;"	f	class:V3ExpandNtkCmd
exec	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::exec(const string& option) {$/;"	f	class:V3FlattenNtkCmd
exec	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::exec(const string& option) {$/;"	f	class:V3MiterNtkCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::exec(const string& option) {$/;"	f	class:V3MCReadPropertyCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::exec(const string& option) {$/;"	f	class:V3MCRunCmd
exec	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::exec(const string& option) {$/;"	f	class:V3MCWritePropertyCmd
exec	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::exec(const string& option) {$/;"	f	class:V3BMCVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::exec(const string& option) {$/;"	f	class:V3CheckResultCmd
exec	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::exec(const string& option) {$/;"	f	class:V3ElaboratePrptyCmd
exec	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::exec(const string& option) {$/;"	f	class:V3ITPVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::exec(const string& option) {$/;"	f	class:V3KLiveVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::exec(const string& option) {$/;"	f	class:V3PDRVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::exec(const string& option) {$/;"	f	class:V3PlotResultCmd
exec	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::exec(const string& option) {$/;"	f	class:V3PrintReportCmd
exec	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::exec(const string& option) {$/;"	f	class:V3PrintSolverCmd
exec	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::exec(const string& option) {$/;"	f	class:V3SECVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::exec(const string& option) {$/;"	f	class:V3SIMVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::exec(const string& option) {$/;"	f	class:V3SetLivenessCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::exec(const string& option) {$/;"	f	class:V3SetReportCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::exec(const string& option) {$/;"	f	class:V3SetSafetyCmd
exec	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::exec(const string& option) {$/;"	f	class:V3SetSolverCmd
exec	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::exec(const string& option) {$/;"	f	class:V3UMCVrfCmd
exec	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::exec(const string& option) {$/;"	f	class:V3WriteResultCmd
execOneCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::execOneCmd() {$/;"	f	class:V3CmdMgr
exist	bdd/bddNodeV.cpp	/^BddNodeV::exist(unsigned l) const$/;"	f	class:BddNodeV
exist0	adt/v3BitVec.cpp	/^V3BitVecX::exist0 () const {$/;"	f	class:V3BitVecX
exist1	adt/v3BitVec.cpp	/^V3BitVecX::exist1 () const {$/;"	f	class:V3BitVecX
existFSM	ntk/v3NtkHandler.h	/^      inline const bool existFSM(const string& s) const { return _fsm.end() != _fsm.find(s); }$/;"	f	class:V3NtkHandler
existInitial	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::existInitial(const V3NetVec& state) {$/;"	f	class:V3VrfIPDR
existInitial	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::existInitial(const V3NetVec& state) {$/;"	f	class:V3VrfMPDR
existList	adt/v3Misc.h	/^      inline const bool existList(const uint32_t& i) const {$/;"	f	class:V3PortableType
existNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::existNetName(const string& s) const {$/;"	f	class:V3NtkHandler
existProperty	ntk/v3NtkHandler.h	/^      inline const bool existProperty(const string& s) const { return _property.end() != _property.find(s); }$/;"	f	class:V3NtkHandler
existRecur	bdd/bddNodeV.cpp	/^BddNodeV::existRecur(unsigned l, map<size_t, size_t>& existMap) const$/;"	f	class:BddNodeV
existState	stg/v3StgFSM.cpp	/^V3FSMSDGDB::existState(const V3NetVec& stateVars) {$/;"	f	class:V3FSMSDGDB
existVerifyData	svr/v3SvrBase.cpp	/^V3SvrBase::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
existVerifyData	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
existVerifyData	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::existVerifyData(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
expandSimulateResult	vrf/v3VrfResult.cpp	/^const int expandSimulateResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler) {$/;"	f
extra_clause_field	eng/minisat/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:ClauseAllocator
extractModel	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::extractModel(const uint32_t& d, const V3IPDRCube* const nextCube) {$/;"	f	class:V3VrfIPDR
extractModel	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::extractModel(const V3MPDRCube* const nextCube, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
extractNewCube	vrf/v3VrfCITP.cpp	/^V3VrfCITP::extractNewCube(V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
extractNewCube	vrf/v3VrfFITP.cpp	/^V3VrfFITP::extractNewCube(V3FITPCube* const curCube) {$/;"	f	class:V3VrfFITP
filterOutNoMuxVariable	stg/v3StgExtract.h	/^      inline void filterOutNoMuxVariable()      { assert (!(_configs & 4ul  )); _configs |= 4ul;   }$/;"	f	class:V3FSMExtract
filterOutNonSeqVariable	stg/v3StgExtract.h	/^      inline void filterOutNonSeqVariable()     { assert (!(_configs & 8ul  )); _configs |= 8ul;   }$/;"	f	class:V3FSMExtract
find	eng/minisat/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f
findCorresOperator	ext/v3Formula.cpp	/^V3Formula::findCorresOperator(const string& exp, const char& prefix, const char& suffix) {$/;"	f	class:V3Formula
findNextOperator	ext/v3Formula.cpp	/^V3Formula::findNextOperator(const string& exp, uint32_t& pos) {$/;"	f	class:V3Formula
findSliceOperand	ext/v3Formula.cpp	/^V3Formula::findSliceOperand(const string& exp, uint32_t& msb, uint32_t& lsb) {$/;"	f	class:V3Formula
first	eng/minisat/Queue.h	/^    int     first;$/;"	m	class:Queue
first0	adt/v3BitVec.cpp	/^V3BitVecX::first0() const {$/;"	f	class:V3BitVecX
first1	adt/v3BitVec.cpp	/^V3BitVecX::first1() const {$/;"	f	class:V3BitVecX
firstX	adt/v3BitVec.cpp	/^V3BitVecX::firstX() const {$/;"	f	class:V3BitVecX
flattenNtk	ntk/v3NtkDuplicate.cpp	/^V3Ntk* const flattenNtk(V3NtkHandler* const handler, V3NetVec& c2pMap, V3NtkHierInfo& hierInfo, const uint32_t& flattenLevel) {$/;"	f
forceAddBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::forceAddBddNodeV(const string& str, size_t n)$/;"	f	class:BddMgrV
forceInsert	bdd/myHash.h	/^   void forceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
forceInsert	bdd/test/myHash.h	/^   void forceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
formalBlockCurrentState	stg/v3StgFSM.cpp	/^V3FSM::formalBlockCurrentState(const uint32_t& state, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalBlockNextState	stg/v3StgFSM.cpp	/^V3FSM::formalBlockNextState(const uint32_t& state, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalCheckFiredResult	vrf/v3VrfResult.cpp	/^const int formalCheckFiredResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
formalCheckProvenResult	vrf/v3VrfResult.cpp	/^const int formalCheckProvenResult(const V3Ntk* const inv, const V3NtkHandler* const handler) {$/;"	f
formalForBackwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::formalForBackwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
formalForForwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::formalForForwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
formalGetCurrentState	stg/v3StgFSM.cpp	/^V3FSM::formalGetCurrentState(const V3NetVec& stateData, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetInitialState	stg/v3StgFSM.cpp	/^V3FSM::formalGetInitialState(const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetNextState	stg/v3StgFSM.cpp	/^V3FSM::formalGetNextState(const V3NetVec& stateData, const V3SvrData& svrData) {$/;"	f	class:V3FSM
formalGetTerminalState	stg/v3StgFSM.cpp	/^V3FSM::formalGetTerminalState(const V3SvrData& svrData) {$/;"	f	class:V3FSM
forwardModel	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::forwardModel(const V3IPDRCube* const curCube) {$/;"	f	class:V3VrfIPDR
forwardModel	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::forwardModel(const V3MPDRCube* const curCube) {$/;"	f	class:V3VrfMPDR
forwardProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::forwardProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
forwardProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::forwardProof(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
free	eng/minisat/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:RegionAllocator
free	eng/minisat/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:ClauseAllocator
freeNetId	ntk/v3Ntk.h	/^inline void V3Ntk::freeNetId(const V3NetId& id) {$/;"	f	class:V3Ntk
free_vars	eng/minisat/Solver.h	/^    vec<Var>            free_vars;$/;"	m	class:Solver
garbage_frac	eng/minisat/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Solver
generalization	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalization(V3IPDRTimedCube& generalizedCube) {$/;"	f	class:V3VrfIPDR
generalization	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalization(V3MPDRTimedCube& generalizedCube) {$/;"	f	class:V3VrfMPDR
generalizationValid	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::generalizationValid() {$/;"	f	class:V3AlgAigGeneralize
generalizationValid	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::generalizationValid() {$/;"	f	class:V3AlgBvGeneralize
generalizeCex	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeCex(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
generalizeCex	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeCex(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
generalizeProof	vrf/v3VrfCITP.cpp	/^V3VrfCITP::generalizeProof(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
generalizeProof	vrf/v3VrfFITP.cpp	/^V3VrfFITP::generalizeProof(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
generalizeProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
generalizeProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeProof(V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
generalizeSimulation	vrf/v3VrfCITP.cpp	/^V3VrfCITP::generalizeSimulation(V3CITPCube* const cube, const V3CITPCube* const nextCube) {$/;"	f	class:V3VrfCITP
generalizeSimulation	vrf/v3VrfFITP.cpp	/^V3VrfFITP::generalizeSimulation(const V3NetVec& nextCube) {$/;"	f	class:V3VrfFITP
generalizeSimulation	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::generalizeSimulation(const uint32_t& d, V3IPDRCube* const cube, const V3IPDRCube* const nextCube) {$/;"	f	class:V3VrfIPDR
generalizeSimulation	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::generalizeSimulation(V3MPDRCube* const cube, const V3MPDRCube* const nextCube, const uint32_t& depth) {$/;"	f	class:V3VrfMPDR
generalizeStateFromSimulation	stg/v3StgFSM.cpp	/^V3FSM::generalizeStateFromSimulation(const V3NetVec& targetNets, const uint32_t& depth) {$/;"	f	class:V3FSM
generateAndAddUniquenessBound	vrf/v3VrfUMC.cpp	/^V3VrfUMC::generateAndAddUniquenessBound(const uint32_t& depth) {$/;"	f	class:V3VrfUMC
geq	svr/v3SvrSatHelper.h	/^inline void geq(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
geqInt	svr/v3SvrSatHelper.h	/^inline void geqInt(Solver* SS, const Var& y, const Var& g, const Var& e, const uint32_t& Width)$/;"	f
geq_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId geq_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
getAccumTime	util/v3Usage.h	/^      inline const double getAccumTime() const { assert (!_isStarted); return _timeAccum; }$/;"	f	class:V3Stat
getAccumToRef	util/v3Usage.h	/^      inline const double getAccumToRef() const { return _refStat ? getAccumTime() \/ _refStat->getAccumTime() : 0; }$/;"	f	class:V3Stat
getActivator	vrf/v3VrfMPDR.h	/^      inline const V3SvrData& getActivator() const { return _activator; }$/;"	f	class:V3MPDRFrame
getActiveMainSize	v3mc/v3MCMain.cpp	/^V3MCResource::getActiveMainSize() {$/;"	f	class:V3MCResource
getAllCubes	bdd/bddNodeV.cpp	/^BddNodeV::getAllCubes() const$/;"	f	class:BddNodeV
getAllCubesRecur	bdd/bddNodeV.cpp	/^BddNodeV::getAllCubesRecur$/;"	f	class:BddNodeV
getAuxFSMName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getAuxFSMName() const {$/;"	f	class:V3NtkHandler
getAuxPropertyName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getAuxPropertyName() const {$/;"	f	class:V3NtkHandler
getAvailableCores	v3mc/v3MCMain.cpp	/^V3MCResource::getAvailableCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
getAvgTime	util/v3Usage.h	/^      inline const double getAvgTime() const { return getAccumTime() \/ (double)(getNumCalled()); }$/;"	f	class:V3Stat
getBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getBase() const { return _base; }$/;"	f	class:V3SDGNode
getBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::getBddNodeV(const string& name) const$/;"	f	class:BddMgrV
getBddNodeV	bdd/bddMgrV.cpp	/^BddMgrV::getBddNodeV(unsigned id) const$/;"	f	class:BddMgrV
getBddNodeV	bdd/bddMgrV.cpp	/^BddNodeV getBddNodeV(const string& bddName)$/;"	f
getBddNodeVInt	bdd/bddNodeV.h	/^   BddNodeVInt* getBddNodeVInt() const {$/;"	f	class:BddNodeV
getBddNodeVInt	bdd/test/bddNodeV.h	/^   BddNodeVInt* getBddNodeVInt() const {$/;"	f	class:BddNodeV
getBitBlastedNet	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getBitBlastedNet(const V3NetId& id, const uint32_t& index) {$/;"	f	class:V3BvBlastBv
getBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::getBound(const uint32_t& p) {$/;"	f	class:V3VrfSharedBound
getBound	vrf/v3VrfShared.h	/^      inline void getBound(V3UI32Vec& bound) { lock(); bound = _bound; unlock(); }$/;"	f	class:V3VrfSharedBound
getBranchIndex	ext/v3Formula.h	/^      inline const uint32_t getBranchIndex(const uint32_t& i, const uint32_t& j) const {$/;"	f	class:V3Formula
getBranchIndex	ext/v3LTLFormula.h	/^      inline const uint32_t getBranchIndex(const uint32_t& i, const uint32_t& j) const {$/;"	f	class:V3LTLFormula
getBranchSize	ext/v3Formula.h	/^      inline const uint32_t getBranchSize(const uint32_t& i) const {$/;"	f	class:V3Formula
getBranchSize	ext/v3LTLFormula.h	/^      inline const uint32_t getBranchSize(const uint32_t& i) const {$/;"	f	class:V3LTLFormula
getBtorInput	io/v3BtorParser.cpp	/^inline const V3NetId getBtorInput(const V3HashMap<uint32_t, V3NetId>::Hash& id2IdHash, const int& id) {$/;"	f
getCOISize	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getCOISize() {$/;"	f	class:V3VrfSEC
getCexTrace	ext/v3Property.h	/^      inline V3CexTrace* const getCexTrace() const { assert (isCex()); return (V3CexTrace*)(_cexOrInv); }$/;"	f	class:V3VrfResult
getCexTrace	ext/v3Property.h	/^      inline const V3CexTrace* const getCexTrace() const { assert (isFired()); return _result.getCexTrace(); }$/;"	f	class:V3Property
getChecker	v3mc/v3MCEngine.cpp	/^V3VrfBase* getChecker(const V3MCEngineType& type, V3NtkHandler* const handler, const uint32_t& ntkSize) {$/;"	f
getClock	ntk/v3Ntk.h	/^      inline const V3NetId& getClock() const { return _globalClk; }$/;"	f	class:V3Ntk
getCluster	stg/v3StgExtract.h	/^      inline const V3UI32Set& getCluster(const uint32_t& i) const { assert (i < _clusters.size()); return _clusters[i]; }$/;"	f	class:V3FSMExtract
getClusterSize	stg/v3StgExtract.h	/^      inline const uint32_t getClusterSize() const { return _clusters.size(); }$/;"	f	class:V3FSMExtract
getCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::getCmd(const string& cmd) const {$/;"	f	class:V3CmdMgr
getCmdLen	cmd/v3CmdMgr.h	/^      inline unsigned getCmdLen() const { return _cmdLen; }$/;"	f	class:V3CmdExec
getCmdListFromPart	cmd/v3CmdMgr.cpp	/^V3CmdMgr::getCmdListFromPart(const string& cmd) const {$/;"	f	class:V3CmdMgr
getConst	ntk/v3Ntk.h	/^      inline const V3NetId& getConst(const uint32_t& i) const { assert (i < getConstSize()); return _ConstList[i]; }$/;"	f	class:V3Ntk
getConstSize	ntk/v3Ntk.h	/^      inline const uint32_t getConstSize() const { return _ConstList.size(); }$/;"	f	class:V3Ntk
getConstValue	ntk/v3Ntk.cpp	/^V3BvNtk::getConstValue(const V3BVXId& valueId) const {$/;"	f	class:V3BvNtk
getConstWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getConstWidth(const V3BVXId& valueId) const {$/;"	f	class:V3BvNtk
getCube	bdd/bddNodeV.cpp	/^BddNodeV::getCube(size_t ith) const$/;"	f	class:BddNodeV
getCubeList	vrf/v3VrfCITP.h	/^      inline V3CITPCubeList& getCubeList() { return _cubeList; }$/;"	f	class:V3CITPFrame
getCubeList	vrf/v3VrfFITP.h	/^      inline V3FITPCubeList& getCubeList() { return _cubeList; }$/;"	f	class:V3FITPFrame
getCubeList	vrf/v3VrfIPDR.h	/^      inline const V3IPDRCubeList& getCubeList() const { return _cubeList; }$/;"	f	class:V3IPDRFrame
getCubeList	vrf/v3VrfMPDR.h	/^      inline const V3MPDRCubeList& getCubeList() const { return _cubeList; }$/;"	f	class:V3MPDRFrame
getCubeRecur	bdd/bddNodeV.cpp	/^BddNodeV::getCubeRecur$/;"	f	class:BddNodeV
getCubeSize	alg/v3AlgGeneralize.h	/^      inline const uint32_t getCubeSize() const { return _cube2Var.size(); }$/;"	f	class:V3GenStruct
getCurHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getCurHandler() const { $/;"	f	class:V3Handler
getCurHandlerId	ntk/v3NtkHandler.h	/^      inline const uint32_t getCurHandlerId() const { return _curHandlerId; }$/;"	f	class:V3Handler
getCurrentNetId	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkElaborate
getCurrentNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getCurrentNetId	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkSimplify
getCurrentNetId	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getCurrentNetId	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getCurrentNetId	trans/v3NtkExpand.cpp	/^V3NtkExpand::getCurrentNetId(const V3NetId& id, const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getCurrentNetId	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getCurrentNetId(const V3NetId& id, const uint32_t& handlerIndex) const {$/;"	f	class:V3NtkFlatten
getCutSignal	ntk/v3Ntk.h	/^      inline const V3NetId& getCutSignal(const uint32_t& i) const { return _cutSignals[i]; }$/;"	f	class:V3Ntk
getCutSize	ntk/v3Ntk.h	/^      inline const uint32_t getCutSize() const { return _cutSignals.size(); }$/;"	f	class:V3Ntk
getCycle	trans/v3NtkExpand.h	/^      inline const uint32_t& getCycle() const { return _cycle; }$/;"	f	class:V3NtkExpand
getCycleCount	alg/v3AlgSimulate.h	/^      inline const uint32_t getCycleCount() const { return _cycle; }$/;"	f	class:V3AlgSimulate
getData	ext/v3Property.h	/^      inline const V3BitVecX& getData(const uint32_t& i) const { assert (i < _data.size()); return _data[i]; }$/;"	f	class:V3CexTrace
getDataConflict	svr/v3SvrBase.cpp	/^V3SvrBase::getDataConflict(V3SvrDataVec& var_exp) const {$/;"	f	class:V3SvrBase
getDataConflict	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataConflict(V3SvrDataVec& Exps) const {$/;"	f	class:V3SvrBoolector
getDataConflict	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataConflict(V3SvrDataVec& vars) const {$/;"	f	class:V3SvrMiniSat
getDataValue	svr/v3SvrBase.cpp	/^V3SvrBase::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBase
getDataValue	svr/v3SvrBase.cpp	/^V3SvrBase::getDataValue(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
getDataValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBoolector
getDataValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getDataValue(const size_t& exp) const {$/;"	f	class:V3SvrBoolector
getDataValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataValue(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrMiniSat
getDataValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getDataValue(const size_t& var) const {$/;"	f	class:V3SvrMiniSat
getDefaultCheckerList	v3mc/v3MCEngine.cpp	/^void getDefaultCheckerList(const V3MCMainType& type, const uint32_t& pSize, V3MCEngineList& checkers) {$/;"	f
getDefaultSolver	vrf/v3VrfBase.h	/^      static inline const V3SolverType getDefaultSolver() { return _extSolverType; }$/;"	f	class:V3VrfBase
getDepFFCone	stg/v3StgSDG.h	/^      inline V3SDGBase* const getDepFFCone() { return _depFFCone; }$/;"	f	class:V3SDGBase
getDepFFSet	stg/v3StgSDG.h	/^      inline const V3UI32Set& getDepFFSet() const { return _depFFSet; }$/;"	f	class:V3SDGBase
getDepMuxCone	stg/v3StgSDG.h	/^      inline V3SDGBase* const getDepMuxCone() { return _depMuxCone; }$/;"	f	class:V3SDGBase
getDepMuxSet	stg/v3StgSDG.h	/^      inline const V3UI32Set& getDepMuxSet() const { return _depMuxSet; }$/;"	f	class:V3SDGBase
getDepVars	stg/v3StgFSM.h	/^      inline const V3UI32Set& getDepVars() const { return _depVars; }$/;"	f	class:V3FSMSDGDB
getEnd	ext/v3Property.h	/^      inline const uint32_t getEnd()   const { assert (isPOConstr()); return V3PairType(_constrInfo).bus[1]; }$/;"	f	class:V3Constraint
getFBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getFBase() const { return _fBase; }$/;"	f	class:V3SDGMUX
getFSM	ext/v3Property.h	/^      inline V3FSM* const getFSM() const { assert (isFSMConstr()); return (V3FSM* const)(_constrInfo); }$/;"	f	class:V3Constraint
getFSM	ntk/v3NtkHandler.h	/^      inline V3FSMExtract* const getFSM(const string& s) const { assert (existFSM(s)); return _fsm.find(s)->second; }$/;"	f	class:V3NtkHandler
getFSM	stg/v3StgExtract.h	/^      inline V3FSM* const getFSM(const uint32_t& i) const { assert (i < _fsmList.size()); return _fsmList[i]; }$/;"	f	class:V3FSMExtract
getFSMListSize	stg/v3StgExtract.h	/^      inline const uint32_t getFSMListSize() const { return _fsmList.size(); }$/;"	f	class:V3FSMExtract
getFSMSDGDBSize	stg/v3StgExtract.h	/^      inline const uint32_t getFSMSDGDBSize() const { return _sdgDBList.size(); }$/;"	f	class:V3FSMExtract
getFSMSDGList	stg/v3StgFSM.h	/^      inline const V3FSMSDGList& getFSMSDGList() const { return _sdgDB->getFSMSDGList(); }$/;"	f	class:V3FSM
getFSMSDGList	stg/v3StgFSM.h	/^      inline const V3FSMSDGList& getFSMSDGList() const { return _sdgList; }$/;"	f	class:V3FSMSDGDB
getFairConstr	ext/v3Property.cpp	/^V3Property::getFairConstr(const uint32_t& i) const {$/;"	f	class:V3Property
getFairConstrSize	ext/v3Property.h	/^      inline const uint32_t getFairConstrSize() const { return _fairConstrs.size(); }$/;"	f	class:V3Property
getFalseSDG	stg/v3StgFSM.h	/^      inline const V3FSMSDGSet& getFalseSDG() const { return _falseSDG; }$/;"	f	class:V3FSMSDG
getFalseStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getFalseStateSize() const { return _falseSize; }$/;"	f	class:V3FSMSDG
getFormula	ext/v3LTLFormula.h	/^      inline V3Formula* const getFormula(const uint32_t& i) const {$/;"	f	class:V3LTLFormula
getFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrBase
getFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBase
getFormula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
getFormula	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrBoolector
getFormula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getFormula(const V3NetId& id, const uint32_t& bit, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
getFormula	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getFormula(const V3NetId& id, const uint32_t& depth) {$/;"	f	class:V3SvrMiniSat
getFrameId	dfx/v3DfxTrace.h	/^      inline const uint32_t getFrameId() const { return _frameId; }$/;"	f	class:V3DfxCube
getFromSize	adt/v3Graph.h	/^V3Graph<T>::getFromSize(const uint32_t& t) const {$/;"	f	class:V3Graph
getGateType	ext/v3Formula.h	/^      inline const V3GateType& getGateType(const uint32_t& i) const { assert (!isLeaf(i)); return _formula[i].first; }$/;"	f	class:V3Formula
getGateType	ntk/v3Ntk.h	/^inline const V3GateType V3Ntk::getGateType(const V3NetId& id) const {$/;"	f	class:V3Ntk
getGeneralizationResult	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::getGeneralizationResult() const {$/;"	f	class:V3AlgGeneralize
getHandler	ext/v3Formula.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3Formula
getHandler	ext/v3LTLFormula.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3LTLFormula
getHandler	ext/v3Property.h	/^      inline V3NtkHandler* const getHandler() const { return (V3NtkHandler*)(~3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
getHandler	ntk/v3NtkHandler.cpp	/^V3Handler::getHandler(const uint32_t& ntkId) const {$/;"	f	class:V3Handler
getHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getHandler() const { return _handler; }$/;"	f	class:V3NtkHandler
getHandler	ntk/v3NtkHandler.h	/^      inline V3NtkHandler* const getHandler(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getHandlerCount	ntk/v3NtkHandler.h	/^      inline const uint32_t getHandlerCount() const { return _ntkHandlerList.size(); }$/;"	f	class:V3Handler
getHelpPrefixString	eng/minisat/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Option
getInNode	adt/v3Graph.h	/^V3Graph<T>::getInNode(const uint32_t& i, const uint32_t& s) const {$/;"	f	class:V3Graph
getInNodeSize	adt/v3Graph.h	/^V3Graph<T>::getInNodeSize(const uint32_t& i) const {$/;"	f	class:V3Graph
getIncLastDepthToKeepGoing	vrf/v3VrfBase.h	/^      inline const uint32_t getIncLastDepthToKeepGoing() const { return _incLastDepthToKeepGoing; }$/;"	f	class:V3VrfBase
getIndInv	ext/v3Property.h	/^      inline V3Ntk* const getIndInv() const { assert (isInv()); return (V3Ntk*)(_cexOrInv & ~1ul); }$/;"	f	class:V3VrfResult
getIndInv	ext/v3Property.h	/^      inline const V3Ntk* const getIndInv() const { assert (isProven()); return _result.getIndInv(); }$/;"	f	class:V3Property
getInit	ext/v3Property.h	/^      inline V3BitVecX* const getInit() const { return _init; }$/;"	f	class:V3CexTrace
getInitFwdReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getInitFwdReachableSize() {$/;"	f	class:V3FSM
getInitStateSize	stg/v3StgFSM.cpp	/^V3FSM::getInitStateSize() const {$/;"	f	class:V3FSM
getInitStates	stg/v3StgFSM.cpp	/^V3FSM::getInitStates(V3UI32Vec& states, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getInitialObligation	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::getInitialObligation() {  \/\/ If SAT(R ^ T ^ !p)$/;"	f	class:V3VrfIPDR
getInitialObligation	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::getInitialObligation() {  \/\/ If SAT(R ^ T ^ !p)$/;"	f	class:V3VrfMPDR
getInout	ntk/v3Ntk.h	/^      inline const V3NetId& getInout(const uint32_t& i) const { assert (i < getInoutSize()); return _IOList[2][i]; }$/;"	f	class:V3Ntk
getInoutName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getInoutName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getInoutName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getInoutName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getInoutName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getInoutName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getInoutName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getInoutName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getInoutSize	ntk/v3Ntk.h	/^      inline const uint32_t getInoutSize() const { return _IOList[2].size(); }$/;"	f	class:V3Ntk
getInput	ntk/v3Ntk.h	/^      inline const V3NetId& getInput(const uint32_t& i) const { assert (i < getInputSize()); return _IOList[0][i]; }$/;"	f	class:V3Ntk
getInputConstValue	ntk/v3Ntk.cpp	/^V3BvNtk::getInputConstValue(const V3NetId& id) const {$/;"	f	class:V3BvNtk
getInputData	vrf/v3VrfIPDR.h	/^      inline const V3BitVecX& getInputData() const { return _inputData; }$/;"	f	class:V3IPDRCube
getInputData	vrf/v3VrfMPDR.h	/^      inline const V3BitVecX& getInputData() const { return _inputData; }$/;"	f	class:V3MPDRCube
getInputList	ntk/v3Ntk.h	/^      inline const V3NetVec& getInputList() const { return _inputs; }$/;"	f	class:V3NtkModule
getInputName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getInputName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getInputName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getInputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getInputName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getInputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getInputName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getInputName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getInputNetId	ntk/v3Ntk.h	/^inline const V3NetId& V3Ntk::getInputNetId(const V3NetId& id, const uint32_t& i) const {$/;"	f	class:V3Ntk
getInputNetSize	ntk/v3Ntk.h	/^inline const uint32_t V3Ntk::getInputNetSize(const V3NetId& id) const {$/;"	f	class:V3Ntk
getInputSize	ntk/v3Ntk.h	/^      inline const uint32_t getInputSize() const { return _IOList[0].size(); }$/;"	f	class:V3Ntk
getInputSliceBit	ntk/v3Ntk.cpp	/^V3BvNtk::getInputSliceBit(const V3NetId& id, const bool& msb) const {$/;"	f	class:V3BvNtk
getInv	vrf/v3VrfShared.h	/^      inline void getInv(V3NetTable& inv) { lock(); inv = _inv; unlock(); }$/;"	f	class:V3VrfSharedInv
getInvConstr	ext/v3Property.cpp	/^V3Property::getInvConstr(const uint32_t& i) const {$/;"	f	class:V3Property
getInvConstrSize	ext/v3Property.h	/^      inline const uint32_t getInvConstrSize() const { return _invConstrs.size(); }$/;"	f	class:V3Property
getInvariant	ext/v3Property.cpp	/^V3Property::getInvariant(const uint32_t& i) const {$/;"	f	class:V3Property
getInvariantSize	ext/v3Property.h	/^      inline const uint32_t getInvariantSize() const { return _invariants.size(); }$/;"	f	class:V3Property
getKLHandler	vrf/v3VrfKLive.h	/^      inline V3NtkHandler* const getKLHandler() const { return _klHandler; }$/;"	f	class:V3VrfKLive
getLTLFormulSize	ext/v3NtkElaborate.h	/^      inline const uint32_t getLTLFormulSize() const { return _pOutput.size(); }$/;"	f	class:V3NtkElaborate
getLTLFormula	ext/v3Property.h	/^      inline V3LTLFormula* const getLTLFormula() const { return _formula; }$/;"	f	class:V3Property
getLabel	bdd/bddNodeV.cpp	/^BddNodeV::getLabel() const$/;"	f	class:BddNodeV
getLatch	ntk/v3Ntk.h	/^      inline const V3NetId& getLatch(const uint32_t& i) const { assert (i < getLatchSize()); return _FFList[i]; }$/;"	f	class:V3Ntk
getLatchSize	ntk/v3Ntk.h	/^      inline const uint32_t getLatchSize() const { return _FFList.size(); }$/;"	f	class:V3Ntk
getLeaves	adt/v3Graph.h	/^V3Graph<T>::getLeaves(V3NodeLayer& leafList) const {$/;"	f	class:V3Graph
getLeft	bdd/bddNodeV.cpp	/^BddNodeV::getLeft() const$/;"	f	class:BddNodeV
getLeft	bdd/bddNodeV.h	/^   const BddNodeV& getLeft() const { return _left; }$/;"	f	class:BddNodeVInt
getLeft	bdd/test/bddNodeV.h	/^   const BddNodeV& getLeft() const { return _left; }$/;"	f	class:BddNodeVInt
getLeftCofactor	bdd/bddNodeV.cpp	/^BddNodeV::getLeftCofactor(unsigned i) const$/;"	f	class:BddNodeV
getLevel	bdd/bddNodeV.cpp	/^BddNodeV::getLevel() const$/;"	f	class:BddNodeV
getLevel	bdd/bddNodeV.h	/^   unsigned getLevel() const { return _level; }$/;"	f	class:BddNodeVInt
getLevel	bdd/test/bddNodeV.h	/^   unsigned getLevel() const { return _level; }$/;"	f	class:BddNodeVInt
getList	adt/v3Misc.h	/^      inline const size_t& getList(const uint32_t& i) const {$/;"	f	class:V3PortableType
getMandCmd	cmd/v3CmdMgr.h	/^      inline const string& getMandCmd(size_t idx) const { return _mandCmd[idx]; }$/;"	f	class:V3CmdExec
getMap	ntk/v3NtkHandler.h	/^      inline V3NetVec& getMap(const uint32_t& i) {$/;"	f	class:V3NtkHierInfo
getMap	ntk/v3NtkHandler.h	/^      inline const V3NetVec& getMap(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getMaxAllowedStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getMaxAllowedStateSize() const { return _maxSize; }$/;"	f	class:V3FSMSDGDB
getMaxMemory	vrf/v3VrfShared.h	/^      inline const double getMaxMemory() { lock(); const double m = _maxMemory; unlock(); return m; }$/;"	f	class:V3VrfSharedMem
getMemUsage	util/v3Usage.h	/^      const double getMemUsage() { setMemUsage(); return _currentMem; }$/;"	f	class:V3Usage
getMemory	svr/v3SvrBase.cpp	/^V3SvrBase::getMemory() const {$/;"	f	class:V3SvrBase
getMemory	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getMemory() const {$/;"	f	class:V3SvrMiniSat
getMemory	vrf/v3VrfShared.h	/^      inline const double getMemory() { lock(); const double m = v3Usage.getMemUsage(); unlock(); return m; }$/;"	f	class:V3VrfSharedMem
getMileStoneSize	stg/v3StgFSM.cpp	/^V3FSM::getMileStoneSize() const {$/;"	f	class:V3FSM
getModule	ntk/v3Ntk.h	/^inline V3NtkModule* const V3Ntk::getModule(const V3NetId& id) const {$/;"	f	class:V3Ntk
getModule	ntk/v3Ntk.h	/^inline V3NtkModule* const V3Ntk::getModule(const uint32_t& i) const {$/;"	f	class:V3Ntk
getModuleSize	ntk/v3Ntk.h	/^      inline const uint32_t getModuleSize() const { return _ntkModule.size(); }$/;"	f	class:V3Ntk
getName	ext/v3LTLFormula.h	/^      inline const string& getName() const { return _name; }$/;"	f	class:V3LTLFormula
getNegExp	svr/v3SvrBoolector.h	/^      inline const size_t getNegExp(const BtorExp* const e) const { return ((getPosExp(e)) | 2ul); }$/;"	f	class:V3SvrBoolector
getNegFormula	svr/v3SvrBase.cpp	/^V3SvrBase::getNegFormula(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
getNegFormula	svr/v3SvrBoolector.h	/^      inline const size_t getNegFormula(const size_t& e) const { return (e ^ 2ul); }$/;"	f	class:V3SvrBoolector
getNegFormula	svr/v3SvrMiniSat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:V3SvrMiniSat
getNegVar	svr/v3SvrMiniSat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:V3SvrMiniSat
getNetExpression	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetExpression(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetFromName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetFromName(const string& s) const {$/;"	f	class:V3NtkHandler
getNetFromName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getNetFromName(const string& s) const {$/;"	f	class:V3BvBlastAig
getNetFromName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getNetFromName(const string& s) const {$/;"	f	class:V3BvBlastBv
getNetFromName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getNetFromName(const string& s) const {$/;"	f	class:V3NtkExpand
getNetFromName	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getNetFromName(const string& s) const {$/;"	f	class:V3NtkFlatten
getNetId	ext/v3Formula.h	/^      inline const V3NetId& getNetId(const uint32_t& i) const {$/;"	f	class:V3Formula
getNetId	ntk/v3NtkInput.cpp	/^V3NtkInput::getNetId(const string& netName) const {$/;"	f	class:V3NtkInput
getNetId	stg/v3StgSDG.h	/^      inline const V3NetId& getNetId() const { return _netId; }$/;"	f	class:V3SDGNode
getNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkHandler
getNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetName(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3BvBlastAig
getNetName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3BvBlastBv
getNetName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkExpand
getNetName	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkFlatten
getNetName	trans/v3NtkMiter.cpp	/^V3NtkMiter::getNetName(V3NetId& id, string& name) const {$/;"	f	class:V3NtkMiter
getNetNameOrFormedWithId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetNameOrFormedWithId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetRecurExpression	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNetRecurExpression(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getNetSize	ntk/v3Ntk.h	/^      inline const uint32_t getNetSize() const { return _inputData.size(); }$/;"	f	class:V3Ntk
getNetSize	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNetSize() {$/;"	f	class:V3VrfSharedNtk
getNetWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getNetWidth(const V3NetId& id) const {$/;"	f	class:V3BvNtk
getNetWidth	ntk/v3Ntk.cpp	/^V3Ntk::getNetWidth(const V3NetId& id) const {$/;"	f	class:V3Ntk
getNextCube	vrf/v3VrfCITP.h	/^      inline const V3CITPCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3CITPCube
getNextCube	vrf/v3VrfFITP.h	/^      inline const V3FITPCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3FITPCube
getNextCube	vrf/v3VrfIPDR.h	/^      inline const V3IPDRCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3IPDRCube
getNextCube	vrf/v3VrfMPDR.h	/^      inline const V3MPDRCube* const getNextCube() const { return _nextCube; }$/;"	f	class:V3MPDRCube
getNextLineInCexTrace	ext/v3ExtIO.cpp	/^inline const bool getNextLineInCexTrace(ifstream& input, string& inputStr) {$/;"	f
getNextVar	alg/v3AlgGeneralize.cpp	/^V3GenStruct::getNextVar() {$/;"	f	class:V3GenStruct
getNextVar	alg/v3AlgGeneralize.cpp	/^V3GenStruct::getNextVar(uint32_t& cost) {$/;"	f	class:V3GenStruct
getNode	adt/v3Graph.h	/^V3Graph<T>::getNode(const uint32_t& i) const {$/;"	f	class:V3Graph
getNodeIndex	adt/v3Graph.h	/^V3Graph<T>::getNodeIndex(const T& t) const {$/;"	f	class:V3Graph
getNodeSize	adt/v3Graph.h	/^V3Graph<T>::getNodeSize() const { return _nodeList.size(); }$/;"	f	class:V3Graph
getNtk	ntk/v3NtkHandler.h	/^      inline V3Ntk* const getNtk() const { return _ntk; }$/;"	f	class:V3NtkHandler
getNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNtk(V3NtkHandler* const handler) {$/;"	f	class:V3VrfSharedNtk
getNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::getNtk(V3NtkHandler* const handler, V3NetTable& constr) {$/;"	f	class:V3VrfSharedNtk
getNtkHandler	stg/v3StgExtract.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3FSMExtract
getNtkHandler	stg/v3StgFSM.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3FSMSDGDB
getNtkHandler	stg/v3StgFSM.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _sdgDB->getNtkHandler(); }$/;"	f	class:V3FSM
getNtkHandler	stg/v3StgSDG.h	/^      inline V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3SDG
getNtkHandler	vrf/v3VrfBase.h	/^      inline const V3NtkHandler* const getNtkHandler() const { return _handler; }$/;"	f	class:V3VrfBase
getNtkName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getNtkName() const {$/;"	f	class:V3NtkHandler
getNtkName	ntk/v3NtkInput.h	/^      inline const string getNtkName() const { return _ntkName; }$/;"	f	class:V3NtkInput
getNtkRef	ntk/v3Ntk.h	/^      inline V3NtkHandler* const getNtkRef() const { return (V3NtkHandler*)(_ref & ~1ul); }$/;"	f	class:V3NtkModule
getNtkSize	ntk/v3NtkHandler.h	/^      inline const uint32_t getNtkSize() const { return _hierInfo.size(); }$/;"	f	class:V3NtkHierInfo
getNumCalled	util/v3Usage.h	/^      inline const uint32_t getNumCalled() const { assert (!_isStarted); return _numCalled; }$/;"	f	class:V3Stat
getNumSupports	bdd/bddMgrV.h	/^   size_t getNumSupports() const { return _supports.size(); }$/;"	f	class:BddMgrV
getNumSupports	bdd/test/bddMgrV.h	/^   size_t getNumSupports() const { return _supports.size(); }$/;"	f	class:BddMgrV
getOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::getOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
getOpType	ext/v3LTLFormula.h	/^      inline const V3LTLOpType& getOpType(const uint32_t& i) const { assert (!isLeaf(i)); return _formula[i].first; }$/;"	f	class:V3LTLFormula
getOptCmd	cmd/v3CmdMgr.h	/^      inline const string& getOptCmd(size_t idx) const { return _optCmd[idx]; }$/;"	f	class:V3CmdExec
getOptionList	eng/minisat/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Option
getOriExp	svr/v3SvrBoolector.h	/^      inline BtorExp* const getOriExp(const size_t& e) const { return (BtorExp*)(e & ~2ul); }$/;"	f	class:V3SvrBoolector
getOriVar	svr/v3SvrMiniSat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:V3SvrMiniSat
getOutNode	adt/v3Graph.h	/^V3Graph<T>::getOutNode(const uint32_t& i, const uint32_t& s) const {$/;"	f	class:V3Graph
getOutNodeSize	adt/v3Graph.h	/^V3Graph<T>::getOutNodeSize(const uint32_t& i) const {$/;"	f	class:V3Graph
getOutPinWidthFromQuteRTL	io/v3NtkQuteRTL.cpp	/^const uint32_t getOutPinWidthFromQuteRTL(const string& name, CktOutPin* const OutPin) {$/;"	f
getOutput	ntk/v3Ntk.h	/^      inline const V3NetId& getOutput(const uint32_t& i) const { assert (i < getOutputSize()); return _IOList[1][i]; }$/;"	f	class:V3Ntk
getOutputList	ntk/v3Ntk.h	/^      inline const V3NetVec& getOutputList() const { return _outputs; }$/;"	f	class:V3NtkModule
getOutputName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getOutputName(const uint32_t& index) const {$/;"	f	class:V3NtkHandler
getOutputName	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getOutputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastAig
getOutputName	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getOutputName(const uint32_t& index) const {$/;"	f	class:V3BvBlastBv
getOutputName	trans/v3NtkExpand.cpp	/^V3NtkExpand::getOutputName(const uint32_t& index) const {$/;"	f	class:V3NtkExpand
getOutputSize	ntk/v3Ntk.h	/^      inline const uint32_t getOutputSize() const { return _IOList[1].size(); }$/;"	f	class:V3Ntk
getPDRDepth	vrf/v3VrfIPDR.h	/^      inline const uint32_t getPDRDepth() const { return _pdrFrame.size() - 1; }$/;"	f	class:V3VrfIPDR
getPDRDepth	vrf/v3VrfMPDR.h	/^      inline const uint32_t getPDRDepth() const { return _pdrFrame.size() - 2; }$/;"	f	class:V3VrfMPDR
getPDRFrame	vrf/v3VrfIPDR.h	/^      inline const uint32_t getPDRFrame() const { return _pdrFrame.size(); }$/;"	f	class:V3VrfIPDR
getPDRFrame	vrf/v3VrfMPDR.h	/^      inline const uint32_t getPDRFrame() const { return _pdrFrame.size() - 1; }$/;"	f	class:V3VrfMPDR
getPInitState	bdd/bddMgrV.h	/^   BddNodeV getPInitState() const { return _initState; }$/;"	f	class:BddMgrV
getPInitState	bdd/test/bddMgrV.h	/^   BddNodeV getPInitState() const { return _initState; }$/;"	f	class:BddMgrV
getPReachState	bdd/bddMgrV.h	/^   BddNodeV getPReachState() const { $/;"	f	class:BddMgrV
getPReachState	bdd/test/bddMgrV.h	/^   BddNodeV getPReachState() const { $/;"	f	class:BddMgrV
getPTr	bdd/bddMgrV.h	/^   BddNodeV getPTr() const { return _tr; }$/;"	f	class:BddMgrV
getPTr	bdd/test/bddMgrV.h	/^   BddNodeV getPTr() const { return _tr; }$/;"	f	class:BddMgrV
getPTri	bdd/bddMgrV.h	/^   BddNodeV getPTri() const { return _tri; }$/;"	f	class:BddMgrV
getPTri	bdd/test/bddMgrV.h	/^   BddNodeV getPTri() const { return _tri; }$/;"	f	class:BddMgrV
getParentId	ntk/v3NtkHandler.h	/^      inline const uint32_t getParentId(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getParentIndex	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3BvBlastAig
getParentIndex	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3BvBlastBv
getParentIndex	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getParentIndex(const V3NetId& id) const {$/;"	f	class:V3NtkFlatten
getParentNetId	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkElaborate
getParentNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getParentNetId	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkSimplify
getParentNetId	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3BvBlastAig
getParentNetId	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3BvBlastBv
getParentNetId	trans/v3NtkExpand.cpp	/^V3NtkExpand::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkExpand
getParentNetId	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::getParentNetId(const V3NetId& id) const {$/;"	f	class:V3NtkFlatten
getPosExp	svr/v3SvrBoolector.h	/^      inline const size_t getPosExp(const BtorExp* const e) const { return ((size_t)e); }$/;"	f	class:V3SvrBoolector
getPosVar	svr/v3SvrMiniSat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:V3SvrMiniSat
getPrimitive	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getPrimitive() const {$/;"	f	class:V3NtkHandler
getPrimitiveNetId	ntk/v3NtkHandler.cpp	/^V3NtkHandler::getPrimitiveNetId(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
getPrompt	cmd/v3CmdMgr.h	/^      inline const string& getPrompt() const { return _prompt; }$/;"	f	class:V3CmdMgr
getProperty	ntk/v3NtkHandler.h	/^      V3Property* const getProperty(const string& s) const {$/;"	f	class:V3NtkHandler
getPropertyList	ntk/v3NtkHandler.h	/^      inline const V3PropertyMap& getPropertyList() const { return _property; }$/;"	f	class:V3NtkHandler
getReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getReachableSize() const {$/;"	f	class:V3FSM
getRefCount	bdd/bddNodeV.cpp	/^BddNodeV::getRefCount() const$/;"	f	class:BddNodeV
getRefCount	bdd/bddNodeV.h	/^   unsigned getRefCount() const { return _refCount; }$/;"	f	class:BddNodeVInt
getRefCount	bdd/test/bddNodeV.h	/^   unsigned getRefCount() const { return _refCount; }$/;"	f	class:BddNodeVInt
getRefId	ntk/v3NtkHandler.h	/^      inline const V3PairType& getRefId(const uint32_t& i) const {$/;"	f	class:V3NtkHierInfo
getRefSize	ntk/v3NtkHandler.h	/^      inline const uint32_t getRefSize() const { return _refIdMap.size(); }$/;"	f	class:V3NtkHierInfo
getResult	v3mc/v3MCMain.h	/^      inline void getResult(V3VrfResultVec& result) { lock(); result = _result; unlock(); }$/;"	f	class:V3MCResult
getResult	vrf/v3VrfBase.h	/^      inline const V3VrfResult& getResult(const uint32_t& i) const { assert (i < _result.size()); return _result[i]; }$/;"	f	class:V3VrfBase
getRight	bdd/bddNodeV.cpp	/^BddNodeV::getRight() const$/;"	f	class:BddNodeV
getRight	bdd/bddNodeV.h	/^   const BddNodeV& getRight() const { return _right; }$/;"	f	class:BddNodeVInt
getRight	bdd/test/bddNodeV.h	/^   const BddNodeV& getRight() const { return _right; }$/;"	f	class:BddNodeVInt
getRightCofactor	bdd/bddNodeV.cpp	/^BddNodeV::getRightCofactor(unsigned i) const$/;"	f	class:BddNodeV
getRoot	ext/v3Formula.h	/^      inline const uint32_t getRoot() const { assert (isValid()); return _rootId; }$/;"	f	class:V3Formula
getRoot	ext/v3LTLFormula.h	/^      inline const uint32_t getRoot() const { assert (isValid()); return _rootId; }$/;"	f	class:V3LTLFormula
getSDGExpr	stg/v3StgFSM.cpp	/^V3FSMSDG::getSDGExpr(const V3UI32Vec& stateMap, string& exp) const {$/;"	f	class:V3FSMSDG
getSDGNode	stg/v3StgSDG.h	/^      inline V3SDGNode* const getSDGNode(const uint32_t& i) const { $/;"	f	class:V3SDG
getSECHandler	vrf/v3VrfSEC.h	/^      inline V3NtkHandler* const getSECHandler() const { return _secHandler; }$/;"	f	class:V3VrfSEC
getSignature	dfx/v3DfxTrace.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3DfxCube
getSignature	vrf/v3VrfCITP.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3CITPCube
getSignature	vrf/v3VrfFITP.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3FITPCube
getSignature	vrf/v3VrfIPDR.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3IPDRCube
getSignature	vrf/v3VrfMPDR.h	/^      inline const uint64_t getSignature() const { return _signature; }$/;"	f	class:V3MPDRCube
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const {$/;"	f	class:V3AlgAigSimulate
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const {$/;"	f	class:V3AlgBvSimulate
getSimRecordData	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::getSimRecordData(uint32_t cycle, V3SimTrace& traceData) const { traceData.clear(); }$/;"	f	class:V3AlgSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::getSimValue(const V3NetId& id) const {$/;"	f	class:V3AlgAigSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::getSimValue(const V3NetId& id) const {$/;"	f	class:V3AlgBvSimulate
getSimValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::getSimValue(const V3NetId& id) const { return V3BitVecX(); }$/;"	f	class:V3AlgSimulate
getSliceBit	ntk/v3Ntk.cpp	/^V3BvNtk::getSliceBit(const V3BusId& busId, const bool& msb) const {$/;"	f	class:V3BvNtk
getSliceWidth	ntk/v3Ntk.cpp	/^V3BvNtk::getSliceWidth(const V3BusId& busId) const {$/;"	f	class:V3BvNtk
getSolver	stg/v3StgFSM.h	/^      inline V3SvrBase* const getSolver() const { return _solver; }$/;"	f	class:V3FSMSDGDB
getSolver	vrf/v3VrfBase.h	/^      inline const V3SolverType getSolver() const { return (V3_SVR_TOTAL == _solverType) ? _extSolverType : _solverType; }$/;"	f	class:V3VrfBase
getSolverCexTrace	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getSolverCexTrace(V3SvrBase* const solver, const uint32_t& cycle) {$/;"	f	class:V3VrfSEC
getStart	ext/v3Property.h	/^      inline const uint32_t getStart() const { assert (isPOConstr()); return V3PairType(_constrInfo).bus[0]; }$/;"	f	class:V3Constraint
getState	dfx/v3DfxTrace.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3DfxCube
getState	vrf/v3VrfCITP.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3CITPCube
getState	vrf/v3VrfFITP.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3FITPCube
getState	vrf/v3VrfIPDR.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3IPDRCube
getState	vrf/v3VrfMPDR.h	/^      inline const V3NetVec& getState() const { return _stateId; }$/;"	f	class:V3MPDRCube
getStateBwdReachable	stg/v3StgFSM.cpp	/^V3FSM::getStateBwdReachable(const uint32_t& state, V3UI32Vec& bwdStates, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getStateFwdReachable	stg/v3StgFSM.cpp	/^V3FSM::getStateFwdReachable(const uint32_t& state, V3UI32Vec& fwdStates, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getStateName	stg/v3StgFSM.cpp	/^V3FSM::getStateName(const uint32_t& i) const {$/;"	f	class:V3FSM
getStateNet	stg/v3StgFSM.h	/^      inline const V3NetId getStateNet() const { return _netId; }$/;"	f	class:V3FSMSDG
getStateNetId	stg/v3StgFSM.cpp	/^V3FSM::getStateNetId(const uint32_t& state, V3NetVec& stateData) const {$/;"	f	class:V3FSM
getStateSize	stg/v3StgFSM.cpp	/^V3FSMSDG::getStateSize() const {$/;"	f	class:V3FSMSDG
getStateSize	stg/v3StgFSM.cpp	/^V3FSMSDGDB::getStateSize() const {$/;"	f	class:V3FSMSDGDB
getStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getStateSize() const { return _sdgDB->getStateSize(); }$/;"	f	class:V3FSM
getStateStr	vrf/v3VrfCITP.cpp	/^V3VrfCITP::getStateStr(const V3NetVec& state) const {$/;"	f	class:V3VrfCITP
getStepBwdFromTerm	stg/v3StgFSM.cpp	/^V3FSM::getStepBwdFromTerm(const uint32_t& state) const {$/;"	f	class:V3FSM
getStepFwdFromInit	stg/v3StgFSM.cpp	/^V3FSM::getStepFwdFromInit(const uint32_t& state) const {$/;"	f	class:V3FSM
getStronglyConnectedComponents	adt/v3Graph.h	/^V3Graph<T>::getStronglyConnectedComponents(V3NodeField& scc) const {$/;"	f	class:V3Graph
getStronglyConnectedComponentsIndex	adt/v3Graph.h	/^V3Graph<T>::getStronglyConnectedComponentsIndex(V3IndexField& scc) const {$/;"	f	class:V3Graph
getSubsumedCubes	dfx/v3DfxTrace.cpp	/^const V3Vec<V3DfxCube*>::Vec getSubsumedCubes(V3DfxCube* const cube, const V3DfxCubeList& stateList) {$/;"	f
getSubsumingCubes	dfx/v3DfxTrace.cpp	/^const V3Vec<V3DfxCube*>::Vec getSubsumingCubes(V3DfxCube* const cube, const V3DfxCubeList& stateList) {$/;"	f
getSupport	bdd/bddMgrV.h	/^   const BddNodeV& getSupport(size_t i) const { return _supports[i]; }$/;"	f	class:BddMgrV
getSupport	bdd/test/bddMgrV.h	/^   const BddNodeV& getSupport(size_t i) const { return _supports[i]; }$/;"	f	class:BddMgrV
getTBase	stg/v3StgSDG.h	/^      inline V3SDGBase* const getTBase() const { return _tBase; }$/;"	f	class:V3SDGMUX
getTargetCandidate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::getTargetCandidate() {$/;"	f	class:V3VrfSEC
getTermBwdReachableSize	stg/v3StgFSM.cpp	/^V3FSM::getTermBwdReachableSize() {$/;"	f	class:V3FSM
getTermStateSize	stg/v3StgFSM.cpp	/^V3FSM::getTermStateSize() const {$/;"	f	class:V3FSM
getTermStates	stg/v3StgFSM.cpp	/^V3FSM::getTermStates(V3UI32Vec& states, const bool& mileStoneOnly) const {$/;"	f	class:V3FSM
getTime	svr/v3SvrBase.cpp	/^V3SvrBase::getTime() const {$/;"	f	class:V3SvrBase
getTime	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getTime() const {$/;"	f	class:V3SvrMiniSat
getTimeUsed	vrf/v3VrfShared.h	21;"	d
getToSize	adt/v3Graph.h	/^V3Graph<T>::getToSize(const uint32_t& f) const {$/;"	f	class:V3Graph
getTotalOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::getTotalOccupiedCores() {$/;"	f	class:V3MCResource
getTrace	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::getTrace() const {$/;"	f	class:V3TraceSimplify
getTraceDataSize	ext/v3Property.h	/^      inline const uint32_t getTraceDataSize() const { return _data.size(); }$/;"	f	class:V3CexTrace
getTraceSize	ext/v3Property.h	/^      inline const uint32_t getTraceSize() const { return _size; }$/;"	f	class:V3CexTrace
getTrueSDG	stg/v3StgFSM.h	/^      inline const V3FSMSDGSet& getTrueSDG() const { return _trueSDG; }$/;"	f	class:V3FSMSDG
getTrueStateSize	stg/v3StgFSM.h	/^      inline const uint32_t getTrueStateSize() const { return _trueSize; }$/;"	f	class:V3FSMSDG
getUndecided	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::getUndecided() const {$/;"	f	class:V3AlgGeneralize
getUnrolledNtk	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::getUnrolledNtk(const bool& genOnFF, const uint32_t& f){$/;"	f	class:V3TraceSimplify
getUnsolvedSize	vrf/v3VrfShared.h	/^      inline uint32_t getUnsolvedSize() const { return _unsvd; }$/;"	f	class:V3VrfSharedBound
getUsageString	eng/minisat/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Option
getV3CmdType	cmd/v3CmdMgr.h	/^      inline V3CmdType getV3CmdType() const { return _cmdType; }$/;"	f	class:V3CmdExec
getV3ExtendNormal	ntk/v3Ntk.h	31;"	d
getV3InvertNet	ntk/v3Ntk.h	17;"	d
getV3NetIndex	ntk/v3Ntk.h	18;"	d
getVarSize	alg/v3AlgGeneralize.h	/^      inline const uint32_t getVarSize() const { return _var2Cube.size(); }$/;"	f	class:V3GenStruct
getVariableSize	stg/v3StgExtract.h	/^      inline const uint32_t getVariableSize() const { return _depGraph.getNodeSize(); }$/;"	f	class:V3FSMExtract
getVerifyData	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::getVerifyData(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrBoolector
getVerifyData	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::getVerifyData(const V3NetId& id, const uint32_t& depth) const {$/;"	f	class:V3SvrMiniSat
getVerilogModuleName	io/v3RTLWriter.cpp	/^const string getVerilogModuleName(const V3NtkHandler* const handler) {$/;"	f
getVerilogName	io/v3RTLWriter.cpp	/^const string getVerilogName(const V3NtkHandler* const handler, const string& name) {$/;"	f
greater_2	svr/v3SvrSatHelper.h	/^inline void greater_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
greater_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId greater_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
growTo	eng/minisat/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:CMap
growTo	eng/minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size) {$/;"	f	class:vec
growTo	eng/minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size, const T& pad) {$/;"	f	class:vec
has	eng/minisat/IntMap.h	/^        bool     has         (K k) { in_set.reserve(k, 0); return in_set[k]; }$/;"	f	class:IntSet
has	eng/minisat/IntMap.h	/^        bool     has       (K k) const { return index(k) < map.size(); }$/;"	f	class:IntMap
has	eng/minisat/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Map
has	eng/minisat/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:CMap
has_extra	eng/minisat/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Clause::__anon1
has_extra	eng/minisat/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Clause
hash	eng/minisat/Map.h	/^    H          hash;$/;"	m	class:Map
hash	eng/minisat/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f
hash	eng/minisat/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f
hash	eng/minisat/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f
hash	eng/minisat/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f
hashV3BusId	ntk/v3Ntk.cpp	/^V3BvNtk::hashV3BusId(const uint32_t& msb, const uint32_t& lsb) {$/;"	f	class:V3BvNtk
hashV3ConstBitVec	ntk/v3Ntk.cpp	/^V3BvNtk::hashV3ConstBitVec(const string& input_exp) {$/;"	f	class:V3BvNtk
header	eng/minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	class:Clause	typeref:struct:Clause::__anon1
heap	eng/minisat/Heap.h	/^    vec<K>                heap;     \/\/ Heap of Keys$/;"	m	class:Heap
help	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::help() const {$/;"	f	class:V3PlotTraceCmd
help	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::help() const {$/;"	f	class:V3SimNtkCmd
help	bdd/bddCmd.cpp	/^BAndCmd::help() const$/;"	f	class:BAndCmd
help	bdd/bddCmd.cpp	/^BCofactorCmd::help() const$/;"	f	class:BCofactorCmd
help	bdd/bddCmd.cpp	/^BCompareCmd::help() const$/;"	f	class:BCompareCmd
help	bdd/bddCmd.cpp	/^BConstructCmd::help() const$/;"	f	class:BConstructCmd
help	bdd/bddCmd.cpp	/^BDrawCmd::help() const$/;"	f	class:BDrawCmd
help	bdd/bddCmd.cpp	/^BExistCmd::help() const$/;"	f	class:BExistCmd
help	bdd/bddCmd.cpp	/^BInvCmd::help() const$/;"	f	class:BInvCmd
help	bdd/bddCmd.cpp	/^BNandCmd::help() const$/;"	f	class:BNandCmd
help	bdd/bddCmd.cpp	/^BNorCmd::help() const$/;"	f	class:BNorCmd
help	bdd/bddCmd.cpp	/^BOrCmd::help() const$/;"	f	class:BOrCmd
help	bdd/bddCmd.cpp	/^BReportCmd::help() const$/;"	f	class:BReportCmd
help	bdd/bddCmd.cpp	/^BResetCmd::help() const$/;"	f	class:BResetCmd
help	bdd/bddCmd.cpp	/^BSetOrderCmd::help() const$/;"	f	class:BSetOrderCmd
help	bdd/bddCmd.cpp	/^BSetVarCmd::help() const$/;"	f	class:BSetVarCmd
help	bdd/bddCmd.cpp	/^BSimulateCmd::help() const$/;"	f	class:BSimulateCmd
help	bdd/bddCmd.cpp	/^BXnorCmd::help() const$/;"	f	class:BXnorCmd
help	bdd/bddCmd.cpp	/^BXorCmd::help() const$/;"	f	class:BXorCmd
help	cmd/v3CmdComm.cpp	/^V3DofileCmd::help() const {$/;"	f	class:V3DofileCmd
help	cmd/v3CmdComm.cpp	/^V3HelpCmd::help() const {$/;"	f	class:V3HelpCmd
help	cmd/v3CmdComm.cpp	/^V3HistoryCmd::help() const {$/;"	f	class:V3HistoryCmd
help	cmd/v3CmdComm.cpp	/^V3LogFileCmd::help() const {$/;"	f	class:V3LogFileCmd
help	cmd/v3CmdComm.cpp	/^V3QuitCmd::help() const {$/;"	f	class:V3QuitCmd
help	cmd/v3CmdComm.cpp	/^V3UsageCmd::help() const {$/;"	f	class:V3UsageCmd
help	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::help() const {$/;"	f	class:V3OptTraceCmd
help	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::help() const {$/;"	f	class:V3TraceSimplifyCmd
help	eng/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:BoolOption
help	eng/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:DoubleOption
help	eng/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Int64Option
help	eng/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:IntOption
help	eng/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:StringOption
help	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::help() const {$/;"	f	class:V3DuplicateNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::help() const {$/;"	f	class:V3ListNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::help() const$/;"	f	class:V3NetInfoCmd
help	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::help() const {$/;"	f	class:V3PlotNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::help() const {$/;"	f	class:V3PrintNetCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::help() const {$/;"	f	class:V3PrintNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::help() const {$/;"	f	class:V3PrintVerbosityCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::help() const {$/;"	f	class:V3ReadAIGCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::help() const {$/;"	f	class:V3ReadBTORCmd
help	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::help() const {$/;"	f	class:V3ReadRTLCmd
help	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::help() const {$/;"	f	class:V3ReduceNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::help() const {$/;"	f	class:V3RefNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::help() const {$/;"	f	class:V3RewriteNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::help() const {$/;"	f	class:V3SetNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::help() const {$/;"	f	class:V3SetVerbosityCmd
help	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::help() const {$/;"	f	class:V3StrashNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::help() const {$/;"	f	class:V3WorkNtkCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::help() const {$/;"	f	class:V3WriteAIGCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::help() const {$/;"	f	class:V3WriteBTORCmd
help	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::help() const {$/;"	f	class:V3WriteRTLCmd
help	prove/proveCmd.cpp	/^PCheckPropertyCmd::help() const$/;"	f	class:PCheckPropertyCmd
help	prove/proveCmd.cpp	/^PImageCmd::help() const$/;"	f	class:PImageCmd
help	prove/proveCmd.cpp	/^PInitialStateCmd::help() const$/;"	f	class:PInitialStateCmd
help	prove/proveCmd.cpp	/^PTransRelationCmd::help() const$/;"	f	class:PTransRelationCmd
help	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::help() const {$/;"	f	class:V3ElaborateFSMCmd
help	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::help() const {$/;"	f	class:V3ExtractFSMCmd
help	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::help() const {$/;"	f	class:V3PlotFSMCmd
help	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::help() const {$/;"	f	class:V3WriteFSMCmd
help	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::help() const {$/;"	f	class:V3BlastNtkCmd
help	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::help() const {$/;"	f	class:V3ExpandNtkCmd
help	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::help() const {$/;"	f	class:V3FlattenNtkCmd
help	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::help() const {$/;"	f	class:V3MiterNtkCmd
help	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::help() const {$/;"	f	class:V3MCReadPropertyCmd
help	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::help() const {$/;"	f	class:V3MCRunCmd
help	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::help() const {$/;"	f	class:V3MCWritePropertyCmd
help	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::help() const {$/;"	f	class:V3BMCVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::help() const {$/;"	f	class:V3CheckResultCmd
help	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::help() const {$/;"	f	class:V3ElaboratePrptyCmd
help	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::help() const {$/;"	f	class:V3ITPVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::help() const {$/;"	f	class:V3KLiveVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::help() const {$/;"	f	class:V3PDRVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::help() const {$/;"	f	class:V3PlotResultCmd
help	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::help() const {$/;"	f	class:V3PrintReportCmd
help	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::help() const {$/;"	f	class:V3PrintSolverCmd
help	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::help() const {$/;"	f	class:V3SECVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::help() const {$/;"	f	class:V3SIMVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::help() const {$/;"	f	class:V3SetLivenessCmd
help	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::help() const {$/;"	f	class:V3SetReportCmd
help	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::help() const {$/;"	f	class:V3SetSafetyCmd
help	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::help() const {$/;"	f	class:V3SetSolverCmd
help	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::help() const {$/;"	f	class:V3UMCVrfCmd
help	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::help() const {$/;"	f	class:V3WriteResultCmd
hwmcc_aiger_decode	v3mc/v3MCAiger.cpp	/^unsigned hwmcc_aiger_decode(FILE* file) {$/;"	f
hwmcc_aiger_getnoneofch	v3mc/v3MCAiger.cpp	/^unsigned char hwmcc_aiger_getnoneofch(FILE* file) {$/;"	f
hwmcc_aiger_symbol	v3mc/v3MCAiger.cpp	/^bool hwmcc_aiger_symbol(FILE* file, unsigned char& c, uint32_t& index, string& name) {$/;"	f
hwmcc_encode_aig	v3mc/v3MCAiger.cpp	/^void hwmcc_encode_aig(ofstream& output, int x) {$/;"	f
i	eng/minisat/Solver.h	/^        uint32_t i;$/;"	m	struct:Solver::ShrinkStackElem
id	ntk/v3Type.h	/^   V3NetId     id;$/;"	m	union:V3NetType
id	ntk/v3Type.h	/^   uint32_t    id : 31;$/;"	m	struct:V3NetId
identifyCandidates	stg/v3StgSDG.cpp	/^V3AigSDG::identifyCandidates() {$/;"	f	class:V3AigSDG
in	eng/minisat/ParseUtils.h	/^    gzFile         in;$/;"	m	class:StreamBuffer
inHeap	eng/minisat/Heap.h	/^    bool inHeap    (K k)       const { return indices.has(k) && indices[k] >= 0; }$/;"	f	class:Heap
in_set	eng/minisat/IntMap.h	/^        IntMap<K, char, MkIndex> in_set;$/;"	m	class:IntSet
inc	alg/v3AlgGeneralize.cpp	/^V3GenBucket::inc(const uint32_t& data, const uint32_t& amount) {$/;"	f	class:V3GenBucket
incInstRef	ntk/v3NtkHandler.h	/^      inline void incInstRef() { ++_instRef; assert (_instRef); }$/;"	f	class:V3NtkHandler
incOccupiedCores	v3mc/v3MCMain.cpp	/^V3MCResource::incOccupiedCores(const V3MCMainType& t) {$/;"	f	class:V3MCResource
incRefCount	bdd/bddNodeV.h	/^   void incRefCount() { ++_refCount; }$/;"	f	class:BddNodeVInt
incRefCount	bdd/test/bddNodeV.h	/^   void incRefCount() { ++_refCount; }$/;"	f	class:BddNodeVInt
incRefCount	ntk/v3NtkHandler.h	/^      inline void incRefCount() { ++_refCount; assert (_refCount); }$/;"	f	class:V3NtkHandler
increase	eng/minisat/Heap.h	/^    void increase  (K k) { assert(inHeap(k)); percolateDown(indices[k]); }$/;"	f	class:Heap
index	eng/minisat/IntMap.h	/^        MkIndex  index;$/;"	m	class:IntMap
index	eng/minisat/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Map
indices	eng/minisat/Heap.h	/^    IntMap<K,int,MkIndex> indices;  \/\/ Each Key's position (index) in the Heap$/;"	m	class:Heap
init	adt/v3Bucket.h	/^V3BucketList<T>::init(const uint32_t& size) {$/;"	f	class:V3BucketList
init	adt/v3Bucket.h	/^V3IncBucketList<T>::init(const uint32_t& size) {$/;"	f	class:V3IncBucketList
init	bdd/bddMgrV.cpp	/^BddMgrV::init(size_t nin, size_t h, size_t c)$/;"	f	class:BddMgrV
init	bdd/myHash.h	/^   void init(size_t b) {$/;"	f	class:Hash
init	bdd/myHash.h	/^   void init(size_t s) { reset(); _size = s; _cache = new CacheNode[s]; }$/;"	f	class:Cache
init	bdd/test/myHash.h	/^   void init(size_t b) {$/;"	f	class:Hash
init	bdd/test/myHash.h	/^   void init(size_t s) { reset(); _size = s; _cache = new CacheNode[s]; }$/;"	f	class:Cache
init	eng/minisat/SolverTypes.h	/^    void  init      (const K& idx){ occs.reserve(idx); occs[idx].clear(); dirty.reserve(idx, 0); }$/;"	f	class:OccLists
initAlgCmd	alg/v3AlgCmd.cpp	/^bool initAlgCmd() {$/;"	f
initBdd	bdd/test/testBdd.cpp	/^initBdd(size_t nin, size_t h, size_t c)$/;"	f	file:
initBddCmd	bdd/bddCmd.cpp	/^initBddCmd() {$/;"	f
initCommonCmd	cmd/v3CmdComm.cpp	/^bool initCommonCmd() {$/;"	f
initDfxCmd	dfx/v3DfxCmd.cpp	/^bool initDfxCmd() {$/;"	f
initNtkCmd	ntk/v3NtkCmd.cpp	/^bool initNtkCmd() {$/;"	f
initProveCmd	prove/proveCmd.cpp	/^initProveCmd() {$/;"	f
initRelease	svr/v3SvrBase.cpp	/^V3SvrBase::initRelease() {$/;"	f	class:V3SvrBase
initRelease	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::initRelease() {$/;"	f	class:V3SvrBoolector
initRelease	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::initRelease() { _init.clear(); }$/;"	f	class:V3SvrMiniSat
initStgCmd	stg/v3StgCmd.cpp	/^bool initStgCmd() {$/;"	f
initTransCmd	trans/v3TransCmd.cpp	/^bool initTransCmd() {$/;"	f
initV3MCCmd	v3mc/v3MCCmd.cpp	/^bool initV3MCCmd() {$/;"	f
initVrfCmd	vrf/v3VrfCmd.cpp	/^bool initVrfCmd() {$/;"	f
initialize	ntk/v3Ntk.cpp	/^V3BvNtk::initialize() {$/;"	f	class:V3BvNtk
initialize	ntk/v3Ntk.cpp	/^V3Ntk::initialize() {$/;"	f	class:V3Ntk
initializeBMCSolver	vrf/v3VrfCITP.cpp	/^V3VrfCITP::initializeBMCSolver(const uint32_t& start, const uint32_t& frames) {$/;"	f	class:V3VrfCITP
initializeBMCSolver	vrf/v3VrfFITP.cpp	/^V3VrfFITP::initializeBMCSolver(const uint32_t& start, const uint32_t& frames) {$/;"	f	class:V3VrfFITP
initializeDepGraph	stg/v3StgExtract.cpp	/^V3FSMExtract::initializeDepGraph() {$/;"	f	class:V3FSMExtract
initializeECPair	vrf/v3VrfSEC.cpp	/^V3VrfSEC::initializeECPair() {$/;"	f	class:V3VrfSEC
initializeEventList	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::initializeEventList() {$/;"	f	class:V3AlgSimulate
initializeITPSolver	vrf/v3VrfCITP.cpp	/^V3VrfCITP::initializeITPSolver() {$/;"	f	class:V3VrfCITP
initializeITPSolver	vrf/v3VrfFITP.cpp	/^V3VrfFITP::initializeITPSolver() {$/;"	f	class:V3VrfFITP
initializeNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::initializeNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
initializeOperatorMap	ext/v3Formula.cpp	/^V3Formula::initializeOperatorMap() {$/;"	f	class:V3Formula
initializeReachTable	stg/v3StgFSM.cpp	/^V3FSM::initializeReachTable(const uint32_t& state) {$/;"	f	class:V3FSM
initializeSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::initializeSolver(const uint32_t& d, const bool& isReuse) {$/;"	f	class:V3VrfIPDR
initializeSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::initializeSolver() {$/;"	f	class:V3VrfMPDR
insert	bdd/myHash.h	/^   bool insert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
insert	bdd/test/myHash.h	/^   bool insert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
insert	eng/minisat/Heap.h	/^    void insert(K k)$/;"	f	class:Heap
insert	eng/minisat/IntMap.h	/^        void     insert      (K k) { in_set.reserve(k, 0); if (!in_set[k]) { in_set[k] = 1; xs.push(k); } }$/;"	f	class:IntSet
insert	eng/minisat/IntMap.h	/^        void     insert (K key, V val)       { reserve(key); operator[](key) = val; }$/;"	f	class:IntMap
insert	eng/minisat/IntMap.h	/^        void     insert (K key, V val, V pad){ reserve(key, pad); operator[](key) = val; }$/;"	f	class:IntMap
insert	eng/minisat/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Map
insert	eng/minisat/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Queue
insert	eng/minisat/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:CMap
insertEdge	adt/v3Graph.h	/^V3Graph<T>::insertEdge(const T& f, const T& t) {$/;"	f	class:V3Graph
insertFF	stg/v3StgSDG.h	/^      inline void insertFF(const uint32_t& i) { _depFFSet.insert(i); }$/;"	f	class:V3SDGBase
insertMux	stg/v3StgSDG.h	/^      inline void insertMux(const uint32_t& i) { _depMuxSet.insert(i); }$/;"	f	class:V3SDGBase
insertNode	adt/v3Graph.h	/^V3Graph<T>::insertNode(const T& n) {$/;"	f	class:V3Graph
insertVarOrder	eng/minisat/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Solver
intactON	vrf/v3VrfBase.h	/^      static inline const bool intactON()  { return reportON() && !(2ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
interrupt	eng/minisat/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Solver
inv	trans/v3BvBlastAigHelper.h	/^inline const V3NetId inv(V3Ntk* const ntk, const V3NetId& a)$/;"	f
irand	eng/minisat/Rnd.h	/^static inline int irand(double& seed, int size) { return (int)(drand(seed) * size); }$/;"	f
irand	eng/minisat/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Solver
isAllOutFileON	util/v3Msg.h	/^      bool isAllOutFileON() { return V3Msg::_allout.is_open(); }$/;"	f	class:V3MsgMgr
isAllReachableFromBwd	stg/v3StgFSM.cpp	/^V3FSM::isAllReachableFromBwd() const {$/;"	f	class:V3FSM
isAllReachableFromFwd	stg/v3StgFSM.cpp	/^V3FSM::isAllReachableFromFwd() const {$/;"	f	class:V3FSM
isAssumeCECMiter	vrf/v3VrfSEC.h	/^      inline const bool isAssumeCECMiter() const { return _secCECAssumed; }$/;"	f	class:V3VrfSEC
isAssumeSECMiter	vrf/v3VrfSEC.h	/^      inline const bool isAssumeSECMiter() const { return _secSECAssumed; }$/;"	f	class:V3VrfSEC
isBddBuilt	ntk/v3Ntk.h	/^      const bool isBddBuilt() const { return _isBddBuilt; }$/;"	f	class:V3Ntk
isBlockBadCountIndep	vrf/v3VrfCITP.h	/^      inline const bool isBlockBadCountIndep()  const { return _itpAttr & 4ul;  }$/;"	f	class:V3VrfCITP
isBlockBadCountIndep	vrf/v3VrfFITP.h	/^      inline const bool isBlockBadCountIndep()  const { return _itpAttr & 4ul;  }$/;"	f	class:V3VrfFITP
isBlocked	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::isBlocked(const V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
isBlocked	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::isBlocked(const V3MPDRTimedCube& timedCube) {$/;"	f	class:V3VrfMPDR
isCex	ext/v3Property.h	/^      inline const bool isCex() const { return ((_cexOrInv & ~1ul) && !(_cexOrInv & 1ul)); }$/;"	f	class:V3VrfResult
isCharMatchToken	io/v3RTLParser.cpp	/^bool isCharMatchToken(const char& c, const V3RTLSplitToken& split) {$/;"	f
isCompleteFSM	stg/v3StgFSM.h	/^      inline const bool isCompleteFSM() const { return !(128ul & _configs) && _distInit.size(); }$/;"	f	class:V3FSM
isConstructStandardFSMEnabled	stg/v3StgFSM.h	/^      inline const bool isConstructStandardFSMEnabled() const { return 8ul & _configs; }$/;"	f	class:V3FSMSDGDB
isDynamicInc	vrf/v3VrfUMC.h	/^      inline const bool isDynamicInc() { return _umcAttr & 8ul; }$/;"	f	class:V3VrfUMC
isEarlySuspended	stg/v3StgFSM.h	/^      inline const bool isEarlySuspended() const { return 128ul & _configs; }$/;"	f	class:V3FSMSDGDB
isEmpty	alg/v3AlgGeneralize.h	/^      inline const bool isEmpty() const { return _buckets.size() <= _bestIndex; }$/;"	f	class:V3GenBucket
isEmpty	vrf/v3VrfCITP.h	/^      inline const bool isEmpty() const { return !_signature; }$/;"	f	class:V3CITPCube
isEmpty	vrf/v3VrfFITP.h	/^      inline const bool isEmpty() const { return !_signature; }$/;"	f	class:V3FITPCube
isEnableConstructStandardFSM	stg/v3StgExtract.h	/^      inline const bool isEnableConstructStandardFSM() const { return _configs & 256ul; }$/;"	f	class:V3FSMExtract
isEnableOmitNodesAllCombVars	stg/v3StgExtract.h	/^      inline const bool isEnableOmitNodesAllCombVars() const { return _configs & 16ul;  }$/;"	f	class:V3FSMExtract
isEnableOmitNodesIndepToVars	stg/v3StgExtract.h	/^      inline const bool isEnableOmitNodesIndepToVars() const { return _configs & 32ul;  }$/;"	f	class:V3FSMExtract
isEnableRenderNonEmptyStates	stg/v3StgExtract.h	/^      inline const bool isEnableRenderNonEmptyStates() const { return _configs & 64ul;  }$/;"	f	class:V3FSMExtract
isEnableStopOnAllInitOrTerms	stg/v3StgExtract.h	/^      inline const bool isEnableStopOnAllInitOrTerms() const { return _configs & 128ul; }$/;"	f	class:V3FSMExtract
isEof	eng/minisat/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f
isEof	eng/minisat/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f
isExternalSolver	stg/v3StgFSM.h	/^      inline const bool isExternalSolver() const { return  64ul & _configs; }$/;"	f	class:V3FSMSDGDB
isFSMConstr	ext/v3Property.h	/^      inline const bool isFSMConstr() const { return 1ul == (3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
isFilterOutNoMuxVariable	stg/v3StgExtract.h	/^      inline const bool isFilterOutNoMuxVariable()     const { return _configs & 4ul;   }$/;"	f	class:V3FSMExtract
isFilterOutNonSeqVariable	stg/v3StgExtract.h	/^      inline const bool isFilterOutNonSeqVariable()    const { return _configs & 8ul;   }$/;"	f	class:V3FSMExtract
isFireOnly	vrf/v3VrfUMC.h	/^      inline const bool isFireOnly  () { return _umcAttr & 1ul; }$/;"	f	class:V3VrfUMC
isFired	ext/v3Property.h	/^      inline const bool isFired() const { return _result.isCex(); }$/;"	f	class:V3Property
isForceUnreachable	vrf/v3VrfCITP.h	/^      inline const bool isForceUnreachable()    const { return _itpAttr & 2ul;  }$/;"	f	class:V3VrfCITP
isForceUnreachable	vrf/v3VrfFITP.h	/^      inline const bool isForceUnreachable()    const { return _itpAttr & 2ul;  }$/;"	f	class:V3VrfFITP
isForwardSATGen	vrf/v3VrfIPDR.h	/^      inline const bool isForwardSATGen()   const { return _pdrAttr & 1ul; }$/;"	f	class:V3VrfIPDR
isForwardSATGen	vrf/v3VrfMPDR.h	/^      inline const bool isForwardSATGen()   const { return _pdrAttr & 1ul; }$/;"	f	class:V3VrfMPDR
isForwardUNSATGen	vrf/v3VrfIPDR.h	/^      inline const bool isForwardUNSATGen() const { return _pdrAttr & 2ul; }$/;"	f	class:V3VrfIPDR
isForwardUNSATGen	vrf/v3VrfMPDR.h	/^      inline const bool isForwardUNSATGen() const { return _pdrAttr & 2ul; }$/;"	f	class:V3VrfMPDR
isIncContinueOnLastSolver	vrf/v3VrfBase.h	/^      inline const bool isIncContinueOnLastSolver() const { return _incContinueOnLastSolver; }$/;"	f	class:V3VrfBase
isIncKeepLastReachability	vrf/v3VrfBase.h	/^      inline const bool isIncKeepLastReachability() const { return _incKeepLastReachability; }$/;"	f	class:V3VrfBase
isIncKeepSilent	vrf/v3VrfBase.h	/^      inline const bool isIncKeepSilent          () const { return _incKeepSilent;           }$/;"	f	class:V3VrfBase
isIncVerifyUsingCurResult	vrf/v3VrfBase.h	/^      inline const bool isIncVerifyUsingCurResult() const { return _incVerifyUsingCurResult; }$/;"	f	class:V3VrfBase
isIncrementDepth	vrf/v3VrfCITP.h	/^      inline const bool isIncrementDepth()      const { return _itpAttr & 1ul;  }$/;"	f	class:V3VrfCITP
isIncrementDepth	vrf/v3VrfFITP.h	/^      inline const bool isIncrementDepth()      const { return _itpAttr & 1ul;  }$/;"	f	class:V3VrfFITP
isInternalCEC	vrf/v3VrfSEC.h	/^      inline const bool isInternalCEC() const { return _secCECAssumed && !_secIsCECorSEC; }$/;"	f	class:V3VrfSEC
isInternalSEC	vrf/v3VrfSEC.h	/^      inline const bool isInternalSEC() const { return _secSECAssumed &&  _secIsCECorSEC; }$/;"	f	class:V3VrfSEC
isInv	ext/v3Property.h	/^      inline const bool isInv() const { return ((_cexOrInv & ~1ul) &&  (_cexOrInv & 1ul)); }$/;"	f	class:V3VrfResult
isInvariantDirectedCluster	stg/v3StgExtract.h	/^      inline const bool isInvariantDirectedCluster()   const { return _configs & 2ul;   }$/;"	f	class:V3FSMExtract
isIsolatedNode	adt/v3Graph.h	/^V3Graph<T>::isIsolatedNode(const uint32_t& i) const {$/;"	f	class:V3Graph
isLatestMiscData	ntk/v3Ntk.h	/^inline const bool V3Ntk::isLatestMiscData(const V3NetId& id) const {$/;"	f	class:V3Ntk
isLeaf	ext/v3Formula.h	/^      inline const bool isLeaf(const uint32_t& i) const { assert (isValid(i)); return V3_PI == _formula[i].first; }$/;"	f	class:V3Formula
isLeaf	ext/v3LTLFormula.h	/^      inline const bool isLeaf(const uint32_t& i) const { assert (isValid(i)); return V3_LTL_P == _formula[i].first; }$/;"	f	class:V3LTLFormula
isLegalFSMName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::isLegalFSMName(const string& fsmName) const {$/;"	f	class:V3NtkHandler
isLegalNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::isLegalNetName(const string& name) {$/;"	f	class:V3NtkHandler
isMemValid	vrf/v3VrfShared.h	/^      inline const bool isMemValid() { lock(); const double m = v3Usage.getMemUsage(); unlock(); return _maxMemory > m; }$/;"	f	class:V3VrfSharedMem
isMileStone	stg/v3StgFSM.cpp	/^V3FSM::isMileStone(const uint32_t& state) const {$/;"	f	class:V3FSM
isMutable	ntk/v3NtkHandler.h	/^      inline const bool isMutable() const { return !(_refCount || _instRef); }$/;"	f	class:V3NtkHandler
isNegEdge	bdd/bddNodeV.h	/^   bool isNegEdge() const { return (_nodeV & BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
isNegEdge	bdd/test/bddNodeV.h	/^   bool isNegEdge() const { return (_nodeV & BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
isNegFormula	svr/v3SvrBase.cpp	/^V3SvrBase::isNegFormula(const size_t& var_exp) const {$/;"	f	class:V3SvrBase
isNegFormula	svr/v3SvrBoolector.h	/^      inline const bool isNegFormula(const size_t& e) const { return (e & 2ul); }$/;"	f	class:V3SvrBoolector
isNegFormula	svr/v3SvrMiniSat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:V3SvrMiniSat
isNoIncBySharedBound	vrf/v3VrfCITP.h	/^      inline const bool isNoIncBySharedBound()  const { return _itpAttr & 8ul;  }$/;"	f	class:V3VrfCITP
isNoIncBySharedBound	vrf/v3VrfFITP.h	/^      inline const bool isNoIncBySharedBound()  const { return _itpAttr & 8ul;  }$/;"	f	class:V3VrfFITP
isNtkRefBlackBoxed	ntk/v3Ntk.h	/^      inline const bool isNtkRefBlackBoxed() const { return (_ref & 1ul); }$/;"	f	class:V3NtkModule
isNtkValid	ntk/v3NtkHandler.h	/^      inline const bool isNtkValid(const uint32_t& i) const { return i < _hierInfo.size(); }$/;"	f	class:V3NtkHierInfo
isOmitNodesAllCombVarsEnabled	stg/v3StgFSM.h	/^      inline const bool isOmitNodesAllCombVarsEnabled() const { return 1ul & _configs; }$/;"	f	class:V3FSMSDGDB
isOmitNodesIndepToVarsEnabled	stg/v3StgFSM.h	/^      inline const bool isOmitNodesIndepToVarsEnabled() const { return 2ul & _configs; }$/;"	f	class:V3FSMSDGDB
isOutFileON	util/v3Msg.h	/^      bool isOutFileON() { return _outfile.is_open(); }$/;"	f	class:V3Msg
isOutputSet	svr/v3SvrBase.cpp	/^V3SvrBase::isOutputSet() const {$/;"	f	class:V3SvrBase
isPFixed	bdd/bddMgrV.h	/^   bool isPFixed() const { return _isFixed; }$/;"	f	class:BddMgrV
isPFixed	bdd/test/bddMgrV.h	/^   bool isPFixed() const { return _isFixed; }$/;"	f	class:BddMgrV
isPOConstr	ext/v3Property.h	/^      inline const bool isPOConstr()  const { return 0   == (3ul & (size_t)(_handler)); }$/;"	f	class:V3Constraint
isPosEdge	bdd/bddNodeV.h	/^   bool isPosEdge() const { return !isNegEdge(); }$/;"	f	class:BddNodeV
isPosEdge	bdd/test/bddNodeV.h	/^   bool isPosEdge() const { return !isNegEdge(); }$/;"	f	class:BddNodeV
isProveOnly	vrf/v3VrfUMC.h	/^      inline const bool isProveOnly () { return _umcAttr & 2ul; }$/;"	f	class:V3VrfUMC
isProven	ext/v3Property.h	/^      inline const bool isProven() const { return _result.isInv(); }$/;"	f	class:V3Property
isRecycleInterpolants	vrf/v3VrfCITP.h	/^      inline const bool isRecycleInterpolants() const { return _itpAttr & 16ul; }$/;"	f	class:V3VrfCITP
isRecycleInterpolants	vrf/v3VrfFITP.h	/^      inline const bool isRecycleInterpolants() const { return _itpAttr & 16ul; }$/;"	f	class:V3VrfFITP
isRefValid	ntk/v3NtkHandler.h	/^      inline const bool isRefValid(const uint32_t& i) const { return i < _refIdMap.size(); }$/;"	f	class:V3NtkHierInfo
isRemoved	eng/minisat/Solver.h	/^inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }$/;"	f	class:Solver
isRenderNonEmptyStatesEnabled	stg/v3StgFSM.h	/^      inline const bool isRenderNonEmptyStatesEnabled() const { return 4ul & _configs; }$/;"	f	class:V3FSMSDGDB
isStopOnAllInitialOrAllTerminal	stg/v3StgFSM.h	/^      inline const bool isStopOnAllInitialOrAllTerminal() const { return 1ul & _configs; }$/;"	f	class:V3FSM
isSynthesisMode	vrf/v3VrfSEC.h	/^      inline const bool isSynthesisMode() const { return _secSynthesis; }$/;"	f	class:V3VrfSEC
isTerminal	bdd/bddNodeV.cpp	/^BddNodeV::isTerminal() const$/;"	f	class:BddNodeV
isUniqueness	vrf/v3VrfUMC.h	/^      inline const bool isUniqueness() { return _umcAttr & 4ul; }$/;"	f	class:V3VrfUMC
isV3BlackBoxed	ntk/v3Ntk.h	20;"	d
isV3ConstType	ntk/v3Ntk.h	21;"	d
isV3ExchangableType	ntk/v3Ntk.h	29;"	d
isV3ExtendInvIn	ntk/v3Ntk.h	26;"	d
isV3ExtendInvOut	ntk/v3Ntk.h	27;"	d
isV3ExtendSwapIn	ntk/v3Ntk.h	25;"	d
isV3ExtendType	ntk/v3Ntk.h	24;"	d
isV3NetInverted	ntk/v3Ntk.h	19;"	d
isV3PairType	ntk/v3Ntk.h	23;"	d
isV3ReducedType	ntk/v3Ntk.h	22;"	d
isValid	ext/v3Formula.h	/^      inline const bool isValid() const { return _rootId < _formula.size(); }$/;"	f	class:V3Formula
isValid	ext/v3Formula.h	/^      inline const bool isValid(const uint32_t& i) const { return i < _formula.size(); }$/;"	f	class:V3Formula
isValid	ext/v3LTLFormula.h	/^      inline const bool isValid() const { return _rootId < _formula.size(); }$/;"	f	class:V3LTLFormula
isValid	ext/v3LTLFormula.h	/^      inline const bool isValid(const uint32_t& i) const { return i < _formula.size(); }$/;"	f	class:V3LTLFormula
isValid	stg/v3StgFSM.h	/^      inline const bool isValid() const { return !isEarlySuspended() && (getStateSize() <= _maxSize); }$/;"	f	class:V3FSMSDGDB
isValidBddName	bdd/bddCmd.cpp	/^static bool isValidBddName(const string& str)$/;"	f	file:
isValidCandidates	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidCandidates(const uint32_t& cycle) const {$/;"	f	class:V3VrfSEC
isValidChecker	vrf/v3VrfKLive.cpp	/^V3VrfKLive::isValidChecker() const {$/;"	f	class:V3VrfKLive
isValidChecker	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidChecker() const {$/;"	f	class:V3VrfSEC
isValidCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::isValidCube(const V3NetVec& cube) const {$/;"	f	class:V3GenStruct
isValidInvariant	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidInvariant(const uint32_t& x) {$/;"	f	class:V3VrfSEC
isValidNet	vrf/v3VrfSEC.cpp	/^V3VrfSEC::isValidNet(const V3NetId& id) const {$/;"	f	class:V3VrfSEC
isValidVarName	bdd/bddCmd.cpp	/^static bool isValidVarName(const string& str) {$/;"	f	file:
isValidVarName	prove/proveCmd.cpp	/^static bool isValidVarName(const string& str) {$/;"	f	file:
isVariableClusterBySCC	stg/v3StgExtract.h	/^      inline const bool isVariableClusterBySCC()       const { return _configs & 1ul;   }$/;"	f	class:V3FSMExtract
isVisited	bdd/bddNodeV.h	/^   bool isVisited() const { return (_visited == 1); }$/;"	f	class:BddNodeVInt
isVisited	bdd/test/bddNodeV.h	/^   bool isVisited() const { return (_visited == 1); }$/;"	f	class:BddNodeVInt
ite	bdd/bddMgrV.cpp	/^BddMgrV::ite(BddNodeV f, BddNodeV g, BddNodeV h)$/;"	f	class:BddMgrV
iterator	bdd/myHash.h	/^      iterator(Hash<HashKey, HashData>* h = 0, size_t b = 0, size_t bn = 0)$/;"	f	class:Hash::iterator
iterator	bdd/myHash.h	/^      iterator(const iterator& i)$/;"	f	class:Hash::iterator
iterator	bdd/myHash.h	/^   class iterator$/;"	c	class:Hash
iterator	bdd/test/myHash.h	/^      iterator(Hash<HashKey, HashData>* h = 0, size_t b = 0, size_t bn = 0)$/;"	f	class:Hash::iterator
iterator	bdd/test/myHash.h	/^      iterator(const iterator& i)$/;"	f	class:Hash::iterator
iterator	bdd/test/myHash.h	/^   class iterator$/;"	c	class:Hash
key	eng/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Map::Pair
l	eng/minisat/Solver.h	/^        Lit      l;$/;"	m	struct:Solver::ShrinkStackElem
l_False	eng/minisat/SolverTypes.h	125;"	d
l_True	eng/minisat/SolverTypes.h	124;"	d
l_Undef	eng/minisat/SolverTypes.h	126;"	d
last	eng/minisat/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Clause
last	eng/minisat/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	eng/minisat/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
lbool	eng/minisat/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:lbool
lbool	eng/minisat/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:lbool
lbool	eng/minisat/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	eng/minisat/SolverTypes.h	/^class lbool {$/;"	c
lea	eng/minisat/Alloc.h	/^    T*       lea       (Ref r)       { assert(r < sz); return &memory[r]; }$/;"	f	class:RegionAllocator
lea	eng/minisat/Alloc.h	/^    const T* lea       (Ref r) const { assert(r < sz); return &memory[r]; }$/;"	f	class:RegionAllocator
lea	eng/minisat/SolverTypes.h	/^    Clause*       lea       (CRef r)         { return (Clause*)ra.lea(r); }$/;"	f	class:ClauseAllocator
lea	eng/minisat/SolverTypes.h	/^    const Clause* lea       (CRef r) const   { return (Clause*)ra.lea(r);; }$/;"	f	class:ClauseAllocator
learnt	eng/minisat/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Clause::__anon1
learnt	eng/minisat/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Clause
learnts	eng/minisat/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Solver
learnts_literals	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
learntsize_adjust_cnt	eng/minisat/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Solver
learntsize_adjust_confl	eng/minisat/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Solver
learntsize_adjust_inc	eng/minisat/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Solver
learntsize_adjust_start_confl	eng/minisat/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Solver
learntsize_factor	eng/minisat/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Solver
learntsize_inc	eng/minisat/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Solver
left	eng/minisat/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Heap
leq_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId leq_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
less_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId less_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
level	eng/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Solver::VarData
level	eng/minisat/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Solver
lexConcatenateOperand	ext/v3Formula.cpp	/^V3Formula::lexConcatenateOperand(const string& exp, uint32_t& lhs) {$/;"	f	class:V3Formula
lexConstOperand	ext/v3Formula.cpp	/^V3Formula::lexConstOperand(const string& exp) {$/;"	f	class:V3Formula
lexFSMSpec	stg/v3StgExtract.cpp	/^const bool lexFSMSpec(ifstream& input, uint32_t& lineNumber, V3StrVec& tokens) {$/;"	f
lexFormula	ext/v3Formula.cpp	/^V3Formula::lexFormula(V3OperatorMap::const_iterator& it, string& exp, uint32_t& lhs) {$/;"	f	class:V3Formula
lexHeaderInCexTrace	ext/v3ExtIO.cpp	/^inline const bool lexHeaderInCexTrace(const string& header, uint32_t& pC, uint32_t& pS, uint32_t& iS) {$/;"	f
lexLTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::lexLTLFormula(const string& exp) {$/;"	f	class:V3LTLFormula
lexLineBTOR	io/v3BtorParser.cpp	/^bool lexLineBTOR(ifstream& input, V3BtorLexVec& tokens) {$/;"	f
lexLineRTL	io/v3RTLParser.cpp	/^bool lexLineRTL(ifstream& input, V3StrVec& tokens, const V3RTLSplitToken& split) {$/;"	f
lexOperand	ext/v3Formula.cpp	/^V3Formula::lexOperand(const string& exp, uint32_t& index) {$/;"	f	class:V3Formula
lexOptions	cmd/v3CmdMgr.cpp	/^V3CmdExec::lexOptions(const string& option, vector<string>& tokens) const {$/;"	f	class:V3CmdExec
lexPropSpec	v3mc/v3MCProp.cpp	/^const bool lexPropSpec(ifstream& input, uint32_t& lineNumber, V3StrVec& tokens) {$/;"	f
lexSliceOperand	ext/v3Formula.cpp	/^V3Formula::lexSliceOperand(const string& exp, uint32_t& msb, uint32_t& lsb, uint32_t& index) {$/;"	f	class:V3Formula
lit	eng/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Clause::__anon2
lit_Error	eng/minisat/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	v
lit_Undef	eng/minisat/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	v
lits	eng/minisat/SolverTypes.h	/^    const Lit* lits;$/;"	m	class:TrailIterator
lock	vrf/v3VrfShared.h	/^      inline void lock() { pthread_mutex_lock(&_mutex); }$/;"	f	class:V3VrfShared
locked	eng/minisat/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Solver
lookup	eng/minisat/SolverTypes.h	/^    Vec&  lookup    (const K& idx){ if (dirty[idx]) clean(idx); return occs[idx]; }$/;"	f	class:OccLists
lt	eng/minisat/Heap.h	/^    Comp                  lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Heap
luby_restart	eng/minisat/Solver.h	/^    bool      luby_restart;$/;"	m	class:Solver
main	bdd/test/testBdd.cpp	/^main()$/;"	f
main	main/main.cpp	/^int main(int argc, char** argv) {$/;"	f
makeNetId	ntk/v3Type.h	/^   static V3NetId makeNetId(uint32_t i = V3NtkUD, uint32_t c = 0) { V3NetId j; j.cp = c; j.id = i; return j; }$/;"	f	struct:V3NetId
map	eng/minisat/IntMap.h	/^        vec<V>   map;$/;"	m	class:IntMap
map	eng/minisat/SolverTypes.h	/^    HashTable map;$/;"	m	class:CMap
mark	eng/minisat/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Clause::__anon1
mark	eng/minisat/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Clause
mark	eng/minisat/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Clause
markDepFF	stg/v3StgSDG.cpp	/^V3SDGBase::markDepFF(V3BitVec& marker) const {$/;"	f	class:V3SDGBase
markDepMux	stg/v3StgSDG.cpp	/^V3SDGBase::markDepMux(V3BitVec& marker) const {$/;"	f	class:V3SDGBase
match	eng/minisat/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f
max	eng/minisat/Vec.h	/^    static inline Size max(Size x, Size y){ return (x > y) ? x : y; }$/;"	f	class:vec
max_learnts	eng/minisat/Solver.h	/^    double              max_learnts;$/;"	m	class:Solver
max_literals	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
maximizeDontCares	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::maximizeDontCares(V3Ntk* const unrolledNtk, V3AlgGeneralize* const unrolledGen, const V3SimTrace& piValue, V3SimTrace& ffValue, const V3NetVec& targetNets) {$/;"	f	class:V3TraceSimplify
memory	eng/minisat/Alloc.h	/^    T*        memory;$/;"	m	class:RegionAllocator
mergeBitBlastedNets	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::mergeBitBlastedNets(V3NetId id, const uint32_t& size, const V3NetId& mergedId) {$/;"	f	class:V3BvBlastBv
mergeFairnessConstraints	v3mc/v3MCElaborate.cpp	/^void mergeFairnessConstraints(V3Ntk* const ntk, V3NetTable& constr) {$/;"	f
mergeMuxFaninSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::mergeMuxFaninSDG(V3FSMSDG* const sdgNew, V3FSMSDG* const sdgOld, const bool& invert) {$/;"	f	class:V3FSMSDGDB
min_learnts_lim	eng/minisat/Solver.h	/^    int       min_learnts_lim;    \/\/ Minimum number to set the learnts limit to.$/;"	m	class:Solver
minimizeTransitions	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::minimizeTransitions(V3Ntk* const unrolledNtk, V3AlgGeneralize* const unrolledGen, const V3SimTrace& piValue, V3SimTrace& ffValue, const V3NetVec& targetNets) {$/;"	f	class:V3TraceSimplify
misc	ntk/v3Type.h	/^   uint32_t    misc : 26;$/;"	m	struct:V3MiscType
mkLit	eng/minisat/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f
mkVarData	eng/minisat/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Solver
model	eng/minisat/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Solver
modelValue	eng/minisat/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Solver
modelValue	eng/minisat/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Solver
moveTo	eng/minisat/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:RegionAllocator
moveTo	eng/minisat/IntMap.h	/^        void     moveTo (IntMap& to)           { map.moveTo(to.map); to.index = index; }$/;"	f	class:IntMap
moveTo	eng/minisat/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Map
moveTo	eng/minisat/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:CMap
moveTo	eng/minisat/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:ClauseAllocator
moveTo	eng/minisat/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
msgMutex	util/v3Msg.h	/^      pthread_mutex_t msgMutex;$/;"	m	class:V3MsgMgr
mux	trans/v3BvBlastAigHelper.h	/^inline const V3NetId mux(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& s)$/;"	f
mux_a	svr/v3SvrSatHelper.h	/^inline void mux_a(Solver* SS, const Lit& o, const Lit& s, const Lit& a)$/;"	f
mux_abo	svr/v3SvrSatHelper.h	/^inline void mux_abo(Solver* SS, const Lit& o, const Lit& a, const Lit& b)$/;"	f
mux_b	svr/v3SvrSatHelper.h	/^inline void mux_b(Solver* SS, const Lit& o, const Lit& s, const Lit& b)$/;"	f
nAssigns	eng/minisat/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Solver
nClauses	eng/minisat/Solver.h	/^inline int      Solver::nClauses      ()      const   { return num_clauses; }$/;"	f	class:Solver
nFreeVars	eng/minisat/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Solver
nLearnts	eng/minisat/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return num_learnts; }$/;"	f	class:Solver
nVars	eng/minisat/Solver.h	/^inline int      Solver::nVars         ()      const   { return next_var; }$/;"	f	class:Solver
name	eng/minisat/Options.h	/^    const char* name;$/;"	m	class:Option
nand_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nand_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
nand_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nand_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
newDecisionLevel	eng/minisat/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Solver
newDepFFCone	stg/v3StgSDG.h	/^      inline void newDepFFCone() { assert (!_depFFCone); _depFFCone = new V3SDGBase(); assert (_depFFCone); }$/;"	f	class:V3SDGBase
newDepMuxCone	stg/v3StgSDG.h	/^      inline void newDepMuxCone() { assert (!_depMuxCone); _depMuxCone = new V3SDGBase(); assert (_depMuxCone); }$/;"	f	class:V3SDGBase
newMiscData	ntk/v3Ntk.h	/^      inline void newMiscData() { assert (_globalMisc < V3MiscType(0, V3NtkUD).misc); ++_globalMisc; }$/;"	f	class:V3Ntk
newVar	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::newVar(const uint32_t& width) {$/;"	f	class:V3SvrMiniSat
next_var	eng/minisat/Solver.h	/^    Var                 next_var;         \/\/ Next variable to be created.$/;"	m	class:Solver
nodeMove	bdd/bddNodeV.cpp	/^BddNodeV::nodeMove(unsigned fromLevel, unsigned toLevel, bool& isMoved) const$/;"	f	class:BddNodeV
nodeMoveRecur	bdd/bddNodeV.cpp	/^BddNodeV::nodeMoveRecur$/;"	f	class:BddNodeV
nor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
nor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId nor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
noticePushComplete	alg/v3AlgGeneralize.cpp	/^V3GenBucket::noticePushComplete() {$/;"	f	class:V3GenBucket
nprimes	eng/minisat/Map.h	/^static const int nprimes          = 25;$/;"	v
numBuckets	bdd/myHash.h	/^   size_t numBuckets() const { return _numBuckets; }$/;"	f	class:Hash
numBuckets	bdd/test/myHash.h	/^   size_t numBuckets() const { return _numBuckets; }$/;"	f	class:Hash
num_clauses	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
num_learnts	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
occs	eng/minisat/SolverTypes.h	/^    IntMap<K, Vec,  MkIndex> occs;$/;"	m	class:OccLists
ok	eng/minisat/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Solver
okay	eng/minisat/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Solver
ones	adt/v3BitVec.cpp	/^V3BitVec::ones() const {$/;"	f	class:V3BitVec
op_add	adt/v3BitVec.cpp	/^V3BitVecX::op_add(const char& a, const char& b, const char& c) const$/;"	f	class:V3BitVecX
op_and	adt/v3BitVec.cpp	/^V3BitVecX::op_and(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_bv_equal	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_equal(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_bv_geq	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_geq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_bv_leq	adt/v3BitVec.cpp	/^V3BitVecX::op_bv_leq(const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
op_carry	adt/v3BitVec.cpp	/^V3BitVecX::op_carry(const char& a, const char& b, const char& c) const$/;"	f	class:V3BitVecX
op_eq	adt/v3BitVec.cpp	/^V3BitVecX::op_eq(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_ge	adt/v3BitVec.cpp	/^V3BitVecX::op_ge(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_inv	adt/v3BitVec.cpp	/^V3BitVecX::op_inv(const char& a) const {$/;"	f	class:V3BitVecX
op_le	adt/v3BitVec.cpp	/^V3BitVecX::op_le(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_or	adt/v3BitVec.cpp	/^V3BitVecX::op_or(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
op_xor	adt/v3BitVec.cpp	/^V3BitVecX::op_xor(const char& a, const char& b) const {$/;"	f	class:V3BitVecX
openDofile	cmd/v3CmdMgr.h	/^      bool openDofile(const string& dof) { _dofile.open(dof.c_str()); return _dofile.is_open(); }$/;"	f	class:V3CmdMgr
operator !=	adt/v3BitVec.cpp	/^V3BitVecX::operator != (const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
operator !=	adt/v3BitVec.h	/^      inline const bool operator != (const V3BitVecS& v) const { return !(*this == v); }$/;"	f	class:V3BitVecS
operator !=	bdd/bddNodeV.h	/^   bool operator != (const BddNodeV& n) const { return (_nodeV != n._nodeV); }$/;"	f	class:BddNodeV
operator !=	bdd/myHash.h	/^      bool operator != (const iterator& i) const { return !(*this == i); }$/;"	f	class:Hash::iterator
operator !=	bdd/test/bddNodeV.h	/^   bool operator != (const BddNodeV& n) const { return (_nodeV != n._nodeV); }$/;"	f	class:BddNodeV
operator !=	bdd/test/myHash.h	/^      bool operator != (const iterator& i) const { return !(*this == i); }$/;"	f	class:Hash::iterator
operator !=	eng/minisat/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Solver::Watcher
operator !=	eng/minisat/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:lbool
operator !=	eng/minisat/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Lit
operator !=	eng/minisat/SolverTypes.h	/^    bool operator!=(const ClauseIterator& ci) const { return crefs != ci.crefs; }$/;"	f	class:ClauseIterator
operator !=	eng/minisat/SolverTypes.h	/^    bool operator!=(const TrailIterator& ti) const { return lits != ti.lits; }$/;"	f	class:TrailIterator
operator !=	ntk/v3Type.h	/^   const bool operator != (const V3NetId& i) const { return !(*this == i); }$/;"	f	struct:V3NetId
operator %=	adt/v3BitVec.cpp	/^V3BitVecX::operator %= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator &	bdd/bddNodeV.cpp	/^BddNodeV::operator & (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator &&	eng/minisat/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:lbool
operator &=	adt/v3BitVec.cpp	/^V3BitVec::operator &= (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator &=	adt/v3BitVec.cpp	/^V3BitVecX::operator &= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator &=	adt/v3BitVec.h	/^      inline V3BitVecS& operator &= (const V3BitVecS& v) { _data0 |= v._data0; _data1 &= v._data1; return *this; }$/;"	f	class:V3BitVecS
operator &=	bdd/bddNodeV.cpp	/^BddNodeV::operator &= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator ()	adt/v3Hash.h	/^   inline size_t operator() (const pair<S, T>& key) const {$/;"	f	struct:V3PairHashFcn
operator ()	adt/v3Hash.h	/^   inline size_t operator() (const pair<S, T>& key1, const pair<S, T>& key2) const {$/;"	f	struct:V3PairHashEqual
operator ()	adt/v3Misc.h	/^struct V3UI32LessOrEq { const bool operator() (const T& i, const T& j) const { return i <= j; } };$/;"	f	struct:V3UI32LessOrEq
operator ()	alg/v3AlgGeneralize.h	/^         inline const bool operator () (const V3GenVarPair& p1, const V3GenVarPair& p2) const {$/;"	f	struct:V3GenStruct::V3GenComp
operator ()	bdd/bddMgrV.h	/^   size_t operator() () const { return ((_f << 3)+(_g << 3)+(_h << 3)); }$/;"	f	class:BddCacheKeyV
operator ()	bdd/bddMgrV.h	/^   size_t operator() () const { return ((_l << 3) + (_r << 3) + _i); }$/;"	f	class:BddHashKeyV
operator ()	bdd/bddNodeV.h	/^   size_t operator () () const { return _nodeV; }$/;"	f	class:BddNodeV
operator ()	bdd/test/bddMgrV.h	/^   size_t operator() () const { return ((_f << 3)+(_g << 3)+(_h << 3)); }$/;"	f	class:BddCacheKeyV
operator ()	bdd/test/bddMgrV.h	/^   size_t operator() () const { return ((_l << 3) + (_r << 3) + _i); }$/;"	f	class:BddHashKeyV
operator ()	bdd/test/bddNodeV.h	/^   size_t operator () () const { return _nodeV; }$/;"	f	class:BddNodeV
operator ()	cmd/v3CmdMgr.h	/^struct V3CmdCompare { bool operator() (const V3CmdExec* a, const V3CmdExec* b) const { return (*a < *b); } };$/;"	f	struct:V3CmdCompare
operator ()	dfx/v3DfxTrace.h	/^   const bool operator() (const V3DfxCube* const s1, const V3DfxCube* const s2) const {$/;"	f	struct:V3DfxCubeCompare
operator ()	eng/minisat/IntMap.h	/^        typename vec<T>::Size operator()(T t) const { return (typename vec<T>::Size)t; }$/;"	f	struct:MkIndexDefault
operator ()	eng/minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:DeepEqual
operator ()	eng/minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:DeepHash
operator ()	eng/minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Equal
operator ()	eng/minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Hash
operator ()	eng/minisat/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Option::OptionLt
operator ()	eng/minisat/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Solver::VarOrderLt
operator ()	eng/minisat/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Solver::WatcherDeleted
operator ()	eng/minisat/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:CMap::CRefHash
operator ()	eng/minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	f	struct:MkIndexLit
operator ()	eng/minisat/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	util/v3Msg.h	/^      V3Msg& operator () (const V3MsgType type) {$/;"	f	class:V3MsgMgr
operator ()	vrf/v3VrfCITP.h	/^   const bool operator() (const V3CITPCube* const c1, const V3CITPCube* const c2) const {$/;"	f	struct:V3CITPCubeCompare
operator ()	vrf/v3VrfFITP.h	/^   const bool operator() (const V3FITPCube* const c1, const V3FITPCube* const c2) const {$/;"	f	struct:V3FITPCubeCompare
operator ()	vrf/v3VrfIPDR.h	/^   const bool operator() (const V3IPDRCube* const c1, const V3IPDRCube* const c2) const {$/;"	f	struct:V3IPDRCubeCompare
operator ()	vrf/v3VrfMPDR.h	/^   const bool operator() (const V3MPDRCube* const c1, const V3MPDRCube* const c2) const {$/;"	f	struct:V3MPDRCubeCompare
operator *	bdd/myHash.h	/^      HashNode& operator * () { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *	bdd/myHash.h	/^      const HashNode& operator * () const { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *	bdd/test/myHash.h	/^      HashNode& operator * () { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *	bdd/test/myHash.h	/^      const HashNode& operator * () const { return (*_hash)[_bId][_bnId]; }$/;"	f	class:Hash::iterator
operator *	eng/minisat/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:StreamBuffer
operator *	eng/minisat/SolverTypes.h	/^    Lit  operator*() const { return *lits; }$/;"	f	class:TrailIterator
operator *	eng/minisat/SolverTypes.h	/^    const Clause& operator*() const { return ca[*crefs]; }$/;"	f	class:ClauseIterator
operator *=	adt/v3BitVec.cpp	/^V3BitVecX::operator *= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator ++	bdd/myHash.h	/^      iterator operator ++ (int) { iterator li=(*this); ++(*this); return li; }$/;"	f	class:Hash::iterator
operator ++	bdd/myHash.h	/^      iterator& operator ++ () {$/;"	f	class:Hash::iterator
operator ++	bdd/test/myHash.h	/^      iterator operator ++ (int) { iterator li=(*this); ++(*this); return li; }$/;"	f	class:Hash::iterator
operator ++	bdd/test/myHash.h	/^      iterator& operator ++ () {$/;"	f	class:Hash::iterator
operator ++	eng/minisat/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:StreamBuffer
operator ++	eng/minisat/SolverTypes.h	/^    void operator++()   { lits++; }$/;"	f	class:TrailIterator
operator ++	eng/minisat/SolverTypes.h	/^    void operator++(){ crefs++; }$/;"	f	class:ClauseIterator
operator +=	adt/v3BitVec.cpp	/^V3BitVecX::operator += (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator --	bdd/myHash.h	/^      iterator operator -- (int) { iterator li=(*this); --(*this); return li; }$/;"	f	class:Hash::iterator
operator --	bdd/myHash.h	/^      iterator& operator -- () {$/;"	f	class:Hash::iterator
operator --	bdd/test/myHash.h	/^      iterator operator -- (int) { iterator li=(*this); --(*this); return li; }$/;"	f	class:Hash::iterator
operator --	bdd/test/myHash.h	/^      iterator& operator -- () {$/;"	f	class:Hash::iterator
operator -=	adt/v3BitVec.cpp	/^V3BitVecX::operator -= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator /=	adt/v3BitVec.cpp	/^V3BitVecX::operator \/= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator <	bdd/bddNodeV.cpp	/^BddNodeV::operator < (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator <	cmd/v3CmdMgr.cpp	/^V3CmdExec::operator < (const V3CmdExec& rhs) const {$/;"	f	class:V3CmdExec
operator <	eng/minisat/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Lit
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVec& b) {$/;"	f
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVecS& v) {$/;"	f
operator <<	adt/v3BitVec.cpp	/^ostream& operator << (ostream& os, const V3BitVecX& b) {$/;"	f
operator <<	bdd/bddNodeV.cpp	/^operator << (ostream& os, const BddNodeV& n)$/;"	f
operator <<	util/v3Msg.h	/^      friend V3Msg& operator << (V3Msg& m, StdEndLine e) {$/;"	f	class:V3Msg
operator <<	util/v3Msg.h	/^      template<class T> friend V3Msg& operator << (V3Msg& m, const T& s) {$/;"	f	class:V3Msg
operator <<	util/v3Usage.h	/^      friend ostream& operator << (ostream& os, const V3Stat& stat) {$/;"	f	class:V3Stat
operator <<=	adt/v3BitVec.cpp	/^V3BitVecX::operator <<= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator <=	bdd/bddNodeV.cpp	/^BddNodeV::operator <= (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator =	adt/v3BitVec.cpp	/^V3BitVec::operator = (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator =	adt/v3BitVec.cpp	/^V3BitVecX::operator = (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator =	adt/v3Misc.h	/^      V3PortableType& operator = (const V3PortableType& t) {$/;"	f	class:V3PortableType
operator =	bdd/bddNodeV.cpp	/^BddNodeV::operator = (const BddNodeV& n)$/;"	f	class:BddNodeV
operator =	bdd/myHash.h	/^      iterator& operator = (const iterator& i) {$/;"	f	class:Hash::iterator
operator =	bdd/test/myHash.h	/^      iterator& operator = (const iterator& i) {$/;"	f	class:Hash::iterator
operator =	eng/minisat/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:BoolOption
operator =	eng/minisat/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:DoubleOption
operator =	eng/minisat/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Int64Option
operator =	eng/minisat/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:IntOption
operator =	eng/minisat/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:StringOption
operator ==	adt/v3BitVec.cpp	/^V3BitVec::operator == (const V3BitVec& b) const {$/;"	f	class:V3BitVec
operator ==	adt/v3BitVec.cpp	/^V3BitVecX::operator == (const V3BitVecX& b) const {$/;"	f	class:V3BitVecX
operator ==	adt/v3BitVec.h	/^      inline const bool operator == (const V3BitVecS& v) const { return (_data0 == v._data0) && (_data1 == v._data1); }$/;"	f	class:V3BitVecS
operator ==	bdd/bddMgrV.h	/^   bool operator == (const BddCacheKeyV& k) const {$/;"	f	class:BddCacheKeyV
operator ==	bdd/bddMgrV.h	/^   bool operator == (const BddHashKeyV& k) {$/;"	f	class:BddHashKeyV
operator ==	bdd/bddNodeV.h	/^   bool operator == (const BddNodeV& n) const { return (_nodeV == n._nodeV); }$/;"	f	class:BddNodeV
operator ==	bdd/myHash.h	/^      bool operator == (const iterator& i) const {$/;"	f	class:Hash::iterator
operator ==	bdd/test/bddMgrV.h	/^   bool operator == (const BddCacheKeyV& k) const {$/;"	f	class:BddCacheKeyV
operator ==	bdd/test/bddMgrV.h	/^   bool operator == (const BddHashKeyV& k) {$/;"	f	class:BddHashKeyV
operator ==	bdd/test/bddNodeV.h	/^   bool operator == (const BddNodeV& n) const { return (_nodeV == n._nodeV); }$/;"	f	class:BddNodeV
operator ==	bdd/test/myHash.h	/^      bool operator == (const iterator& i) const {$/;"	f	class:Hash::iterator
operator ==	eng/minisat/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Solver::Watcher
operator ==	eng/minisat/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:lbool
operator ==	eng/minisat/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Lit
operator ==	eng/minisat/SolverTypes.h	/^    bool operator==(const ClauseIterator& ci) const { return crefs == ci.crefs; }$/;"	f	class:ClauseIterator
operator ==	eng/minisat/SolverTypes.h	/^    bool operator==(const TrailIterator& ti) const { return lits == ti.lits; }$/;"	f	class:TrailIterator
operator ==	ntk/v3Type.h	/^   const bool operator == (const V3NetId& i) const { return cp == i.cp && id == i.id; }$/;"	f	struct:V3NetId
operator >	bdd/bddNodeV.h	/^   bool operator > (const BddNodeV& n) const { return !((*this) <= n); }$/;"	f	class:BddNodeV
operator >	bdd/test/bddNodeV.h	/^   bool operator > (const BddNodeV& n) const { return !((*this) <= n); }$/;"	f	class:BddNodeV
operator >=	bdd/bddNodeV.h	/^   bool operator >= (const BddNodeV& n) const { return !((*this) < n); }$/;"	f	class:BddNodeV
operator >=	bdd/test/bddNodeV.h	/^   bool operator >= (const BddNodeV& n) const { return !((*this) < n); }$/;"	f	class:BddNodeV
operator >>=	adt/v3BitVec.cpp	/^V3BitVecX::operator >>= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator T*	eng/minisat/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:vec
operator []	adt/v3BitVec.cpp	/^V3BitVec::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVec
operator []	adt/v3BitVec.cpp	/^V3BitVecS::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVecS
operator []	adt/v3BitVec.cpp	/^V3BitVecX::operator[] (const unsigned& i) const {$/;"	f	class:V3BitVecX
operator []	bdd/myHash.h	/^   CacheNode& operator [] (size_t i) { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/myHash.h	/^   const CacheNode& operator [](size_t i) const { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/myHash.h	/^   const vector<HashNode>& operator [](size_t i) const { return _buckets[i]; }$/;"	f	class:Hash
operator []	bdd/myHash.h	/^   vector<HashNode>& operator [] (size_t i) { return _buckets[i]; }$/;"	f	class:Hash
operator []	bdd/test/myHash.h	/^   CacheNode& operator [] (size_t i) { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/test/myHash.h	/^   const CacheNode& operator [](size_t i) const { return _cache[i]; }$/;"	f	class:Cache
operator []	bdd/test/myHash.h	/^   const vector<HashNode>& operator [](size_t i) const { return _buckets[i]; }$/;"	f	class:Hash
operator []	bdd/test/myHash.h	/^   vector<HashNode>& operator [] (size_t i) { return _buckets[i]; }$/;"	f	class:Hash
operator []	eng/minisat/Alloc.h	/^    T&       operator[](Ref r)       { assert(r < sz); return memory[r]; }$/;"	f	class:RegionAllocator
operator []	eng/minisat/Alloc.h	/^    const T& operator[](Ref r) const { assert(r < sz); return memory[r]; }$/;"	f	class:RegionAllocator
operator []	eng/minisat/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Heap
operator []	eng/minisat/IntMap.h	/^        K        operator [] (int index) const  { return xs[index]; }$/;"	f	class:IntSet
operator []	eng/minisat/IntMap.h	/^        V&       operator[](K k)       { assert(has(k)); return map[index(k)]; }$/;"	f	class:IntMap
operator []	eng/minisat/IntMap.h	/^        const V& operator[](K k) const { assert(has(k)); return map[index(k)]; }$/;"	f	class:IntMap
operator []	eng/minisat/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Map
operator []	eng/minisat/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Map
operator []	eng/minisat/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Queue
operator []	eng/minisat/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Queue
operator []	eng/minisat/SolverTypes.h	/^    Clause&       operator[](CRef r)         { return (Clause&)ra[r]; }$/;"	f	class:ClauseAllocator
operator []	eng/minisat/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Clause
operator []	eng/minisat/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Clause
operator []	eng/minisat/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:CMap
operator []	eng/minisat/SolverTypes.h	/^    Vec&  operator[](const K& idx){ return occs[idx]; }$/;"	f	class:OccLists
operator []	eng/minisat/SolverTypes.h	/^    const Clause& operator[](CRef r) const   { return (Clause&)ra[r]; }$/;"	f	class:ClauseAllocator
operator []	eng/minisat/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:CMap
operator []	eng/minisat/Vec.h	/^    T&       operator [] (Size index)       { return data[index]; }$/;"	f	class:vec
operator []	eng/minisat/Vec.h	/^    const T& operator [] (Size index) const { return data[index]; }$/;"	f	class:vec
operator ^	bdd/bddNodeV.cpp	/^BddNodeV::operator ^ (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator ^	eng/minisat/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:lbool
operator ^	eng/minisat/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f
operator ^=	adt/v3BitVec.cpp	/^V3BitVecS::operator ^= (const V3BitVecS& v) {$/;"	f	class:V3BitVecS
operator ^=	adt/v3BitVec.cpp	/^V3BitVecX::operator ^= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator ^=	bdd/bddNodeV.cpp	/^BddNodeV::operator ^= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator bool	eng/minisat/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:BoolOption
operator bool&	eng/minisat/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:BoolOption
operator const Lit*	eng/minisat/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Clause
operator const char*	eng/minisat/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:StringOption
operator const char*&	eng/minisat/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:StringOption
operator double	eng/minisat/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:DoubleOption
operator double&	eng/minisat/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:DoubleOption
operator int32_t	eng/minisat/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:IntOption
operator int32_t&	eng/minisat/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:IntOption
operator int64_t	eng/minisat/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Int64Option
operator int64_t&	eng/minisat/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Int64Option
operator |	bdd/bddNodeV.cpp	/^BddNodeV::operator | (const BddNodeV& n) const$/;"	f	class:BddNodeV
operator |=	adt/v3BitVec.cpp	/^V3BitVec::operator |= (const V3BitVec& b) {$/;"	f	class:V3BitVec
operator |=	adt/v3BitVec.cpp	/^V3BitVecX::operator |= (const V3BitVecX& b) {$/;"	f	class:V3BitVecX
operator |=	bdd/bddNodeV.cpp	/^BddNodeV::operator |= (const BddNodeV& n)$/;"	f	class:BddNodeV
operator ||	eng/minisat/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:lbool
operator ~	adt/v3BitVec.cpp	/^V3BitVecX::operator ~ () const {$/;"	f	class:V3BitVecX
operator ~	adt/v3BitVec.h	/^      inline const V3BitVecS operator ~ () const { const V3BitVecS v(_data1, _data0); return v; }$/;"	f	class:V3BitVecS
operator ~	bdd/bddNodeV.h	/^   BddNodeV operator ~ () const { return (_nodeV ^ BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
operator ~	bdd/test/bddNodeV.h	/^   BddNodeV operator ~ () const { return (_nodeV ^ BDD_NEG_EDGEV); }$/;"	f	class:BddNodeV
operator ~	eng/minisat/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
operator ~	ntk/v3Type.h	/^   V3NetId operator ~ () const { return makeNetId(id, cp ^ 1); }$/;"	f	struct:V3NetId
or_2	svr/v3SvrSatHelper.h	/^inline void or_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
or_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId or_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
or_red	svr/v3SvrSatHelper.h	/^inline void or_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
or_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId or_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
order_heap	eng/minisat/Solver.h	/^    Heap<Var,VarOrderLt>order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Solver
pair	ntk/v3Type.h	/^      uint64_t    pair;$/;"	m	union:V3PairType::__anon7
parent	eng/minisat/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Heap
parse	eng/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:BoolOption
parse	eng/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:DoubleOption
parse	eng/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Int64Option
parse	eng/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:IntOption
parse	eng/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:StringOption
parseCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::parseCmd(string& option) {$/;"	f	class:V3CmdMgr
parseInt	eng/minisat/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f
parse_DIMACS	eng/minisat/Dimacs.h	/^static void parse_DIMACS(gzFile input_stream, Solver& S, bool strictp = false) {$/;"	f
parse_DIMACS_main	eng/minisat/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S, bool strictp = false) {$/;"	f
peek	eng/minisat/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Map
peek	eng/minisat/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Queue
percolateDown	eng/minisat/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Heap
percolateUp	eng/minisat/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Heap
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgAigGeneralize
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgBvGeneralize
performFixForControlVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performFixForControlVars(const bool& parallelSim) {$/;"	f	class:V3AlgGeneralize
performImplicationForTargetUpdate	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performImplicationForTargetUpdate(V3NetVec& newSource) {$/;"	f	class:V3AlgAigGeneralize
performImplicationForTargetUpdate	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performImplicationForTargetUpdate(const V3NetId& id, V3NetVec& newSource, V3BoolVec& updated) {$/;"	f	class:V3AlgAigGeneralize
performInputFileSimulation	alg/v3AlgSim.cpp	/^const bool performInputFileSimulation(const V3NtkHandler* const handler, const string& fileName, $/;"	f
performNtkTransformation	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::performNtkTransformation() {$/;"	f	class:V3BvBlastAig
performNtkTransformation	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::performNtkTransformation() {$/;"	f	class:V3BvBlastBv
performNtkTransformation	trans/v3NtkExpand.cpp	/^V3NtkExpand::performNtkTransformation(const bool& init) {$/;"	f	class:V3NtkExpand
performNtkTransformation	trans/v3NtkMiter.cpp	/^V3NtkMiter::performNtkTransformation(V3NtkHandler* const handler1, V3NtkHandler* const handler2, const bool& merge) {$/;"	f	class:V3NtkMiter
performRandomSimulation	alg/v3AlgSim.cpp	/^const bool performRandomSimulation(const V3NtkHandler* const handler, const uint32_t& patternCount, $/;"	f
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgAigGeneralize
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgBvGeneralize
performSetXForNotCOIVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performSetXForNotCOIVars() {$/;"	f	class:V3AlgGeneralize
performSimulationForFrozenPropagation	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performSimulationForFrozenPropagation(const V3NetVec& newSource) {$/;"	f	class:V3AlgAigGeneralize
performTraceGeneralization	dfx/v3DfxTrace.cpp	/^void performTraceGeneralization(V3NtkHandler* const handler, V3Property* const p) {$/;"	f
performTraceReduction	dfx/v3DfxTrace.cpp	/^void performTraceReduction(V3NtkHandler* const handler, V3Property* const p) {$/;"	f
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgAigGeneralize
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgBvGeneralize
performXPropForExtensibleVars	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performXPropForExtensibleVars(const V3UI32Vec& generalizeOrder) {$/;"	f	class:V3AlgGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgAigGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgBvGeneralize
performXPropForMinimizeTransitions	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::performXPropForMinimizeTransitions(const uint32_t& frameSize, const V3NetVec& targetValue) {$/;"	f	class:V3AlgGeneralize
phase_saving	eng/minisat/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Solver
plotNetFanin	io/v3NtkWriter.cpp	/^void plotNetFanin(ofstream& os, V3Ntk* const ntk, const uint32_t& id, const unsigned& depth) {$/;"	f
polarity	eng/minisat/Solver.h	/^    VMap<char>          polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Solver
pop	adt/v3Bucket.h	/^V3BucketList<T>::pop(uint32_t& index, T& t) {$/;"	f	class:V3BucketList
pop	adt/v3Bucket.h	/^V3IncBucketList<T>::pop(uint32_t& index, T& t) {$/;"	f	class:V3IncBucketList
pop	alg/v3AlgGeneralize.cpp	/^V3GenBucket::pop(uint32_t& data) {$/;"	f	class:V3GenBucket
pop	eng/minisat/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Queue
pop	eng/minisat/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Clause
pop	eng/minisat/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:vec
pos	eng/minisat/ParseUtils.h	/^    int            pos;$/;"	m	class:StreamBuffer
position	eng/minisat/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:StreamBuffer
primes	eng/minisat/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	v
print	bdd/bddNodeV.cpp	/^BddNodeV::print(ostream& os, size_t indent, size_t& nNodes) const$/;"	f	class:BddNodeV
print	stg/v3StgSDG.cpp	/^V3SDGBase::print() const {$/;"	f	class:V3SDGBase
printCandidate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::printCandidate(const uint32_t& x) const {$/;"	f	class:V3VrfSEC
printCombLoops	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printCombLoops() const {$/;"	f	class:V3NtkHandler
printConfl	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printConfl(const V3UI32Set& cube) const {$/;"	f	class:V3GenStruct
printCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printCube(const V3NetVec& cube) const {$/;"	f	class:V3GenStruct
printCube2Var	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printCube2Var() const {$/;"	f	class:V3GenStruct
printFaninRec	ntk/v3Ntk.cpp	/^void V3Ntk::printFaninRec(V3NtkHandler* const handler, const V3NetId& netId, const int& depth, const int& level) {$/;"	f	class:V3Ntk
printFloatings	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printFloatings() const {$/;"	f	class:V3NtkHandler
printHelps	cmd/v3CmdMgr.cpp	/^V3CmdMgr::printHelps(bool revealed) const {$/;"	f	class:V3CmdMgr
printHistory	cmd/v3CmdMgr.cpp	/^V3CmdMgr::printHistory(int nPrint) const {$/;"	f	class:V3CmdMgr
printInfo	svr/v3SvrBase.cpp	/^V3SvrBase::printInfo() const {$/;"	f	class:V3SvrBase
printInfo	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::printInfo() const {$/;"	f	class:V3SvrBoolector
printInfo	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::printInfo() const {$/;"	f	class:V3SvrMiniSat
printLock	vrf/v3VrfShared.h	/^      static inline void printLock() { pthread_mutex_lock(&_printMutex); }$/;"	f	class:V3VrfShared
printNet	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printNet(const V3NetId& id) const {$/;"	f	class:V3NtkHandler
printNetlist	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printNetlist() const {$/;"	f	class:V3NtkHandler
printNtkInAncestry	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkInAncestry() const {$/;"	f	class:V3Handler
printNtkInHierarchy	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkInHierarchy() const {$/;"	f	class:V3Handler
printNtkRelation	ntk/v3NtkHandler.cpp	/^V3Handler::printNtkRelation(const string& fileName) const {$/;"	f	class:V3Handler
printPrimary	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printPrimary() const {$/;"	f	class:V3NtkHandler
printRecurHierarchy	ntk/v3NtkHandler.cpp	/^V3Handler::printRecurHierarchy(V3NtkHandler* const handler, const uint32_t& maxLevel, const uint32_t& level) const {$/;"	f	class:V3Handler
printReportSettings	vrf/v3VrfBase.cpp	/^V3VrfBase::printReportSettings() {$/;"	f	class:V3VrfBase
printResult	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::printResult() const {$/;"	f	class:V3AlgAigSimulate
printResult	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::printResult() const {$/;"	f	class:V3AlgBvSimulate
printResult	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::printResult() const { }$/;"	f	class:V3AlgSimulate
printSolverSettings	vrf/v3VrfBase.cpp	/^V3VrfBase::printSolverSettings() {$/;"	f	class:V3VrfBase
printState	vrf/v3VrfCITP.cpp	/^V3VrfCITP::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfCITP
printState	vrf/v3VrfFITP.cpp	/^V3VrfFITP::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfFITP
printState	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfIPDR
printState	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::printState(const V3NetVec& state) const {$/;"	f	class:V3VrfMPDR
printSummary	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printSummary() const {$/;"	f	class:V3NtkHandler
printTraceInfo	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::printTraceInfo() const {$/;"	f	class:V3TraceSimplify
printUnlock	vrf/v3VrfShared.h	/^      static inline void printUnlock() { pthread_mutex_unlock(&_printMutex); }$/;"	f	class:V3VrfShared
printUnreachables	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printUnreachables() const {$/;"	f	class:V3NtkHandler
printVar2Cube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::printVar2Cube() const {$/;"	f	class:V3GenStruct
printVerbose	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printVerbose() const {$/;"	f	class:V3NtkHandler
printVerbose	svr/v3SvrBase.cpp	/^V3SvrBase::printVerbose() const {$/;"	f	class:V3SvrBase
printVerbose	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::printVerbose() const {$/;"	f	class:V3SvrMiniSat
printVerbositySettings	ntk/v3NtkHandler.cpp	/^V3NtkHandler::printVerbositySettings() {$/;"	f	class:V3NtkHandler
profileON	vrf/v3VrfBase.h	/^      static inline const bool profileON() { return reportON() &&  (32ul & _extVerbosity); }$/;"	f	class:V3VrfBase
progress_estimate	eng/minisat/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Solver
propagateCubes	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::propagateCubes() {$/;"	f	class:V3VrfIPDR
propagateCubes	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::propagateCubes() {$/;"	f	class:V3VrfMPDR
propagation_budget	eng/minisat/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Solver
propagations	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
push	alg/v3AlgGeneralize.cpp	/^V3GenBucket::push(const uint32_t& data, const uint32_t& bucketIndex) {$/;"	f	class:V3GenBucket
push	eng/minisat/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); new (&data[sz++]) T(elem); }$/;"	f	class:vec
push	eng/minisat/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:vec
pushAndSetCurHandler	ntk/v3NtkHandler.cpp	/^V3Handler::pushAndSetCurHandler(V3NtkHandler* const handler) {$/;"	f	class:V3Handler
pushCube	alg/v3AlgGeneralize.cpp	/^V3GenStruct::pushCube(const V3NetVec& cube, const bool& invert) {$/;"	f	class:V3GenStruct
pushCube	vrf/v3VrfCITP.cpp	/^V3CITPFrame::pushCube(V3CITPCube* const c) {$/;"	f	class:V3CITPFrame
pushCube	vrf/v3VrfFITP.cpp	/^V3FITPFrame::pushCube(V3FITPCube* const c) {$/;"	f	class:V3FITPFrame
pushCube	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::pushCube(V3IPDRCube* const c) {$/;"	f	class:V3IPDRFrame
pushCube	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::pushCube(V3MPDRCube* const c) {$/;"	f	class:V3MPDRFrame
pushData	ext/v3Property.h	/^      inline void pushData(const V3BitVecX& v) { _data.push_back(v); }$/;"	f	class:V3CexTrace
pushInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::pushInv(V3SvrBase* const solver, V3Ntk* const ntk, const uint32_t& depth) {$/;"	f	class:V3VrfSharedInv
pushNtk	ntk/v3NtkHandler.h	/^      inline void pushNtk(V3NtkHandler* const n, const uint32_t& p) { _hierInfo.push_back(new V3NtkHierData(n, p)); }$/;"	f	class:V3NtkHierInfo
pushRefId	ntk/v3NtkHandler.h	/^      inline void pushRefId(const uint32_t& id, const uint32_t& i) { _refIdMap.push_back(V3PairType(id, i)); }$/;"	f	class:V3NtkHierInfo
pushStateIntoSolver	stg/v3StgFSM.cpp	/^V3FSM::pushStateIntoSolver(V3SvrBase* const solver, const uint32_t& state, const uint32_t& depth) const {$/;"	f	class:V3FSM
pushTerminalState	stg/v3StgExtract.h	/^      inline void pushTerminalState(const V3NetId& id) { _terminals.push_back(id); }$/;"	f	class:V3FSMExtract
push_	eng/minisat/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:vec
qhead	eng/minisat/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Solver
quteRTL_MsgFile	io/v3NtkQuteRTL.cpp	/^const string quteRTL_MsgFile = "quteRTL.log";  \/\/ QuteRTL Log File$/;"	v
ra	eng/minisat/SolverTypes.h	/^    RegionAllocator<uint32_t> ra;$/;"	m	class:ClauseAllocator
random	adt/v3BitVec.cpp	/^V3BitVec::random() {$/;"	f	class:V3BitVec
random	adt/v3BitVec.cpp	/^V3BitVecX::random() {$/;"	f	class:V3BitVecX
random	adt/v3BitVec.h	/^      inline void random() { _data0 = rand(); _data1 = ~_data0; }$/;"	f	class:V3BitVecS
randomGetInitialState	stg/v3StgFSM.cpp	/^V3FSM::randomGetInitialState() {$/;"	f	class:V3FSM
randomShuffle	eng/minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<T>& xs)$/;"	f
randomShuffle	eng/minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<vec<T> >& xs)$/;"	f
randomSimulate	vrf/v3VrfSEC.cpp	/^V3VrfSEC::randomSimulate(const uint32_t& p, const uint32_t& cycle, const bool& initValid) {$/;"	f	class:V3VrfSEC
randomSimulateOneCycle	stg/v3StgFSM.cpp	/^V3FSM::randomSimulateOneCycle() {$/;"	f	class:V3FSM
random_seed	eng/minisat/Solver.h	/^    double    random_seed;$/;"	m	class:Solver
random_var_freq	eng/minisat/Solver.h	/^    double    random_var_freq;$/;"	m	class:Solver
range	eng/minisat/Options.h	/^    DoubleRange range;$/;"	m	class:DoubleOption
range	eng/minisat/Options.h	/^    Int64Range range;$/;"	m	class:Int64Option
range	eng/minisat/Options.h	/^    IntRange range;$/;"	m	class:IntOption
read	bdd/myHash.h	/^   bool read(const CacheKey& k, CacheData& d) const {$/;"	f	class:Cache
read	bdd/test/myHash.h	/^   bool read(const CacheKey& k, CacheData& d) const {$/;"	f	class:Cache
readAiger	v3mc/v3MCAiger.cpp	/^V3NtkInput* readAiger(const string& fileName, V3NetVec& badList, V3NetVec& invList, V3NetTable& fairList, const bool& hwmcc) {$/;"	f
readClause	eng/minisat/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f
readProperty	v3mc/v3MCProp.cpp	/^V3NtkHandler* const readProperty(V3NtkHandler* const handler, const string& fileName) {$/;"	f
readRTLModule	io/v3RTLParser.cpp	/^bool readRTLModule(ifstream& input, V3StrSet& ioNames, V3NtkInput* const handler) {$/;"	f
readRTLModuleHeader	io/v3RTLParser.cpp	/^bool readRTLModuleHeader(ifstream& input, string& moduleName, V3StrSet& ioNames) {$/;"	f
reallocNumOfCores	v3mc/v3MCMain.cpp	/^V3MCResource::reallocNumOfCores() {$/;"	f	class:V3MCResource
reason	eng/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Solver::VarData
reason	eng/minisat/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Solver
recordCubeInputForTraceLog	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recordCubeInputForTraceLog(V3IPDRCube* const& cube) {$/;"	f	class:V3VrfIPDR
recordCubeInputForTraceLog	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recordCubeInputForTraceLog(V3MPDRCube* const& cube) {$/;"	f	class:V3VrfMPDR
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::recordSimValue() {$/;"	f	class:V3AlgAigSimulate
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::recordSimValue() {$/;"	f	class:V3AlgBvSimulate
recordSimValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::recordSimValue() {}$/;"	f	class:V3AlgSimulate
recordSimulationValue	stg/v3StgFSM.cpp	/^V3FSM::recordSimulationValue(V3SimTrace& trace) const {$/;"	f	class:V3FSM
recordSolverValue	stg/v3StgFSM.cpp	/^V3FSM::recordSolverValue(V3SimTrace& trace, const uint32_t& depth) const {$/;"	f	class:V3FSM
recordSolverXValue	stg/v3StgFSM.cpp	/^V3FSM::recordSolverXValue(V3SimTrace& trace, const uint32_t& depth) const {$/;"	f	class:V3FSM
recoverForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::recoverForGeneralization() {$/;"	f	class:V3AlgAigGeneralize
recoverForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::recoverForGeneralization() {$/;"	f	class:V3AlgBvGeneralize
recurTraverseNtk	io/v3NtkWriter.cpp	/^void recurTraverseNtk(V3Ntk* const ntk, const uint32_t& id, const uint32_t& pId, unsigned& depth, V3Graph<uint32_t>& G) {$/;"	f
recursiveBlockCube	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recursiveBlockCube(V3IPDRCube* const badCube) {$/;"	f	class:V3VrfIPDR
recursiveBlockCube	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recursiveBlockCube(V3MPDRCube* const badCube) {$/;"	f	class:V3VrfMPDR
recycleSolver	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::recycleSolver(const uint32_t& d) {$/;"	f	class:V3VrfIPDR
recycleSolver	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::recycleSolver() {$/;"	f	class:V3VrfMPDR
reduceON	ntk/v3NtkHandler.h	/^      static inline const bool reduceON()  { return _extVerbosity & 1ul;  }$/;"	f	class:V3NtkHandler
referenceSolver	svr/v3SvrHandler.cpp	/^V3SvrBase* const referenceSolver(V3SvrBase* const solver) {$/;"	f
regCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::regCmd(const string& cmd, unsigned nCmp, V3CmdExec* e) {$/;"	f	class:V3CmdMgr
regCmd	cmd/v3CmdMgr.cpp	/^V3CmdMgr::regCmd(const string& cmd, unsigned nCmp1, unsigned nCmp2, V3CmdExec* e) {$/;"	f	class:V3CmdMgr
regEx	adt/v3BitVec.cpp	/^V3BitVec::regEx() const {$/;"	f	class:V3BitVec
regEx	adt/v3BitVec.cpp	/^V3BitVecX::regEx() const {$/;"	f	class:V3BitVecX
rehash	eng/minisat/Map.h	/^    void    rehash () {$/;"	f	class:Map
rel	eng/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Clause::__anon2
releaseNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::releaseNtk(V3NtkHandler* const handler) {$/;"	f	class:V3VrfSharedNtk
released_vars	eng/minisat/Solver.h	/^    vec<Var>            released_vars;$/;"	m	class:Solver
reloc	eng/minisat/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:ClauseAllocator
relocate	eng/minisat/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Clause
relocation	eng/minisat/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Clause
reloced	eng/minisat/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Clause::__anon1
reloced	eng/minisat/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Clause
remove	eng/minisat/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f
remove	eng/minisat/Heap.h	/^    void remove(K k)$/;"	f	class:Heap
remove	eng/minisat/Map.h	/^    void remove(const K& k) {$/;"	f	class:Map
remove	eng/minisat/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:CMap
removeConnection	adt/v3Graph.h	/^V3Graph<T>::removeConnection(const uint32_t& f, const uint32_t& t) {$/;"	f	class:V3Graph
removeECPairOutOfCOI	vrf/v3VrfSEC.cpp	/^V3VrfSEC::removeECPairOutOfCOI() {$/;"	f	class:V3VrfSEC
removeFromProof	vrf/v3VrfCITP.cpp	/^V3VrfCITP::removeFromProof(V3CITPCube* const cube) {$/;"	f	class:V3VrfCITP
removeFromProof	vrf/v3VrfFITP.cpp	/^V3VrfFITP::removeFromProof(V3FITPCube* const cube) {$/;"	f	class:V3VrfFITP
removeFromProof	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::removeFromProof(V3IPDRTimedCube& timedCube) {$/;"	f	class:V3VrfIPDR
removeFromProof	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::removeFromProof(V3MPDRTimedCube& timedCube, const bool& pushForward) {$/;"	f	class:V3VrfMPDR
removeLastInout	ntk/v3Ntk.h	/^      inline void removeLastInout() { _IOList[2].pop_back(); }$/;"	f	class:V3Ntk
removeLastInput	ntk/v3Ntk.h	/^      inline void removeLastInput() { _IOList[0].pop_back(); }$/;"	f	class:V3Ntk
removeLastLatch	ntk/v3Ntk.h	/^      inline void removeLastLatch() { _FFList.pop_back(); }$/;"	f	class:V3Ntk
removeLastOutput	ntk/v3Ntk.h	/^      inline void removeLastOutput() { _IOList[1].pop_back(); }$/;"	f	class:V3Ntk
removeMin	eng/minisat/Heap.h	/^    K removeMin()$/;"	f	class:Heap
removePrefixNetName	ntk/v3NtkInput.cpp	/^V3NtkInput::removePrefixNetName(V3Str2BoolFuncPtr toRemove) {$/;"	f	class:V3NtkInput
removeSelfSubsumed	vrf/v3VrfCITP.cpp	/^V3CITPFrame::removeSelfSubsumed() {$/;"	f	class:V3CITPFrame
removeSelfSubsumed	vrf/v3VrfFITP.cpp	/^V3FITPFrame::removeSelfSubsumed() {$/;"	f	class:V3FITPFrame
removeSelfSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSelfSubsumed() {$/;"	f	class:V3IPDRFrame
removeSelfSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSelfSubsumed() {$/;"	f	class:V3MPDRFrame
removeSubsumed	vrf/v3VrfCITP.cpp	/^V3CITPFrame::removeSubsumed(const V3CITPCube* const cube, const V3CITPCubeList::const_iterator& ix) {$/;"	f	class:V3CITPFrame
removeSubsumed	vrf/v3VrfFITP.cpp	/^V3FITPFrame::removeSubsumed(const V3FITPCube* const cube, const V3FITPCubeList::const_iterator& ix) {$/;"	f	class:V3FITPFrame
removeSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSubsumed(const V3IPDRCube* const cube) {$/;"	f	class:V3IPDRFrame
removeSubsumed	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::removeSubsumed(const V3IPDRCube* const cube, const V3IPDRCubeList::const_iterator& ix) {$/;"	f	class:V3IPDRFrame
removeSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSubsumed(const V3MPDRCube* const cube) {$/;"	f	class:V3MPDRFrame
removeSubsumed	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::removeSubsumed(const V3MPDRCube* const cube, const V3MPDRCubeList::const_iterator& ix) {$/;"	f	class:V3MPDRFrame
remove_satisfied	eng/minisat/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Solver
renderConnection	adt/v3Graph.h	/^V3Graph<T>::renderConnection(const uint32_t& f, const uint32_t& t) {$/;"	f	class:V3Graph
renderFreeNetAsInput	ntk/v3NtkInput.cpp	/^V3NtkInput::renderFreeNetAsInput() {$/;"	f	class:V3NtkInput
reorderPropertyByCOI	v3mc/v3MCReorder.cpp	/^void reorderPropertyByCOI(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
reorderPropertyByNetId	v3mc/v3MCReorder.cpp	/^void reorderPropertyByNetId(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
reorderPropertyByNetLevel	v3mc/v3MCReorder.cpp	/^void reorderPropertyByNetLevel(V3NtkHandler* const handler, V3NetTable& constr, const bool& live) {$/;"	f
replaceFanin	ntk/v3Ntk.cpp	/^V3Ntk::replaceFanin(const V3RepIdHash& repIdHash) {$/;"	f	class:V3Ntk
replaceInsert	bdd/myHash.h	/^   bool replaceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
replaceInsert	bdd/test/myHash.h	/^   bool replaceInsert(const HashKey& k, const HashData& d) {$/;"	f	class:Hash
replaceOutput	ntk/v3Ntk.cpp	/^V3Ntk::replaceOutput(const uint32_t& index, const V3NetId& id) {$/;"	f	class:V3Ntk
replaceSECNetwork	vrf/v3VrfSEC.cpp	/^V3VrfSEC::replaceSECNetwork(V3RepIdHash& repIdHash) {$/;"	f	class:V3VrfSEC
replaceSECOutput	vrf/v3VrfSEC.cpp	/^V3VrfSEC::replaceSECOutput(const uint32_t& x) {$/;"	f	class:V3VrfSEC
replaceV3Ntk	ntk/v3NtkConstruct.cpp	/^const bool replaceV3Ntk(V3Ntk* const ntk1, V3Ntk* const ntk2) {$/;"	f
report	util/v3Usage.h	/^      void report(const bool& repTime, const bool& repMem) {$/;"	f	class:V3Usage
reportAigerCex	v3mc/v3MCReport.cpp	/^void reportAigerCex(const uint32_t& inputSize, const uint32_t& latchSize, const V3CexTrace& cex, const string& prefix) {$/;"	f
reportAigerInv	v3mc/v3MCReport.cpp	/^void reportAigerInv(const uint32_t& inputSize, const uint32_t& latchSize, const string& prefix) {$/;"	f
reportCombinationalLoops	ntk/v3NtkConstruct.cpp	/^const bool reportCombinationalLoops(V3Ntk* const ntk, const V3NetId& id, const V3UI32Vec levelData, V3Vec<V3PairType>::Vec& netLoop) {$/;"	f
reportCombinationalLoops	ntk/v3NtkConstruct.cpp	/^const uint32_t reportCombinationalLoops(V3Ntk* const ntk) {$/;"	f
reportIncompatibleModule	ntk/v3NtkConstruct.cpp	/^const bool reportIncompatibleModule(V3Ntk* const ntk, const V3NetVec& inputs, const V3NetVec& outputs, $/;"	f
reportIncompatibleModule	ntk/v3NtkConstruct.cpp	/^const bool reportIncompatibleModule(V3NtkHandler* const handler1, V3NtkHandler* const handler2) {$/;"	f
reportInconsistentRefNtk	ntk/v3NtkConstruct.cpp	/^const bool reportInconsistentRefNtk(V3Ntk* const ntk) {$/;"	f
reportInvertingNet	ntk/v3Ntk.cpp	/^V3Ntk::reportInvertingNet(const V3NetId& id) const {$/;"	f	class:V3Ntk
reportMultipleDrivenNet	ntk/v3Ntk.cpp	/^V3Ntk::reportMultipleDrivenNet(const V3GateType& type, const V3NetId& id) const {$/;"	f	class:V3Ntk
reportNetWidthInconsistency	ntk/v3Ntk.cpp	/^V3Ntk::reportNetWidthInconsistency(const V3NetId& id1, const V3NetId& id2, const string& s) const {$/;"	f	class:V3Ntk
reportON	vrf/v3VrfBase.h	/^      static inline const bool reportON()  { return (1ul & _extVerbosity); }$/;"	f	class:V3VrfBase
reportOutputBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::reportOutputBdd() {$/;"	f	class:V3Ntk
reportOutputBdd	ntk/v3NtkBdd.cpp	/^void V3Ntk::reportOutputBdd(const uint32_t& i) {$/;"	f	class:V3Ntk
reportShorterTrace	vrf/v3VrfResult.cpp	/^void reportShorterTrace(const uint32_t& cycle, const char& value) {$/;"	f
reportUnexpectedFaninSize	ntk/v3Ntk.cpp	/^V3Ntk::reportUnexpectedFaninSize(const V3GateType& type, const V3NetId& id) const {$/;"	f	class:V3Ntk
reportUnexpectedNetWidth	ntk/v3Ntk.cpp	/^V3Ntk::reportUnexpectedNetWidth(const V3NetId& id, const uint32_t& width, const string& s) const {$/;"	f	class:V3Ntk
reportUnexpectedState	vrf/v3VrfResult.cpp	/^void reportUnexpectedState(const uint32_t& cycle, const uint32_t& index, const V3BitVecX& v1, const V3BitVecX& v2) {$/;"	f
reportUnsatisfiedConstraint	vrf/v3VrfResult.cpp	/^void reportUnsatisfiedConstraint(const uint32_t& cycle, const uint32_t& index, const V3BitVecX& v) {$/;"	f
reportUnsupportedInitialState	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::reportUnsupportedInitialState() {$/;"	f	class:V3VrfIPDR
reportUnsupportedInitialState	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::reportUnsupportedInitialState() {$/;"	f	class:V3VrfMPDR
reserve	eng/minisat/IntMap.h	/^        void     reserve(K key)              { map.growTo(index(key)+1); }$/;"	f	class:IntMap
reserve	eng/minisat/IntMap.h	/^        void     reserve(K key, V pad)       { map.growTo(index(key)+1, pad); }$/;"	f	class:IntMap
reserveFormula	svr/v3SvrBase.cpp	/^V3SvrBase::reserveFormula() {$/;"	f	class:V3SvrBase
reserveFormula	svr/v3SvrBoolector.h	/^      inline const size_t reserveFormula() { return getPosExp(boolector_var(_Solver, 1, NULL)); }$/;"	f	class:V3SvrBoolector
reserveFormula	svr/v3SvrMiniSat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar(1)); }$/;"	f	class:V3SvrMiniSat
reset	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::reset(const V3NetVec& targetNets) {$/;"	f	class:V3AlgAigSimulate
reset	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::reset(const V3NetVec& targetNets) {$/;"	f	class:V3AlgBvSimulate
reset	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::reset(const V3NetVec& targetNets) { resetSimulator(); }$/;"	f	class:V3AlgSimulate
reset	bdd/bddMgrV.cpp	/^BddMgrV::reset()$/;"	f	class:BddMgrV
reset	bdd/myHash.h	/^   void reset() { _size = 0; if (_cache) { delete [] _cache; _cache = 0; } }$/;"	f	class:Cache
reset	bdd/myHash.h	/^   void reset() {$/;"	f	class:Hash
reset	bdd/test/myHash.h	/^   void reset() { _size = 0; if (_cache) { delete [] _cache; _cache = 0; } }$/;"	f	class:Cache
reset	bdd/test/myHash.h	/^   void reset() {$/;"	f	class:Hash
reset	svr/v3SvrBase.cpp	/^V3SvrBase::reset() {$/;"	f	class:V3SvrBase
reset	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::reset() {$/;"	f	class:V3SvrBoolector
reset	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::reset() {$/;"	f	class:V3SvrMiniSat
reset	util/v3Usage.h	/^      void reset() {$/;"	f	class:V3Usage
resetAuxRenaming	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetAuxRenaming() {$/;"	f	class:V3NtkHandler
resetNetName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetNetName(const uint32_t& index, const string& name) {$/;"	f	class:V3NtkHandler
resetNetWidth	ntk/v3Ntk.cpp	/^V3BvNtk::resetNetWidth(const V3NetId& id, const uint32_t& width) {$/;"	f	class:V3BvNtk
resetOutName	ntk/v3NtkHandler.cpp	/^V3NtkHandler::resetOutName(const uint32_t& index, const string& name) {$/;"	f	class:V3NtkHandler
resetProof	bdd/bddMgrV.h	/^   void resetProof() {}$/;"	f	class:BddMgrV
resetProof	bdd/test/bddMgrV.h	/^   void resetProof() {}$/;"	f	class:BddMgrV
resetReportSettings	vrf/v3VrfBase.h	/^      static inline void resetReportSettings() { setReport(1); setUsage(1); }$/;"	f	class:V3VrfBase
resetSimulator	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::resetSimulator() {$/;"	f	class:V3AlgSimulate
resetSolverSettings	vrf/v3VrfBase.h	/^      static inline void resetSolverSettings() { _extSolverType = V3_SVR_MINISAT; }$/;"	f	class:V3VrfBase
resetVerbositySettings	ntk/v3NtkHandler.h	/^      static inline void resetVerbositySettings() { _extVerbosity = 0; setReduce(1); setP2CMap(1); setC2PMap(1); }$/;"	f	class:V3NtkHandler
resize	adt/v3BitVec.cpp	/^V3BitVec::resize(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVec
resize	adt/v3BitVec.cpp	/^V3BitVecX::resize(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVecX
resolveInitial	vrf/v3VrfCITP.cpp	/^V3VrfCITP::resolveInitial(V3CITPCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfCITP
resolveInitial	vrf/v3VrfFITP.cpp	/^V3VrfFITP::resolveInitial(V3FITPCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfFITP
resolveInitial	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::resolveInitial(const uint32_t& d, V3IPDRCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfIPDR
resolveInitial	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::resolveInitial(V3MPDRCube* const cube, const V3SvrDataSet& coreProofVars) {$/;"	f	class:V3VrfMPDR
restart	bdd/bddMgrV.cpp	/^BddMgrV::restart()$/;"	f	class:BddMgrV
restart_first	eng/minisat/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Solver
restart_inc	eng/minisat/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Solver
restrict0	adt/v3BitVec.cpp	/^V3BitVecX::restrict0() {$/;"	f	class:V3BitVecX
rewriteAigGate	ntk/v3NtkRewrite.cpp	/^const bool rewriteAigGate(V3AigNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewriteBvGate	ntk/v3NtkRewrite.cpp	/^const bool rewriteBvGate(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewriteGetExpr	ntk/v3NtkRewrite.cpp	/^inline const string rewriteGetExpr(const string& width, const string& value) { return width + "'b" + value; }$/;"	f
rewriteON	ntk/v3NtkHandler.h	/^      static inline const bool rewriteON() { return _extVerbosity & 4ul;  }$/;"	f	class:V3NtkHandler
rewriteReturnAigNode	ntk/v3NtkRewrite.cpp	/^const V3NetId rewriteReturnAigNode(V3AigNtk* const ntk, V3PortableType& netHash, const bool& cpId, const V3NetType& in1, const V3NetType& in2) {$/;"	f
rewriteReturnConst	ntk/v3NtkRewrite.cpp	/^const bool rewriteReturnConst(V3BvNtk* const ntk, V3GateType& type, V3PortableType& netHash, const bool& cpId, V3InputVec& inputs, const string& expr) {$/;"	f
rewriteReturnNetId	ntk/v3NtkRewrite.cpp	/^const V3NetId rewriteReturnNetId(V3BvNtk* const ntk, const V3GateType& type, V3PortableType& netHash, const bool& cpId, const V3NetType& in1, const V3NetType& in2 = V3NetUD, const V3NetType& in3 = V3NetUD) {$/;"	f
rewriteReturnTerminal	ntk/v3NtkRewrite.cpp	/^const bool rewriteReturnTerminal(V3Ntk* const ntk, V3GateType& type, V3InputVec& inputs, const V3NetId& id, const bool& cpId) {$/;"	f
rewriteSwapNets	ntk/v3NtkRewrite.cpp	/^inline void rewriteSwapNets(V3NetType& in1, V3NetType& in2) { const V3NetType in = in1; in1 = in2; in2 = in; }$/;"	f
rewrite_ADD	ntk/v3NtkRewrite.cpp	/^const bool rewrite_ADD(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_AIG_NODE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_AIG_NODE(V3AigNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_AND	ntk/v3NtkRewrite.cpp	/^const bool rewrite_AND(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_CONST	ntk/v3NtkRewrite.cpp	/^const bool rewrite_CONST(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_DIV	ntk/v3NtkRewrite.cpp	/^const bool rewrite_DIV(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_EQUALITY	ntk/v3NtkRewrite.cpp	/^const bool rewrite_EQUALITY(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_GEQ	ntk/v3NtkRewrite.cpp	/^const bool rewrite_GEQ(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MERGE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MERGE(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MODULO	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MODULO(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MULT	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MULT(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_MUX	ntk/v3NtkRewrite.cpp	/^const bool rewrite_MUX(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_AND	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_AND(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_OR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_OR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_RED_XOR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_RED_XOR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SHL	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SHL(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SHR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SHR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SLICE	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SLICE(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_SUB	ntk/v3NtkRewrite.cpp	/^const bool rewrite_SUB(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
rewrite_XOR	ntk/v3NtkRewrite.cpp	/^const bool rewrite_XOR(V3BvNtk* const ntk, V3GateType& type, V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
right	eng/minisat/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Heap
rnd_decisions	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
rnd_init_act	eng/minisat/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Solver
rnd_pol	eng/minisat/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Solver
runPCheckProperty	prove/proveBdd.cpp	/^BddMgrV::runPCheckProperty( const string &name, BddNodeV monitor )$/;"	f	class:BddMgrV
seen	eng/minisat/Solver.h	/^    VMap<char>          seen;$/;"	m	class:Solver
select	trans/v3BvBlastAigHelper.h	/^inline const V3NetId select(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& s)$/;"	f
selectionSort	eng/minisat/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	eng/minisat/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
set	adt/v3BitVec.cpp	/^V3BitVec::set(const char* exp) {$/;"	f	class:V3BitVec
set	adt/v3BitVec.cpp	/^V3BitVec::set(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVec
set	adt/v3BitVec.cpp	/^V3BitVecX::set(const unsigned& s, const bool& init) {$/;"	f	class:V3BitVecX
set0	adt/v3BitVec.cpp	/^V3BitVec::set0(const unsigned& i) {$/;"	f	class:V3BitVec
set0	adt/v3BitVec.cpp	/^V3BitVecX::set0(const unsigned& i) {$/;"	f	class:V3BitVecX
set0	adt/v3BitVec.h	/^      inline void set0(const unsigned& i) { _data0 |= (1ul << i); _data1 &= ~(1ul << i); }$/;"	f	class:V3BitVecS
set1	adt/v3BitVec.cpp	/^V3BitVec::set1(const unsigned& i) {$/;"	f	class:V3BitVec
set1	adt/v3BitVec.cpp	/^V3BitVecX::set1(const unsigned& i) {$/;"	f	class:V3BitVecX
set1	adt/v3BitVec.h	/^      inline void set1(const unsigned& i) { _data0 &= ~(1ul << i); _data1 |= (1ul << i); }$/;"	f	class:V3BitVecS
setActivator	vrf/v3VrfMPDR.h	/^      inline void setActivator(const V3SvrData& act) { _activator = act; }$/;"	f	class:V3MPDRFrame
setAllOutFile	util/v3Msg.h	/^      void setAllOutFile(const string filename) { V3Msg::_allName = filename; }$/;"	f	class:V3MsgMgr
setAssumeCECMiter	vrf/v3VrfSEC.h	/^      inline void setAssumeCECMiter() { _secCECAssumed = 1; }$/;"	f	class:V3VrfSEC
setAssumeSECMiter	vrf/v3VrfSEC.h	/^      inline void setAssumeSECMiter() { _secSECAssumed = 1; }$/;"	f	class:V3VrfSEC
setAuxRenaming	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setAuxRenaming() {$/;"	f	class:V3NtkHandler
setBaseHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setBaseHandler() {$/;"	f	class:V3Handler
setBddMgrV	bdd/bddNodeV.h	/^   static void setBddMgrV(BddMgrV* m) { _BddMgrV = m; }$/;"	f	class:BddNodeV
setBddMgrV	bdd/test/bddNodeV.h	/^   static void setBddMgrV(BddMgrV* m) { _BddMgrV = m; }$/;"	f	class:BddNodeV
setBddOrder	bdd/bddCmd.cpp	/^bool                       setBddOrder = false;$/;"	v
setBddOrder	ntk/v3NtkBdd.cpp	/^const bool V3Ntk::setBddOrder(V3NtkHandler* const handler, const bool& file) const {$/;"	f	class:V3Ntk
setBlockBadCount	vrf/v3VrfCITP.h	/^      inline void setBlockBadCount(const uint32_t& m = V3NtkUD) { _itpBadCount = m; }$/;"	f	class:V3VrfCITP
setBlockBadCount	vrf/v3VrfFITP.h	/^      inline void setBlockBadCount(const uint32_t& m = V3NtkUD) { _itpBadCount = m; }$/;"	f	class:V3VrfFITP
setBlockBadCountIndep	vrf/v3VrfCITP.h	/^      inline void setBlockBadCountIndep (const bool& f) { if (f) _itpAttr |= 4ul;  else _itpAttr &= ~4ul;  }$/;"	f	class:V3VrfCITP
setBlockBadCountIndep	vrf/v3VrfFITP.h	/^      inline void setBlockBadCountIndep (const bool& f) { if (f) _itpAttr |= 4ul;  else _itpAttr &= ~4ul;  }$/;"	f	class:V3VrfFITP
setBlockingStruct	vrf/v3VrfCITP.cpp	/^V3VrfCITP::setBlockingStruct(const V3NetVec& baseCube) {$/;"	f	class:V3VrfCITP
setBlockingStruct	vrf/v3VrfCITP.cpp	/^V3VrfCITP::setBlockingStruct(const V3NetVec& baseCube, const V3UI32Vec& blockIndex) {$/;"	f	class:V3VrfCITP
setBlockingStruct	vrf/v3VrfFITP.cpp	/^V3VrfFITP::setBlockingStruct(const V3NetVec& baseCube) {$/;"	f	class:V3VrfFITP
setBlockingStruct	vrf/v3VrfFITP.cpp	/^V3VrfFITP::setBlockingStruct(const V3NetVec& baseCube, const V3UI32Vec& blockIndex) {$/;"	f	class:V3VrfFITP
setC2PMap	ntk/v3NtkHandler.h	/^      static inline void setC2PMap (const bool& t) { if (t) _extVerbosity |= 16ul; else _extVerbosity &= ~16ul; }$/;"	f	class:V3NtkHandler
setCexTrace	ext/v3Property.h	/^      inline void setCexTrace(V3CexTrace* const cex) {$/;"	f	class:V3VrfResult
setChecker	vrf/v3VrfKLive.h	/^      inline void setChecker(V3VrfBase* const c) { _klChecker = c; }$/;"	f	class:V3VrfKLive
setChecker	vrf/v3VrfSEC.h	/^      inline void setChecker(V3VrfBase* const c) { _secChecker = c; }$/;"	f	class:V3VrfSEC
setCmdLen	cmd/v3CmdMgr.h	/^      inline void setCmdLen(unsigned n) { _cmdLen = n; }$/;"	f	class:V3CmdExec
setConfBudget	eng/minisat/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Solver
setConstraint	vrf/v3VrfBase.cpp	/^V3VrfBase::setConstraint(const V3NetVec& constrList, const uint32_t& p) {$/;"	f	class:V3VrfBase
setConstructStandardFSM	stg/v3StgFSM.h	/^      inline void setConstructStandardFSM(const bool& e) { if (e) _configs |= 8ul; else _configs &= ~8ul; }$/;"	f	class:V3FSMSDGDB
setCurHandlerFromId	ntk/v3NtkHandler.cpp	/^V3Handler::setCurHandlerFromId(const uint32_t& ntkId) {$/;"	f	class:V3Handler
setCurHandlerFromPath	ntk/v3NtkHandler.cpp	/^V3Handler::setCurHandlerFromPath(const string& path) {$/;"	f	class:V3Handler
setCutSignals	ntk/v3Ntk.h	/^      inline void setCutSignals(const V3NetVec& cut) { _cutSignals = cut; }$/;"	f	class:V3Ntk
setDecisionVar	eng/minisat/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Solver
setDefaultSolver	vrf/v3VrfBase.h	/^      static inline void setDefaultSolver(const V3SolverType& type) { _extSolverType = type; }$/;"	f	class:V3VrfBase
setDynamicInc	vrf/v3VrfUMC.h	/^      inline void setDynamicInc(const bool& d) { if (d) _umcAttr |= 8ul; else _umcAttr &= ~8ul; }$/;"	f	class:V3VrfUMC
setEarlySuspended	stg/v3StgFSM.h	/^      inline void setEarlySuspended() { _configs |= 128ul; }$/;"	f	class:V3FSM
setEarlySuspended	stg/v3StgFSM.h	/^      inline void setEarlySuspended() { _configs |= 128ul; }$/;"	f	class:V3FSMSDGDB
setEndline	vrf/v3VrfBase.h	/^      static inline void setEndline(const bool& t) { if (t) _extVerbosity |= 4ul;  else _extVerbosity &= ~4ul;  }$/;"	f	class:V3VrfBase
setExternalVerbosity	ntk/v3NtkHandler.h	/^      static inline void setExternalVerbosity() { _intVerbosity = _extVerbosity; }$/;"	f	class:V3NtkHandler
setFSM	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setFSM(const string& fsmName, V3FSMExtract* const fsmList) {$/;"	f	class:V3NtkHandler
setFairConstr	ext/v3Property.cpp	/^V3Property::setFairConstr(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setFairConstr	ext/v3Property.cpp	/^V3Property::setFairConstr(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setFalseEmptyButExist	stg/v3StgFSM.h	/^      inline void setFalseEmptyButExist() { assert (!_falseSize); _falseSize = 1; }$/;"	f	class:V3FSMSDG
setFireOnly	vrf/v3VrfUMC.h	/^      inline void setFireOnly  (const bool& f) { if (f) _umcAttr |= 1ul; else _umcAttr &= ~1ul; }$/;"	f	class:V3VrfUMC
setForceUnreachable	vrf/v3VrfCITP.h	/^      inline void setForceUnreachable   (const bool& f) { if (f) _itpAttr |= 2ul;  else _itpAttr &= ~2ul;  }$/;"	f	class:V3VrfCITP
setForceUnreachable	vrf/v3VrfFITP.h	/^      inline void setForceUnreachable   (const bool& f) { if (f) _itpAttr |= 2ul;  else _itpAttr &= ~2ul;  }$/;"	f	class:V3VrfFITP
setForwardSATGen	vrf/v3VrfIPDR.h	/^      inline void setForwardSATGen  (const bool& s) { if (s) _pdrAttr |= 1ul; else _pdrAttr &= ~1ul; }$/;"	f	class:V3VrfIPDR
setForwardSATGen	vrf/v3VrfMPDR.h	/^      inline void setForwardSATGen  (const bool& s) { if (s) _pdrAttr |= 1ul; else _pdrAttr &= ~1ul; }$/;"	f	class:V3VrfMPDR
setForwardUNSATGen	vrf/v3VrfIPDR.h	/^      inline void setForwardUNSATGen(const bool& u) { if (u) _pdrAttr |= 2ul; else _pdrAttr &= ~2ul; }$/;"	f	class:V3VrfIPDR
setForwardUNSATGen	vrf/v3VrfMPDR.h	/^      inline void setForwardUNSATGen(const bool& u) { if (u) _pdrAttr |= 2ul; else _pdrAttr &= ~2ul; }$/;"	f	class:V3VrfMPDR
setImplyInit	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyInit() {$/;"	f	class:V3SvrBase
setImplyInit	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyInit() {$/;"	f	class:V3SvrBoolector
setImplyInit	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyInit() {$/;"	f	class:V3SvrMiniSat
setImplyIntersection	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyIntersection(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
setImplyIntersection	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyIntersection(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
setImplyIntersection	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyIntersection(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
setImplyUnion	svr/v3SvrBase.cpp	/^V3SvrBase::setImplyUnion(const V3SvrDataVec& var_exp) {$/;"	f	class:V3SvrBase
setImplyUnion	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setImplyUnion(const V3SvrDataVec& Exps) {$/;"	f	class:V3SvrBoolector
setImplyUnion	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setImplyUnion(const V3SvrDataVec& vars) {$/;"	f	class:V3SvrMiniSat
setIncContinueOnLastSolver	vrf/v3VrfBase.h	/^      inline void setIncContinueOnLastSolver(const bool& c) { _incContinueOnLastSolver = c; }$/;"	f	class:V3VrfBase
setIncDepth	vrf/v3VrfBMC.h	/^      inline void setIncDepth(const uint32_t& d) { _incDepth = d; }$/;"	f	class:V3VrfBMC
setIncDepth	vrf/v3VrfKLive.h	/^      inline void setIncDepth(const uint32_t& i) { _incDepth = i; }$/;"	f	class:V3VrfKLive
setIncDepth	vrf/v3VrfUMC.h	/^      inline void setIncDepth(const uint32_t& d) { _incDepth = d; }$/;"	f	class:V3VrfUMC
setIncKeepLastReachability	vrf/v3VrfBase.h	/^      inline void setIncKeepLastReachability(const bool& k) { _incKeepLastReachability = k; }$/;"	f	class:V3VrfBase
setIncKeepSilent	vrf/v3VrfBase.h	/^      inline void setIncKeepSilent          (const bool& s) { _incKeepSilent           = s; }$/;"	f	class:V3VrfBase
setIncLastDepthToKeepGoing	vrf/v3VrfBase.h	/^      inline void setIncLastDepthToKeepGoing(const uint32_t& d) { _incLastDepthToKeepGoing = d; }$/;"	f	class:V3VrfBase
setIncVerifyUsingCurResult	vrf/v3VrfBase.h	/^      inline void setIncVerifyUsingCurResult(const bool& v) { _incVerifyUsingCurResult = v; }$/;"	f	class:V3VrfBase
setIncrementDepth	vrf/v3VrfCITP.h	/^      inline void setIncrementDepth     (const bool& f) { if (f) _itpAttr |= 1ul;  else _itpAttr &= ~1ul;  }$/;"	f	class:V3VrfCITP
setIncrementDepth	vrf/v3VrfFITP.h	/^      inline void setIncrementDepth     (const bool& f) { if (f) _itpAttr |= 1ul;  else _itpAttr &= ~1ul;  }$/;"	f	class:V3VrfFITP
setIndInv	ext/v3Property.h	/^      inline void setIndInv(V3Ntk* const indInv) {$/;"	f	class:V3VrfResult
setInit	ext/v3Property.h	/^      inline void setInit(const V3BitVecX& i) { _init = new V3BitVecX(i); assert (_init); }$/;"	f	class:V3CexTrace
setInput	ntk/v3Ntk.cpp	/^V3Ntk::setInput(const V3NetId& id, const V3InputVec& inputs) {$/;"	f	class:V3Ntk
setInputData	vrf/v3VrfIPDR.h	/^      inline void setInputData(const V3BitVecX& v) { _inputData = v; }$/;"	f	class:V3IPDRCube
setInputData	vrf/v3VrfMPDR.h	/^      inline void setInputData(const V3BitVecX& v) { _inputData = v; }$/;"	f	class:V3MPDRCube
setInternalCEC	vrf/v3VrfSEC.h	/^      inline void setInternalCEC() { assert (isAssumeCECMiter()); _secIsCECorSEC = 0; }$/;"	f	class:V3VrfSEC
setInternalSEC	vrf/v3VrfSEC.h	/^      inline void setInternalSEC() { assert (isAssumeSECMiter()); _secIsCECorSEC = 1; }$/;"	f	class:V3VrfSEC
setInternalVerbosity	ntk/v3NtkHandler.h	/^      static inline void setInternalVerbosity() { _extVerbosity = _intVerbosity; }$/;"	f	class:V3NtkHandler
setInvConstr	ext/v3Property.cpp	/^V3Property::setInvConstr(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setInvConstr	ext/v3Property.cpp	/^V3Property::setInvConstr(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setInvariant	ext/v3Property.cpp	/^V3Property::setInvariant(V3NtkHandler* const constrHandler, V3FSM* const fsm) {$/;"	f	class:V3Property
setInvariant	ext/v3Property.cpp	/^V3Property::setInvariant(V3NtkHandler* const constrHandler, const uint32_t& start, const uint32_t& end) {$/;"	f	class:V3Property
setInvariantDirectedCluster	stg/v3StgExtract.h	/^      inline void setInvariantDirectedCluster() { assert (!(_configs & 3ul  )); _configs |= 2ul;   }$/;"	f	class:V3FSMExtract
setLastHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setLastHandler() {$/;"	f	class:V3Handler
setLatestMiscData	ntk/v3Ntk.h	/^inline void V3Ntk::setLatestMiscData(const V3NetId& id) {$/;"	f	class:V3Ntk
setList	adt/v3Misc.h	/^      inline void setList(const uint32_t& i, const size_t& t) {$/;"	f	class:V3PortableType
setMandCmd	cmd/v3CmdMgr.h	/^      inline void setMandCmd(const string& str) { _mandCmd.push_back(str);}$/;"	f	class:V3CmdExec
setMaxAllowedStateSize	stg/v3StgFSM.h	/^      inline void setMaxAllowedStateSize(const uint32_t& s) { _maxSize = s; }$/;"	f	class:V3FSMSDGDB
setMaxDepth	vrf/v3VrfBase.h	/^      inline void setMaxDepth(const uint32_t& d) { assert (d); _maxDepth = d; }$/;"	f	class:V3VrfBase
setMaxStateSize	stg/v3StgExtract.h	/^      inline void setMaxStateSize(const uint32_t& s) { assert (!_depGraph.getNodeSize()); _maxSize = s; }$/;"	f	class:V3FSMExtract
setMaxTime	vrf/v3VrfBase.h	/^      inline void setMaxTime(const double& t) { assert (t); _maxTime = t; }$/;"	f	class:V3VrfBase
setMaxTimeUsage	stg/v3StgExtract.h	/^      inline void setMaxTimeUsage(const double& t) { assert (t >= 0); _maxTime = t; }$/;"	f	class:V3FSMExtract
setMemUsage	util/v3Usage.h	/^      void setMemUsage() {$/;"	f	class:V3Usage
setNoIncBySharedBound	vrf/v3VrfCITP.h	/^      inline void setNoIncBySharedBound (const bool& d) { if (d) _itpAttr |= 8ul;  else _itpAttr &= ~8ul;  }$/;"	f	class:V3VrfCITP
setNoIncBySharedBound	vrf/v3VrfFITP.h	/^      inline void setNoIncBySharedBound (const bool& d) { if (d) _itpAttr |= 8ul;  else _itpAttr &= ~8ul;  }$/;"	f	class:V3VrfFITP
setNtkName	ntk/v3NtkHandler.h	/^      inline void setNtkName(const string& n) { assert (n.size()); _ntkName = n; }$/;"	f	class:V3NtkHandler
setOmitNodesAllCombVars	stg/v3StgFSM.h	/^      inline void setOmitNodesAllCombVars(const bool& e) { if (e) _configs |= 1ul; else _configs &= ~1ul; }$/;"	f	class:V3FSMSDGDB
setOmitNodesIndepToVars	stg/v3StgFSM.h	/^      inline void setOmitNodesIndepToVars(const bool& e) { if (e) _configs |= 2ul; else _configs &= ~2ul; }$/;"	f	class:V3FSMSDGDB
setOnes	adt/v3BitVec.h	/^      inline void setOnes(const uint64_t& v) { _data1 = v; }$/;"	f	class:V3BitVecS
setOptCmd	cmd/v3CmdMgr.h	/^      inline void setOptCmd(const string& str) { _optCmd.push_back(str); }$/;"	f	class:V3CmdExec
setOutFile	util/v3Msg.h	/^      void setOutFile(const string filename) { _filename = filename; }$/;"	f	class:V3Msg
setOutFile	util/v3Msg.h	/^      void setOutFile(const string filename, const V3MsgType type) { Msgs[type]->setOutFile(filename); }$/;"	f	class:V3MsgMgr
setOutputFile	svr/v3SvrBase.cpp	/^V3SvrBase::setOutputFile(const string fileName) {$/;"	f	class:V3SvrBase
setP2CMap	ntk/v3NtkHandler.h	/^      static inline void setP2CMap (const bool& t) { if (t) _extVerbosity |=  8ul; else _extVerbosity &= ~8ul;  }$/;"	f	class:V3NtkHandler
setPolarity	eng/minisat/Solver.h	/^inline void     Solver::setPolarity   (Var v, lbool b){ user_pol[v] = b; }$/;"	f	class:Solver
setPreDepth	vrf/v3VrfBMC.h	/^      inline void setPreDepth(const uint32_t& d) { _preDepth = d; }$/;"	f	class:V3VrfBMC
setPreDepth	vrf/v3VrfUMC.h	/^      inline void setPreDepth(const uint32_t& d) { _preDepth = d; }$/;"	f	class:V3VrfUMC
setPrevHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setPrevHandler() {$/;"	f	class:V3Handler
setProfile	vrf/v3VrfBase.h	/^      static inline void setProfile(const bool& t) { if (t) _extVerbosity |= 32ul; else _extVerbosity &= ~32ul; }$/;"	f	class:V3VrfBase
setPrompt	cmd/v3CmdMgr.h	/^      inline void setPrompt() { _prompt = _defaultPrompt + "> "; }$/;"	f	class:V3CmdMgr
setPropBudget	eng/minisat/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Solver
setProperty	ntk/v3NtkHandler.cpp	/^V3NtkHandler::setProperty(V3Property* const p) {$/;"	f	class:V3NtkHandler
setProveOnly	vrf/v3VrfUMC.h	/^      inline void setProveOnly (const bool& p) { if (p) _umcAttr |= 2ul; else _umcAttr &= ~2ul; }$/;"	f	class:V3VrfUMC
setQuteLogFile	io/v3NtkQuteRTL.cpp	/^void setQuteLogFile() {$/;"	f
setRecycle	vrf/v3VrfIPDR.h	/^      inline void setRecycle(const uint32_t& r) { _pdrRecycle = r; }$/;"	f	class:V3VrfIPDR
setRecycle	vrf/v3VrfMPDR.h	/^      inline void setRecycle(const uint32_t& r) { _pdrRecycle = r; }$/;"	f	class:V3VrfMPDR
setRecycleInterpolants	vrf/v3VrfCITP.h	/^      inline void setRecycleInterpolants(const bool& f) { if (f) _itpAttr |= 16ul; else _itpAttr &= ~16ul; }$/;"	f	class:V3VrfCITP
setRecycleInterpolants	vrf/v3VrfFITP.h	/^      inline void setRecycleInterpolants(const bool& f) { if (f) _itpAttr |= 16ul; else _itpAttr &= ~16ul; }$/;"	f	class:V3VrfFITP
setReduce	ntk/v3NtkHandler.h	/^      static inline void setReduce (const bool& t) { if (t) _extVerbosity |=  1ul; else _extVerbosity &= ~1ul;  }$/;"	f	class:V3NtkHandler
setRenderNonEmptyStates	stg/v3StgFSM.h	/^      inline void setRenderNonEmptyStates(const bool& e) { if (e) _configs |= 4ul; else _configs &= ~4ul; }$/;"	f	class:V3FSMSDGDB
setReport	vrf/v3VrfBase.h	/^      static inline void setReport (const bool& t) { if (t) _extVerbosity |= 1ul;  else _extVerbosity &= ~1ul;  }$/;"	f	class:V3VrfBase
setResult	ext/v3Property.cpp	/^V3Property::setResult(const V3VrfResult& r) {$/;"	f	class:V3Property
setRewrite	ntk/v3NtkHandler.h	/^      static inline void setRewrite(const bool& t) { if (t) _extVerbosity |=  4ul; else _extVerbosity &= ~4ul;  }$/;"	f	class:V3NtkHandler
setRewriteLevel	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setRewriteLevel(const int& rwl) {$/;"	f	class:V3SvrBoolector
setRootHandler	ntk/v3NtkHandler.cpp	/^V3Handler::setRootHandler() {$/;"	f	class:V3Handler
setRstOnly	vrf/v3VrfBase.h	/^      static inline void setRstOnly(const bool& t) { if (t) _extVerbosity |= 2ul;  else _extVerbosity &= ~2ul;  }$/;"	f	class:V3VrfBase
setSharedBound	vrf/v3VrfBase.h	/^      inline void setSharedBound(V3VrfSharedBound* const s) { _sharedBound = s; }$/;"	f	class:V3VrfBase
setSharedInv	vrf/v3VrfBase.h	/^      inline void setSharedInv(V3VrfSharedInv* const i) { _sharedInv = i; }$/;"	f	class:V3VrfBase
setSharedMem	vrf/v3VrfBase.h	/^      inline void setSharedMem(V3VrfSharedMem* const m) { _sharedMem = m; }$/;"	f	class:V3VrfBase
setSharedNtk	vrf/v3VrfBase.h	/^      inline void setSharedNtk(V3VrfSharedNtk* const n) { _sharedNtk = n; }$/;"	f	class:V3VrfBase
setSolver	vrf/v3VrfBase.h	/^      inline void setSolver(const V3SolverType& s) { assert (V3_SVR_TOTAL > s); _solverType = s; }$/;"	f	class:V3VrfBase
setSolver	vrf/v3VrfBase.h	/^      static inline void setSolver (const bool& t) { if (t) _extVerbosity |= 8ul;  else _extVerbosity &= ~8ul;  }$/;"	f	class:V3VrfBase
setSource	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgAigSimulate
setSource	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgBvSimulate
setSource	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSource(const V3NetId& id, const V3BitVecX& value) {}$/;"	f	class:V3AlgSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgAigSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {$/;"	f	class:V3AlgBvSimulate
setSourceEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceEvent(const V3NetId& id, const V3BitVecX& value) {}$/;"	f	class:V3AlgSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceFree(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgAigSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceFree(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgBvSimulate
setSourceFree	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceFree(const V3GateType& type, const bool& random) {}$/;"	f	class:V3AlgSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgAigSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {$/;"	f	class:V3AlgBvSimulate
setSourceFreeEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::setSourceFreeEvent(const V3GateType& type, const bool& random) {}$/;"	f	class:V3AlgSimulate
setState	dfx/v3DfxTrace.h	/^inline void V3DfxCube::setState(const V3NetVec& v) {$/;"	f	class:V3DfxCube
setState	vrf/v3VrfCITP.h	/^inline void V3CITPCube::setState(const V3NetVec& v) {$/;"	f	class:V3CITPCube
setState	vrf/v3VrfFITP.h	/^inline void V3FITPCube::setState(const V3NetVec& v) {$/;"	f	class:V3FITPCube
setState	vrf/v3VrfIPDR.h	/^inline void V3IPDRCube::setState(const V3NetVec& v) {$/;"	f	class:V3IPDRCube
setState	vrf/v3VrfMPDR.h	/^inline void V3MPDRCube::setState(const V3NetVec& v) {$/;"	f	class:V3MPDRCube
setStateForSimulation	stg/v3StgFSM.cpp	/^V3FSM::setStateForSimulation(const V3SimTrace& trace) {$/;"	f	class:V3FSM
setStrash	ntk/v3NtkHandler.h	/^      static inline void setStrash (const bool& t) { if (t) _extVerbosity |=  2ul; else _extVerbosity &= ~2ul;  }$/;"	f	class:V3NtkHandler
setSynthesisMode	vrf/v3VrfSEC.h	/^      inline void setSynthesisMode(const bool& s) { _secSynthesis = s; }$/;"	f	class:V3VrfSEC
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgAigGeneralize
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgBvGeneralize
setTargetNets	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::setTargetNets(const V3NetVec& curTargets, const V3NetVec& nextTargets) {$/;"	f	class:V3AlgGeneralize
setTargetValue	svr/v3SvrBase.cpp	/^V3SvrBase::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrBase
setTargetValue	svr/v3SvrBase.cpp	/^V3SvrBase::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrBase
setTargetValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrBoolector
setTargetValue	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrBoolector
setTargetValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, V3SvrDataVec& formula) {$/;"	f	class:V3SvrMiniSat
setTargetValue	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::setTargetValue(const V3NetId& id, const V3BitVecX& value, const uint32_t& depth, const size_t& prev) {$/;"	f	class:V3SvrMiniSat
setTimeUsage	util/v3Usage.h	/^      void setTimeUsage() {$/;"	f	class:V3Usage
setTrueEmptyButExist	stg/v3StgFSM.h	/^      inline void setTrueEmptyButExist() { assert (!_trueSize); _trueSize = 1; }$/;"	f	class:V3FSMSDG
setUniqueness	vrf/v3VrfUMC.h	/^      inline void setUniqueness(const bool& u) { if (u) _umcAttr |= 4ul; else _umcAttr &= ~4ul; }$/;"	f	class:V3VrfUMC
setUsage	vrf/v3VrfBase.h	/^      static inline void setUsage  (const bool& t) { if (t) _extVerbosity |= 16ul; else _extVerbosity &= ~16ul; }$/;"	f	class:V3VrfBase
setVariableClusterBySCC	stg/v3StgExtract.h	/^      inline void setVariableClusterBySCC()     { assert (!(_configs & 3ul  )); _configs |= 1ul;   }$/;"	f	class:V3FSMExtract
setVisited	bdd/bddNodeV.h	/^   void setVisited() { _visited = 1; }$/;"	f	class:BddNodeVInt
setVisited	bdd/test/bddNodeV.h	/^   void setVisited() { _visited = 1; }$/;"	f	class:BddNodeVInt
setX	adt/v3BitVec.cpp	/^V3BitVecX::setX (const unsigned& i) {$/;"	f	class:V3BitVecX
setX	adt/v3BitVec.h	/^      inline void setX(const unsigned& i) { _data0 &= ~(1ul << i); _data1 &= ~(1ul << i); }$/;"	f	class:V3BitVecS
setZeros	adt/v3BitVec.h	/^      inline void setZeros(const uint64_t& v) { _data0 = v; }$/;"	f	class:V3BitVecS
set_value	adt/v3BitVec.cpp	/^V3BitVecX::set_value(const unsigned& i, const char& v) {$/;"	f	class:V3BitVecX
sh_select	svr/v3SvrSatHelper.h	/^inline void sh_select(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& s)$/;"	f
shortestPath	adt/v3Graph.h	/^V3Graph<T>::shortestPath(const T& node1, const T& node2, V3NodeStack& path) const {$/;"	f	class:V3Graph
shrink	eng/minisat/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Clause
shrink	eng/minisat/Vec.h	/^    void     shrink   (Size nelems)  { assert(nelems <= sz); for (Size i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
shrink_	eng/minisat/Vec.h	/^    void     shrink_  (Size nelems)  { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:vec
sign	eng/minisat/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f
simpDB_assigns	eng/minisat/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Solver
simpDB_props	eng/minisat/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Solver
simplify	svr/v3SvrBase.cpp	/^V3SvrBase::simplify() {$/;"	f	class:V3SvrBase
simplify	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::simplify() {$/;"	f	class:V3SvrBoolector
simplify	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::simplify() { return _Solver->simplify(); }$/;"	f	class:V3SvrMiniSat
simplifyInputPatterns	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::simplifyInputPatterns(const bool& minTrans, const uint32_t& partition) {$/;"	f	class:V3TraceSimplify
simplifyNetwork	vrf/v3VrfKLive.cpp	/^V3VrfKLive::simplifyNetwork(const uint32_t& p) {$/;"	f	class:V3VrfKLive
simplifySECNetwork	vrf/v3VrfSEC.cpp	/^V3VrfSEC::simplifySECNetwork(V3NetVec& p2cMap, V3NetVec& c2pMap, const V3NetVec& eqNets) {$/;"	f	class:V3VrfSEC
simulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::simulate() {$/;"	f	class:V3AlgAigSimulate
simulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulate() {$/;"	f	class:V3AlgBvSimulate
simulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::simulate() {}$/;"	f	class:V3AlgSimulate
simulateEventList	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::simulateEventList() {$/;"	f	class:V3AlgAigSimulate
simulateEventList	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulateEventList() {$/;"	f	class:V3AlgBvSimulate
simulateForForwardConstruction	stg/v3StgFSM.cpp	/^V3FSM::simulateForForwardConstruction(const uint32_t& state) {$/;"	f	class:V3FSM
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecS& generalizeValue) {$/;"	f	class:V3AlgAigGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecS& generalizeValue, $/;"	f	class:V3AlgAigGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecX& generalizeValue) {$/;"	f	class:V3AlgBvGeneralize
simulateForGeneralization	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::simulateForGeneralization(const V3NetId& generalizeId, const V3BitVecX& generalizeValue, $/;"	f	class:V3AlgBvGeneralize
simulateGate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::simulateGate(const V3NetId& id) {$/;"	f	class:V3AlgBvSimulate
simulationCheckFiredResult	vrf/v3VrfResult.cpp	/^const int simulationCheckFiredResult(const V3CexTrace& cex, const V3NetVec& constrList, const V3NetVec& fairList, const bool& safe, const V3NtkHandler* const handler, const uint32_t& index) {$/;"	f
size	adt/v3BitVec.h	/^      inline const unsigned size() const { return _size; }$/;"	f	class:V3BitVec
size	adt/v3BitVec.h	/^      inline const unsigned size() const { return _size; }$/;"	f	class:V3BitVecX
size	adt/v3Bucket.h	/^      inline const uint32_t size() const { return _size; }$/;"	f	class:V3BucketList
size	adt/v3Bucket.h	/^      inline const uint32_t size() const { return _size; }$/;"	f	class:V3IncBucketList
size	bdd/myHash.h	/^   size_t size() const { return _size; }$/;"	f	class:Cache
size	bdd/myHash.h	/^   size_t size() const {$/;"	f	class:Hash
size	bdd/test/myHash.h	/^   size_t size() const { return _size; }$/;"	f	class:Cache
size	bdd/test/myHash.h	/^   size_t size() const {$/;"	f	class:Hash
size	eng/minisat/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:RegionAllocator
size	eng/minisat/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Heap
size	eng/minisat/IntMap.h	/^        int      size        (void)      const  { return xs.size(); }$/;"	f	class:IntSet
size	eng/minisat/Map.h	/^    int        size;$/;"	m	class:Map
size	eng/minisat/ParseUtils.h	/^    int            size;$/;"	m	class:StreamBuffer
size	eng/minisat/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Queue
size	eng/minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	struct:Clause::__anon1
size	eng/minisat/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Clause
size	eng/minisat/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:CMap
size	eng/minisat/SolverTypes.h	/^    uint32_t size      () const      { return ra.size(); }$/;"	f	class:ClauseAllocator
size	eng/minisat/Vec.h	/^    Size     size     (void) const   { return sz; }$/;"	f	class:vec
skipLine	eng/minisat/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f
skipWhitespace	eng/minisat/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f
smudge	eng/minisat/SolverTypes.h	/^    void  smudge    (const K& idx){$/;"	f	class:OccLists
solve	eng/minisat/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Solver
solve	eng/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Solver
solve	eng/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Solver
solve	eng/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Solver
solve	eng/minisat/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Solver
solve	svr/v3SvrBase.cpp	/^V3SvrBase::solve() {$/;"	f	class:V3SvrBase
solve	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::solve() {$/;"	f	class:V3SvrBoolector
solve	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::solve() {$/;"	f	class:V3SvrMiniSat
solveLimited	eng/minisat/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Solver
solves	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
sort	eng/minisat/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	eng/minisat/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	eng/minisat/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	eng/minisat/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f
speculativeReduction	vrf/v3VrfSEC.cpp	/^V3VrfSEC::speculativeReduction(const uint32_t& cycle) {$/;"	f	class:V3VrfSEC
splitAigFromProperties	io/v3AigWriter.cpp	/^void splitAigFromProperties(const string& fileName, const bool& symbol) {$/;"	f
standardize	bdd/bddMgrV.cpp	/^BddMgrV::standardize(BddNodeV &f, BddNodeV &g, BddNodeV &h, bool &isNegEdge)$/;"	f	class:BddMgrV
start	util/v3Usage.h	/^      inline void start() { assert (!_isStarted); _startTime = clock(); ++_numCalled; _isStarted = 1; }$/;"	f	class:V3Stat
startAllDefault	util/v3Msg.h	/^      void startAllDefault() { for (unsigned i = 1; i < 5; ++i) Msgs[i]->startDefault(); }$/;"	f	class:V3MsgMgr
startAllOutFile	util/v3Msg.h	/^      void startAllOutFile(bool append = false) {$/;"	f	class:V3MsgMgr
startChecker	v3mc/v3MCMain.cpp	/^void* startChecker(void* param) {$/;"	f
startClusterVariables	stg/v3StgExtract.cpp	/^V3FSMExtract::startClusterVariables() {$/;"	f	class:V3FSMExtract
startConstructFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::startConstructFSMSDG() {$/;"	f	class:V3FSMSDGDB
startConstructFSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDGDB::startConstructFSMSDG(V3SDGBase* const sdg, uint32_t& stateSize, V3FSMSDGMap& selectMap, V3NetVec& parentNets) {$/;"	f	class:V3FSMSDGDB
startDefault	util/v3Msg.h	/^      void startDefault() { _defaultON = true; }$/;"	f	class:V3Msg
startDefault	util/v3Msg.h	/^      void startDefault(const V3MsgType type) { Msgs[type]->startDefault(); }$/;"	f	class:V3MsgMgr
startExtractClusteredFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractClusteredFSMs() {$/;"	f	class:V3FSMExtract
startExtractFSM	stg/v3StgFSM.cpp	/^V3FSM::startExtractFSM(const V3NetVec& terminal) {$/;"	f	class:V3FSM
startExtractFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractFSMs() {$/;"	f	class:V3FSMExtract
startExtractInvariantFSMs	stg/v3StgExtract.cpp	/^V3FSMExtract::startExtractInvariantFSMs() {$/;"	f	class:V3FSMExtract
startOutFile	util/v3Msg.h	/^      void startOutFile(bool append) {$/;"	f	class:V3Msg
startOutFile	util/v3Msg.h	/^      void startOutFile(const V3MsgType type, bool append = false) { Msgs[type]->startOutFile(append); }$/;"	f	class:V3MsgMgr
startVarOrder	alg/v3AlgGeneralize.cpp	/^V3GenStruct::startVarOrder(const V3NetVec& careVars) {$/;"	f	class:V3GenStruct
startVerificationFromProp	v3mc/v3MCProp.cpp	/^void startVerificationFromProp(V3NtkHandler* const handler, const uint32_t& numOfCores, const double& maxTime, const double& maxMemory) {$/;"	f
startVerificationMain	v3mc/v3MCMain.cpp	/^void* startVerificationMain(void* param) {$/;"	f
startVerify	vrf/v3VrfBMC.cpp	/^V3VrfBMC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfBMC
startVerify	vrf/v3VrfBase.cpp	/^V3VrfBase::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfBase
startVerify	vrf/v3VrfCITP.cpp	/^V3VrfCITP::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfCITP
startVerify	vrf/v3VrfFITP.cpp	/^V3VrfFITP::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfFITP
startVerify	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfIPDR
startVerify	vrf/v3VrfKLive.cpp	/^V3VrfKLive::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfKLive
startVerify	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfMPDR
startVerify	vrf/v3VrfSEC.cpp	/^V3VrfSEC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfSEC
startVerify	vrf/v3VrfSIM.cpp	/^V3VrfSIM::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfSIM
startVerify	vrf/v3VrfUMC.cpp	/^V3VrfUMC::startVerify(const uint32_t& p) {$/;"	f	class:V3VrfUMC
starts	eng/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Solver
stopAllDefault	util/v3Msg.h	/^      void stopAllDefault() { for (unsigned i = 1; i < 5; ++i) Msgs[i]->stopDefault(); }$/;"	f	class:V3MsgMgr
stopAllOutFile	util/v3Msg.h	/^      void stopAllOutFile() { if (isAllOutFileON()) V3Msg::_allout.close(); }$/;"	f	class:V3MsgMgr
stopDefault	util/v3Msg.h	/^      void stopDefault() { _defaultON = false; }$/;"	f	class:V3Msg
stopDefault	util/v3Msg.h	/^      void stopDefault(const V3MsgType type) { Msgs[type]->stopDefault(); }$/;"	f	class:V3MsgMgr
stopOnAllInitialOrAllTerminal	stg/v3StgFSM.h	/^      inline void stopOnAllInitialOrAllTerminal(const bool& e) { if (e) _configs |= 1ul; else _configs &= ~1ul; }$/;"	f	class:V3FSM
stopOutFile	util/v3Msg.h	/^      void stopOutFile() { if (isOutFileON()) _outfile.close(); }$/;"	f	class:V3Msg
stopOutFile	util/v3Msg.h	/^      void stopOutFile(const V3MsgType type) { Msgs[type]->stopOutFile(); }$/;"	f	class:V3MsgMgr
strashAigGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashAigGate(V3AigNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashAigGate	ntk/v3NtkStrash.cpp	/^void strashAigGate(V3AigNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashAigNodeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashAigNodeGate(V3AigNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashAigNodeGate	ntk/v3NtkStrash.cpp	/^void strashAigNodeGate(V3AigNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvConstGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvConstGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvConstGate	ntk/v3NtkStrash.cpp	/^void strashBvConstGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvGate	ntk/v3NtkStrash.cpp	/^void strashBvGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvMuxGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvMuxGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvMuxGate	ntk/v3NtkStrash.cpp	/^void strashBvMuxGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvPairTypeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvPairTypeGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvPairTypeGate	ntk/v3NtkStrash.cpp	/^void strashBvPairTypeGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvReducedTypeGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvReducedTypeGate(V3BvNtk* const ntk, const V3GateType& type, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvReducedTypeGate	ntk/v3NtkStrash.cpp	/^void strashBvReducedTypeGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashBvSliceGate	ntk/v3NtkStrash.cpp	/^const V3NetId strashBvSliceGate(V3BvNtk* const ntk, const V3InputVec& inputs, V3PortableType& netHash) {$/;"	f
strashBvSliceGate	ntk/v3NtkStrash.cpp	/^void strashBvSliceGate(V3BvNtk* const ntk, const V3NetId& id, V3PortableType& netHash) {$/;"	f
strashON	ntk/v3NtkHandler.h	/^      static inline const bool strashON()  { return _extVerbosity & 2ul;  }$/;"	f	class:V3NtkHandler
strengthen	eng/minisat/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Clause
strongConnect	adt/v3Graph.h	/^V3Graph<T>::strongConnect(const uint32_t& curNode, V3IndexField& scc, V3UI32Vec& nodeIndex, V3UI32Vec& nodeLowlink, V3BoolVec& inStack, V3UI32Stack& nodeStack, uint32_t& curIndex) const {$/;"	f	class:V3Graph
subsumes	eng/minisat/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Clause
subsumes	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::subsumes(const V3IPDRCube* const cube) const {$/;"	f	class:V3IPDRFrame
subsumes	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::subsumes(const V3MPDRCube* const cube) const {$/;"	f	class:V3MPDRFrame
svrInfoON	vrf/v3VrfBase.h	/^      static inline const bool svrInfoON() { return reportON() &&  (8ul  & _extVerbosity); }$/;"	f	class:V3VrfBase
swapBddNodeV	bdd/bddMgrV.cpp	/^static void swapBddNodeV(BddNodeV& f, BddNodeV& g)$/;"	f	file:
sz	eng/minisat/Alloc.h	/^    uint32_t  sz;$/;"	m	class:RegionAllocator
sz	eng/minisat/Vec.h	/^    Size sz;$/;"	m	class:vec
table	eng/minisat/Map.h	/^    vec<Pair>* table;$/;"	m	class:Map
toDimacs	eng/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Solver
toDimacs	eng/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Solver
toDimacs	eng/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Solver
toDimacs	eng/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Solver
toExp	adt/v3BitVec.cpp	/^V3BitVec::toExp() const {$/;"	f	class:V3BitVec
toExp	adt/v3BitVec.cpp	/^V3BitVecX::toExp() const {$/;"	f	class:V3BitVecX
toInt	eng/minisat/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f
toInt	eng/minisat/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f
toInt	eng/minisat/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f
toLbool	eng/minisat/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f
toLit	eng/minisat/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f
toString	bdd/bddNodeV.cpp	/^BddNodeV::toString() const$/;"	f	class:BddNodeV
toStringRecur	bdd/bddNodeV.cpp	/^BddNodeV::toStringRecur(bool phase, string& str) const$/;"	f	class:BddNodeV
toVec	eng/minisat/IntMap.h	/^                 toVec       ()          const  { return xs; }$/;"	f	class:IntSet
topologicalSort	adt/v3Graph.h	/^V3Graph<T>::topologicalSort(V3NodeFlow& orderList) const {$/;"	f	class:V3Graph
topologicalSortIndex	adt/v3Graph.h	/^V3Graph<T>::topologicalSortIndex(V3IndexFlow& orderList) const {$/;"	f	class:V3Graph
tot_literals	eng/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Solver
totalSolves	svr/v3SvrBase.h	/^      inline const uint32_t totalSolves() const { return _solves; }$/;"	f	class:V3SvrBase
totalTime	svr/v3SvrBase.h	/^      inline const double totalTime() const { return _runTime; }$/;"	f	class:V3SvrBase
trail	eng/minisat/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Solver
trailBegin	eng/minisat/Solver.h	/^inline TrailIterator  Solver::trailBegin  () const { return TrailIterator(&trail[0]); }$/;"	f	class:Solver
trailEnd	eng/minisat/Solver.h	/^inline TrailIterator  Solver::trailEnd    () const { $/;"	f	class:Solver
trail_lim	eng/minisat/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Solver
type	ntk/v3Type.h	/^   uint32_t    type : 6;$/;"	m	struct:V3MiscType
type_name	eng/minisat/Options.h	/^    const char* type_name;$/;"	m	class:Option
uniquify	bdd/bddMgrV.cpp	/^BddMgrV::uniquify(size_t l, size_t r, unsigned i)$/;"	f	class:BddMgrV
unlock	vrf/v3VrfShared.h	/^      inline void unlock() { pthread_mutex_unlock(&_mutex); }$/;"	f	class:V3VrfShared
unsetVisited	bdd/bddNodeV.h	/^   void unsetVisited() { _visited = 0; }$/;"	f	class:BddNodeVInt
unsetVisited	bdd/test/bddNodeV.h	/^   void unsetVisited() { _visited = 0; }$/;"	f	class:BddNodeVInt
unsetVisitedRecur	bdd/bddNodeV.cpp	/^BddNodeV::unsetVisitedRecur() const$/;"	f	class:BddNodeV
update	eng/minisat/Heap.h	/^    void update(K k)$/;"	f	class:Heap
update	svr/v3SvrBase.cpp	/^V3SvrBase::update() {$/;"	f	class:V3SvrBase
update	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::update() {$/;"	f	class:V3SvrBoolector
update	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::update() {$/;"	f	class:V3SvrMiniSat
updateBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::updateBound(const uint32_t& p, const uint32_t& bound) {$/;"	f	class:V3VrfSharedBound
updateDepMuxSet	stg/v3StgFSM.cpp	/^V3FSMSDGDB::updateDepMuxSet(V3UI32Set& depMuxSet) {$/;"	f	class:V3FSMSDGDB
updateECPair	vrf/v3VrfSEC.cpp	/^V3VrfSEC::updateECPair(const bool& initValid, const bool& update) {$/;"	f	class:V3VrfSEC
updateEQList	vrf/v3VrfSEC.cpp	/^V3VrfSEC::updateEQList(const uint32_t& x, V3RepIdHash& repIdHash) {$/;"	f	class:V3VrfSEC
updateExtractedFSM	stg/v3StgFSM.cpp	/^V3FSM::updateExtractedFSM(const V3NetVec& terminal) {$/;"	f	class:V3FSM
updateInput	ntk/v3Ntk.h	/^      inline void updateInput(const uint32_t& i, const V3NetId& id) { assert (i < _inputs.size()); _inputs[i] = id; }$/;"	f	class:V3NtkModule
updateInv	vrf/v3VrfShared.h	/^      inline void updateInv(const V3NetTable& i) { lock(); _inv = i; unlock(); }$/;"	f	class:V3VrfSharedInv
updateInv	vrf/v3VrfShared.h	/^      inline void updateInv(const V3NetVec& i) { lock(); _inv.push_back(i); unlock(); }$/;"	f	class:V3VrfSharedInv
updateMaxMemory	vrf/v3VrfShared.h	/^      inline void updateMaxMemory(const double& m) { lock(); _maxMemory = m; unlock(); }$/;"	f	class:V3VrfSharedMem
updateModule	ntk/v3NtkConstruct.cpp	/^const bool updateModule(V3Ntk* const ntk, V3NtkModule* const module, $/;"	f
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::updateNextStateEvent() {$/;"	f	class:V3AlgAigSimulate
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::updateNextStateEvent() {$/;"	f	class:V3AlgBvSimulate
updateNextStateEvent	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::updateNextStateEvent() {}$/;"	f	class:V3AlgSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::updateNextStateValue() {$/;"	f	class:V3AlgAigSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::updateNextStateValue() {$/;"	f	class:V3AlgBvSimulate
updateNextStateValue	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::updateNextStateValue() {}$/;"	f	class:V3AlgSimulate
updateNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::updateNtk(V3Ntk* const ntk, const V3NetTable& constr) {$/;"	f	class:V3VrfSharedNtk
updateNtkRef	ntk/v3Ntk.h	/^      inline void updateNtkRef(const V3NtkHandler* const h, const bool& b = false) {$/;"	f	class:V3NtkModule
updateOutput	ntk/v3Ntk.h	/^      inline void updateOutput(const uint32_t& i, const V3NetId& id) { assert (i < _outputs.size()); _outputs[i] = id; }$/;"	f	class:V3NtkModule
updateOutput	vrf/v3VrfKLive.cpp	/^V3VrfKLive::updateOutput(const uint32_t& p) {$/;"	f	class:V3VrfKLive
updateRemaining	v3mc/v3MCMain.cpp	/^V3MCResource::updateRemaining(const V3MCMainType& t, const uint32_t& rem) {$/;"	f	class:V3MCResource
updateResult	v3mc/v3MCMain.cpp	/^V3MCResult::updateResult(const uint32_t& p, const V3VrfResult& result) {$/;"	f	class:V3MCResult
updateVarOrder	alg/v3AlgGeneralize.cpp	/^V3GenStruct::updateVarOrder(const bool& succeed) {$/;"	f	class:V3GenStruct
usage	alg/v3AlgCmd.cpp	/^V3PlotTraceCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotTraceCmd
usage	alg/v3AlgCmd.cpp	/^V3SimNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3SimNtkCmd
usage	bdd/bddCmd.cpp	/^BAndCmd::usage(const bool& verbose) const$/;"	f	class:BAndCmd
usage	bdd/bddCmd.cpp	/^BCofactorCmd::usage(const bool& verbose) const$/;"	f	class:BCofactorCmd
usage	bdd/bddCmd.cpp	/^BCompareCmd::usage(const bool& verbose) const$/;"	f	class:BCompareCmd
usage	bdd/bddCmd.cpp	/^BConstructCmd::usage(const bool& verbose) const$/;"	f	class:BConstructCmd
usage	bdd/bddCmd.cpp	/^BDrawCmd::usage(const bool& verbose) const$/;"	f	class:BDrawCmd
usage	bdd/bddCmd.cpp	/^BExistCmd::usage(const bool& verbose) const$/;"	f	class:BExistCmd
usage	bdd/bddCmd.cpp	/^BInvCmd::usage(const bool& verbose) const$/;"	f	class:BInvCmd
usage	bdd/bddCmd.cpp	/^BNandCmd::usage(const bool& verbose) const$/;"	f	class:BNandCmd
usage	bdd/bddCmd.cpp	/^BNorCmd::usage(const bool& verbose) const$/;"	f	class:BNorCmd
usage	bdd/bddCmd.cpp	/^BOrCmd::usage(const bool& verbose) const$/;"	f	class:BOrCmd
usage	bdd/bddCmd.cpp	/^BReportCmd::usage(const bool& verbose) const$/;"	f	class:BReportCmd
usage	bdd/bddCmd.cpp	/^BResetCmd::usage(const bool& verbose) const$/;"	f	class:BResetCmd
usage	bdd/bddCmd.cpp	/^BSetOrderCmd::usage(const bool& verbose) const$/;"	f	class:BSetOrderCmd
usage	bdd/bddCmd.cpp	/^BSetVarCmd::usage(const bool& verbose) const$/;"	f	class:BSetVarCmd
usage	bdd/bddCmd.cpp	/^BSimulateCmd::usage(const bool& verbose) const$/;"	f	class:BSimulateCmd
usage	bdd/bddCmd.cpp	/^BXnorCmd::usage(const bool& verbose) const$/;"	f	class:BXnorCmd
usage	bdd/bddCmd.cpp	/^BXorCmd::usage(const bool& verbose) const$/;"	f	class:BXorCmd
usage	cmd/v3CmdComm.cpp	/^V3DofileCmd::usage(const bool& verbose) const {  $/;"	f	class:V3DofileCmd
usage	cmd/v3CmdComm.cpp	/^V3HelpCmd::usage(const bool& verbose) const {$/;"	f	class:V3HelpCmd
usage	cmd/v3CmdComm.cpp	/^V3HistoryCmd::usage(const bool& verbose) const {$/;"	f	class:V3HistoryCmd
usage	cmd/v3CmdComm.cpp	/^V3LogFileCmd::usage(const bool& verbose) const {$/;"	f	class:V3LogFileCmd
usage	cmd/v3CmdComm.cpp	/^V3QuitCmd::usage(const bool& verbose) const {$/;"	f	class:V3QuitCmd
usage	cmd/v3CmdComm.cpp	/^V3UsageCmd::usage(const bool& verbose) const {$/;"	f	class:V3UsageCmd
usage	dfx/v3DfxCmd.cpp	/^V3OptTraceCmd::usage(const bool& verbose) const {$/;"	f	class:V3OptTraceCmd
usage	dfx/v3DfxCmd.cpp	/^V3TraceSimplifyCmd::usage(const bool& verbose) const {$/;"	f	class:V3TraceSimplifyCmd
usage	main/main.cpp	/^static void usage() {$/;"	f	file:
usage	ntk/v3NtkCmd.cpp	/^V3DuplicateNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3DuplicateNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3ListNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ListNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3NetInfoCmd::usage(const bool& verbose) const$/;"	f	class:V3NetInfoCmd
usage	ntk/v3NtkCmd.cpp	/^V3PlotNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintNetCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintNetCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3PrintVerbosityCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintVerbosityCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadAIGCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadAIGCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadBTORCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadBTORCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReadRTLCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReadRTLCmd
usage	ntk/v3NtkCmd.cpp	/^V3ReduceNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ReduceNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3RefNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3RefNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3RewriteNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3RewriteNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3SetNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3SetVerbosityCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetVerbosityCmd
usage	ntk/v3NtkCmd.cpp	/^V3StrashNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3StrashNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3WorkNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3WorkNtkCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteAIGCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteAIGCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteBTORCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteBTORCmd
usage	ntk/v3NtkCmd.cpp	/^V3WriteRTLCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteRTLCmd
usage	prove/proveCmd.cpp	/^PCheckPropertyCmd::usage(const bool& verbose) const$/;"	f	class:PCheckPropertyCmd
usage	prove/proveCmd.cpp	/^PImageCmd::usage(const bool& verbose) const$/;"	f	class:PImageCmd
usage	prove/proveCmd.cpp	/^PInitialStateCmd::usage(const bool& verbose) const$/;"	f	class:PInitialStateCmd
usage	prove/proveCmd.cpp	/^PTransRelationCmd::usage(const bool& verbose) const$/;"	f	class:PTransRelationCmd
usage	stg/v3StgCmd.cpp	/^V3ElaborateFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3ElaborateFSMCmd
usage	stg/v3StgCmd.cpp	/^V3ExtractFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3ExtractFSMCmd
usage	stg/v3StgCmd.cpp	/^V3PlotFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotFSMCmd
usage	stg/v3StgCmd.cpp	/^V3WriteFSMCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteFSMCmd
usage	trans/v3TransCmd.cpp	/^V3BlastNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3BlastNtkCmd
usage	trans/v3TransCmd.cpp	/^V3ExpandNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3ExpandNtkCmd
usage	trans/v3TransCmd.cpp	/^V3FlattenNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3FlattenNtkCmd
usage	trans/v3TransCmd.cpp	/^V3MiterNtkCmd::usage(const bool& verbose) const {$/;"	f	class:V3MiterNtkCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCReadPropertyCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCReadPropertyCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCRunCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCRunCmd
usage	v3mc/v3MCCmd.cpp	/^V3MCWritePropertyCmd::usage(const bool& verbose) const {$/;"	f	class:V3MCWritePropertyCmd
usage	vrf/v3VrfCmd.cpp	/^V3BMCVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3BMCVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3CheckResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3CheckResultCmd
usage	vrf/v3VrfCmd.cpp	/^V3ElaboratePrptyCmd::usage(const bool& verbose) const {$/;"	f	class:V3ElaboratePrptyCmd
usage	vrf/v3VrfCmd.cpp	/^V3ITPVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3ITPVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3KLiveVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3KLiveVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3PDRVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3PDRVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3PlotResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3PlotResultCmd
usage	vrf/v3VrfCmd.cpp	/^V3PrintReportCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintReportCmd
usage	vrf/v3VrfCmd.cpp	/^V3PrintSolverCmd::usage(const bool& verbose) const {$/;"	f	class:V3PrintSolverCmd
usage	vrf/v3VrfCmd.cpp	/^V3SECVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3SECVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3SIMVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3SIMVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetLivenessCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetLivenessCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetReportCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetReportCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetSafetyCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetSafetyCmd
usage	vrf/v3VrfCmd.cpp	/^V3SetSolverCmd::usage(const bool& verbose) const {$/;"	f	class:V3SetSolverCmd
usage	vrf/v3VrfCmd.cpp	/^V3UMCVrfCmd::usage(const bool& verbose) const {$/;"	f	class:V3UMCVrfCmd
usage	vrf/v3VrfCmd.cpp	/^V3WriteResultCmd::usage(const bool& verbose) const {$/;"	f	class:V3WriteResultCmd
usageON	vrf/v3VrfBase.h	/^      static inline const bool usageON()   { return reportON() &&  (16ul & _extVerbosity); }$/;"	f	class:V3VrfBase
user_pol	eng/minisat/Solver.h	/^    VMap<lbool>         user_pol;         \/\/ The users preferred polarity of each variable.$/;"	m	class:Solver
v3CmdMgr	main/main.cpp	/^V3CmdMgr* v3CmdMgr = new V3CmdMgr("v3");$/;"	v
v3CreateDir	util/v3FileUtil.h	/^static inline bool v3CreateDir(const char* dirName, bool replace = true) {$/;"	f
v3DeleteDir	util/v3FileUtil.h	/^static inline void v3DeleteDir(const char* dirName) {$/;"	f
v3ExistDir	util/v3FileUtil.h	/^static inline bool v3ExistDir(const char* dirName) {$/;"	f
v3GetAbsPath	util/v3FileUtil.h	/^static inline const char* v3GetAbsPath(const char* fileName) {$/;"	f
v3GetExecPath	util/v3FileUtil.h	/^static inline const char* v3GetExecPath() {$/;"	f
v3Handler	main/main.cpp	/^V3Handler v3Handler;$/;"	v
v3Int2Str	bdd/test/v3StrUtil.cpp	/^v3Int2Str(const int& num, const uint32_t& width) {$/;"	f
v3Int2Str	util/v3StrUtil.cpp	/^v3Int2Str(const int& num, const uint32_t& width) {$/;"	f
v3MCInteractive	v3mc/v3MCMain.h	/^static const bool v3MCInteractive = false;$/;"	v
v3MCResultCheck	v3mc/v3MCMain.h	/^static const bool v3MCResultCheck = false;$/;"	v
v3Str2BVExpr	bdd/test/v3StrUtil.cpp	/^v3Str2BVExpr(const string& expr, uint32_t& start, uint32_t& end) {$/;"	f
v3Str2BVExpr	util/v3StrUtil.cpp	/^v3Str2BVExpr(const string& expr, uint32_t& start, uint32_t& end) {$/;"	f
v3Str2Int	bdd/test/v3StrUtil.cpp	/^v3Str2Int(const string& str, int& num) {$/;"	f
v3Str2Int	util/v3StrUtil.cpp	/^v3Str2Int(const string& str, int& num) {$/;"	f
v3Str2UInt	bdd/test/v3StrUtil.cpp	/^v3Str2UInt(const string& str, uint32_t& num) {$/;"	f
v3Str2UInt	util/v3StrUtil.cpp	/^v3Str2UInt(const string& str, uint32_t& num) {$/;"	f
v3StrGetTok	bdd/test/v3StrUtil.cpp	/^v3StrGetTok(const string& str, string& tok, const size_t& pos, const char del) {$/;"	f
v3StrGetTok	util/v3StrUtil.cpp	/^v3StrGetTok(const string& str, string& tok, const size_t& pos, const char del) {$/;"	f
v3StrNCmp	bdd/test/v3StrUtil.cpp	/^v3StrNCmp(const string& s1, const string& s2, const uint32_t& n) {$/;"	f
v3StrNCmp	util/v3StrUtil.cpp	/^v3StrNCmp(const string& s1, const string& s2, const uint32_t& n) {$/;"	f
v3StrRemoveSpaces	bdd/test/v3StrUtil.cpp	/^v3StrRemoveSpaces(const string str) {$/;"	f
v3StrRemoveSpaces	util/v3StrUtil.cpp	/^v3StrRemoveSpaces(const string str) {$/;"	f
v3Usage	main/main.cpp	/^V3Usage v3Usage;$/;"	v
valid	bdd/bddCmd.cpp	/^static bool valid()$/;"	f	file:
valid	prove/proveCmd.cpp	/^static bool valid()$/;"	f	file:
validNetId	ntk/v3Ntk.h	/^      inline const bool validNetId(const V3NetId& id) const { return (id.id) < getNetSize(); }$/;"	f	class:V3Ntk
validNetId	svr/v3SvrBase.h	/^      inline const bool validNetId(const V3NetId& id) const { return _ntk->getNetSize() > id.id; }$/;"	f	class:V3SvrBase
value	adt/v3BitVec.cpp	/^V3BitVec::value() const {$/;"	f	class:V3BitVec
value	adt/v3BitVec.cpp	/^V3BitVecX::value() const {$/;"	f	class:V3BitVecX
value	eng/minisat/Options.h	/^    bool value;$/;"	m	class:BoolOption
value	eng/minisat/Options.h	/^    const char* value;$/;"	m	class:StringOption
value	eng/minisat/Options.h	/^    double      value;$/;"	m	class:DoubleOption
value	eng/minisat/Options.h	/^    int32_t  value;$/;"	m	class:IntOption
value	eng/minisat/Options.h	/^    int64_t  value;$/;"	m	class:Int64Option
value	eng/minisat/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Solver
value	eng/minisat/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Solver
value	eng/minisat/SolverTypes.h	/^    uint8_t value;$/;"	m	class:lbool
value	ntk/v3Type.h	/^   uint32_t    value;$/;"	m	union:V3NetType
var	eng/minisat/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f
varBumpActivity	eng/minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Solver
varBumpActivity	eng/minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Solver
varDecayActivity	eng/minisat/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Solver
var_Undef	eng/minisat/SolverTypes.h	/^  const Var var_Undef = -1;$/;"	v
var_Undef	eng/minisat/SolverTypes.h	45;"	d
var_decay	eng/minisat/Solver.h	/^    double    var_decay;$/;"	m	class:Solver
var_inc	eng/minisat/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Solver
vardata	eng/minisat/Solver.h	/^    VMap<VarData>       vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Solver
vec	eng/minisat/Vec.h	/^    explicit vec(Size size)      : data(NULL), sz(0), cap(0)    { growTo(size); }$/;"	f	class:vec
vec	eng/minisat/Vec.h	/^    vec()                        : data(NULL), sz(0), cap(0)    { }$/;"	f	class:vec
vec	eng/minisat/Vec.h	/^    vec(Size size, const T& pad) : data(NULL), sz(0), cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	eng/minisat/Vec.h	/^class vec {$/;"	c
verbosity	eng/minisat/Solver.h	/^    int       verbosity;$/;"	m	class:Solver
verifyInOrder	vrf/v3VrfBase.cpp	/^V3VrfBase::verifyInOrder() {$/;"	f	class:V3VrfBase
verifyProperty	vrf/v3VrfBase.cpp	/^V3VrfBase::verifyProperty(const uint32_t& p) {$/;"	f	class:V3VrfBase
wasted	eng/minisat/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:RegionAllocator
wasted	eng/minisat/SolverTypes.h	/^    uint32_t wasted    () const      { return ra.wasted(); }$/;"	f	class:ClauseAllocator
wasted_	eng/minisat/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:RegionAllocator
watches	eng/minisat/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Solver
withinBudget	eng/minisat/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Solver
words	adt/v3BitVec.cpp	/^unsigned words(const unsigned s) { return (s >> 3) + ((MOD_WORD & s) ? 1 : 0); }$/;"	f
write	bdd/myHash.h	/^   void write(const CacheKey& k, const CacheData& d) {$/;"	f	class:Cache
write	bdd/test/myHash.h	/^   void write(const CacheKey& k, const CacheData& d) {$/;"	f	class:Cache
writeAiger	v3mc/v3MCAiger.cpp	/^void writeAiger(V3NtkHandler* const handler, const string& fileName, const bool& l2s, const bool& invc2Prop) {$/;"	f
writeClusterResult	stg/v3StgExtract.cpp	/^V3FSMExtract::writeClusterResult(const string& fileName) const {$/;"	f	class:V3FSMExtract
writeFSM	stg/v3StgExtract.cpp	/^V3FSMExtract::writeFSM(const string& fileName, V3FSM* const fsm) const {$/;"	f	class:V3FSMExtract
writeFSM	stg/v3StgFSM.cpp	/^V3FSM::writeFSM(const string& fileName) const {$/;"	f	class:V3FSM
writeProperty	v3mc/v3MCProp.cpp	/^void writeProperty(V3NtkHandler* const handler, const string& fileName, const bool& l2s, const bool& invc2Prop) {$/;"	f
writeV3GeneralHeader	io/v3NtkWriter.cpp	/^void writeV3GeneralHeader(const string& formatType, ofstream& output, const string& commentStart) {$/;"	f
x	eng/minisat/SolverTypes.h	/^    int     x;$/;"	m	struct:Lit
xnor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xnor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
xnor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xnor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
xor_2	svr/v3SvrSatHelper.h	/^inline void xor_2(Solver* SS, const Lit& y, const Lit& a, const Lit& b)$/;"	f
xor_2	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_2(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b)$/;"	f
xor_3	svr/v3SvrSatHelper.h	/^inline void xor_3(Solver* SS, const Lit& y, const Lit& a, const Lit& b, const Lit& c)$/;"	f
xor_3	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_3(V3Ntk* const ntk, const V3NetId& a, const V3NetId& b, const V3NetId& c)$/;"	f
xor_red	svr/v3SvrSatHelper.h	/^inline void xor_red(Solver* SS, const Lit& y, const Lit& a, const uint32_t& Width)$/;"	f
xor_red	trans/v3BvBlastAigHelper.h	/^inline const V3NetId xor_red(V3Ntk* const ntk, const V3NetVec& a)$/;"	f
xrealloc	eng/minisat/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f
xs	eng/minisat/IntMap.h	/^        vec<K>                   xs;$/;"	m	class:IntSet
~BddMgrV	bdd/bddMgrV.h	/^   ~BddMgrV() { reset(); }$/;"	f	class:BddMgrV
~BddMgrV	bdd/test/bddMgrV.h	/^   ~BddMgrV() { reset(); }$/;"	f	class:BddMgrV
~BddNodeV	bdd/bddNodeV.cpp	/^BddNodeV::~BddNodeV()$/;"	f	class:BddNodeV
~Cache	bdd/myHash.h	/^   ~Cache() { reset(); }$/;"	f	class:Cache
~Cache	bdd/test/myHash.h	/^   ~Cache() { reset(); }$/;"	f	class:Cache
~Hash	bdd/myHash.h	/^   ~Hash() { reset(); }$/;"	f	class:Hash
~Hash	bdd/test/myHash.h	/^   ~Hash() { reset(); }$/;"	f	class:Hash
~Map	eng/minisat/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Map
~Option	eng/minisat/Options.h	/^    virtual ~Option() {}$/;"	f	class:Option
~RegionAllocator	eng/minisat/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:RegionAllocator
~StreamBuffer	eng/minisat/ParseUtils.h	/^    ~StreamBuffer() { free(buf); }$/;"	f	class:StreamBuffer
~V3AlgAigGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgAigGeneralize::~V3AlgAigGeneralize() {$/;"	f	class:V3AlgAigGeneralize
~V3AlgAigSimulate	alg/v3AlgSimulate.cpp	/^V3AlgAigSimulate::~V3AlgAigSimulate() {$/;"	f	class:V3AlgAigSimulate
~V3AlgBvGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgBvGeneralize::~V3AlgBvGeneralize() {$/;"	f	class:V3AlgBvGeneralize
~V3AlgBvSimulate	alg/v3AlgSimulate.cpp	/^V3AlgBvSimulate::~V3AlgBvSimulate() {$/;"	f	class:V3AlgBvSimulate
~V3AlgGeneralize	alg/v3AlgGeneralize.cpp	/^V3AlgGeneralize::~V3AlgGeneralize() {$/;"	f	class:V3AlgGeneralize
~V3AlgSimulate	alg/v3AlgSimulate.cpp	/^V3AlgSimulate::~V3AlgSimulate() {$/;"	f	class:V3AlgSimulate
~V3BitVec	adt/v3BitVec.cpp	/^V3BitVec::~V3BitVec() {$/;"	f	class:V3BitVec
~V3BitVecS	adt/v3BitVec.cpp	/^V3BitVecS::~V3BitVecS() {}$/;"	f	class:V3BitVecS
~V3BitVecX	adt/v3BitVec.cpp	/^V3BitVecX::~V3BitVecX() {$/;"	f	class:V3BitVecX
~V3BucketList	adt/v3Bucket.h	/^V3BucketList<T>::~V3BucketList() {$/;"	f	class:V3BucketList
~V3BvBlastAig	trans/v3BvBlastAig.cpp	/^V3BvBlastAig::~V3BvBlastAig() {$/;"	f	class:V3BvBlastAig
~V3BvBlastBv	trans/v3BvBlastBv.cpp	/^V3BvBlastBv::~V3BvBlastBv() {$/;"	f	class:V3BvBlastBv
~V3BvNtk	ntk/v3Ntk.cpp	/^V3BvNtk::~V3BvNtk() {$/;"	f	class:V3BvNtk
~V3CITPCube	vrf/v3VrfCITP.h	/^      ~V3CITPCube() { _stateId.clear(); }$/;"	f	class:V3CITPCube
~V3CITPFrame	vrf/v3VrfCITP.cpp	/^V3CITPFrame::~V3CITPFrame() {$/;"	f	class:V3CITPFrame
~V3CexTrace	ext/v3Property.h	/^      ~V3CexTrace() { if (_init) delete _init; _data.clear(); }$/;"	f	class:V3CexTrace
~V3CmdExec	cmd/v3CmdMgr.h	/^      virtual ~V3CmdExec() {}$/;"	f	class:V3CmdExec
~V3CmdMgr	cmd/v3CmdMgr.cpp	/^V3CmdMgr::~V3CmdMgr() {$/;"	f	class:V3CmdMgr
~V3Constraint	ext/v3Property.cpp	/^V3Constraint::~V3Constraint() {$/;"	f	class:V3Constraint
~V3DfxCube	dfx/v3DfxTrace.h	/^      ~V3DfxCube() { _stateId.clear(); }$/;"	f	class:V3DfxCube
~V3FITPCube	vrf/v3VrfFITP.h	/^      ~V3FITPCube() { _stateId.clear(); }$/;"	f	class:V3FITPCube
~V3FITPFrame	vrf/v3VrfFITP.cpp	/^V3FITPFrame::~V3FITPFrame() {$/;"	f	class:V3FITPFrame
~V3FSM	stg/v3StgFSM.cpp	/^V3FSM::~V3FSM() {$/;"	f	class:V3FSM
~V3FSMExtract	stg/v3StgExtract.cpp	/^V3FSMExtract::~V3FSMExtract() {$/;"	f	class:V3FSMExtract
~V3FSMSDG	stg/v3StgFSM.cpp	/^V3FSMSDG::~V3FSMSDG() {$/;"	f	class:V3FSMSDG
~V3FSMSDGDB	stg/v3StgFSM.cpp	/^V3FSMSDGDB::~V3FSMSDGDB() {$/;"	f	class:V3FSMSDGDB
~V3Formula	ext/v3Formula.cpp	/^V3Formula::~V3Formula() {$/;"	f	class:V3Formula
~V3GenBucket	alg/v3AlgGeneralize.cpp	/^V3GenBucket::~V3GenBucket() {$/;"	f	class:V3GenBucket
~V3GenStruct	alg/v3AlgGeneralize.cpp	/^V3GenStruct::~V3GenStruct() {$/;"	f	class:V3GenStruct
~V3Graph	adt/v3Graph.h	/^V3Graph<T>::~V3Graph() { clearGraph(); }$/;"	f	class:V3Graph
~V3Handler	ntk/v3NtkHandler.cpp	/^V3Handler::~V3Handler() {$/;"	f	class:V3Handler
~V3IPDRCube	vrf/v3VrfIPDR.h	/^      ~V3IPDRCube() { _stateId.clear(); }$/;"	f	class:V3IPDRCube
~V3IPDRFrame	vrf/v3VrfIPDR.cpp	/^V3IPDRFrame::~V3IPDRFrame() {$/;"	f	class:V3IPDRFrame
~V3IncBucketList	adt/v3Bucket.h	/^V3IncBucketList<T>::~V3IncBucketList() {$/;"	f	class:V3IncBucketList
~V3LTLFormula	ext/v3LTLFormula.cpp	/^V3LTLFormula::~V3LTLFormula() {$/;"	f	class:V3LTLFormula
~V3MCResource	v3mc/v3MCMain.cpp	/^V3MCResource::~V3MCResource() {$/;"	f	class:V3MCResource
~V3MCResult	v3mc/v3MCMain.cpp	/^V3MCResult::~V3MCResult() {$/;"	f	class:V3MCResult
~V3MPDRCube	vrf/v3VrfMPDR.h	/^      ~V3MPDRCube() { _stateId.clear(); }$/;"	f	class:V3MPDRCube
~V3MPDRFrame	vrf/v3VrfMPDR.cpp	/^V3MPDRFrame::~V3MPDRFrame() {$/;"	f	class:V3MPDRFrame
~V3Msg	util/v3Msg.h	/^      ~V3Msg() {}$/;"	f	class:V3Msg
~V3MsgMgr	util/v3Msg.h	/^      ~V3MsgMgr() { Msgs.clear(); }$/;"	f	class:V3MsgMgr
~V3Ntk	ntk/v3Ntk.cpp	/^V3Ntk::~V3Ntk() {$/;"	f	class:V3Ntk
~V3NtkElaborate	ext/v3NtkElaborate.cpp	/^V3NtkElaborate::~V3NtkElaborate() {$/;"	f	class:V3NtkElaborate
~V3NtkExpand	trans/v3NtkExpand.cpp	/^V3NtkExpand::~V3NtkExpand() {$/;"	f	class:V3NtkExpand
~V3NtkFlatten	trans/v3NtkFlatten.cpp	/^V3NtkFlatten::~V3NtkFlatten() {$/;"	f	class:V3NtkFlatten
~V3NtkHandler	ntk/v3NtkHandler.cpp	/^V3NtkHandler::~V3NtkHandler() {$/;"	f	class:V3NtkHandler
~V3NtkHierData	ntk/v3NtkHandler.h	/^            ~V3NtkHierData() { _p2cMap.clear(); }$/;"	f	class:V3NtkHierInfo::V3NtkHierData
~V3NtkHierInfo	ntk/v3NtkHandler.h	/^      ~V3NtkHierInfo() { clear(); }$/;"	f	class:V3NtkHierInfo
~V3NtkInput	ntk/v3NtkInput.cpp	/^V3NtkInput::~V3NtkInput() {$/;"	f	class:V3NtkInput
~V3NtkMiter	trans/v3NtkMiter.cpp	/^V3NtkMiter::~V3NtkMiter() {$/;"	f	class:V3NtkMiter
~V3NtkSimplify	ntk/v3NtkSimplify.cpp	/^V3NtkSimplify::~V3NtkSimplify() {$/;"	f	class:V3NtkSimplify
~V3PortableType	adt/v3Misc.h	/^      ~V3PortableType() { _list.clear(); _index.clear(); }$/;"	f	class:V3PortableType
~V3Property	ext/v3Property.cpp	/^V3Property::~V3Property() {$/;"	f	class:V3Property
~V3SDG	stg/v3StgSDG.cpp	/^V3SDG::~V3SDG() {$/;"	f	class:V3SDG
~V3SDGBase	stg/v3StgSDG.cpp	/^V3SDGBase::~V3SDGBase() {$/;"	f	class:V3SDGBase
~V3SDGMUX	stg/v3StgSDG.cpp	/^V3SDGMUX::~V3SDGMUX() {$/;"	f	class:V3SDGMUX
~V3SDGNode	stg/v3StgSDG.cpp	/^V3SDGNode::~V3SDGNode() {$/;"	f	class:V3SDGNode
~V3Stat	util/v3Usage.h	/^      ~V3Stat() {}$/;"	f	class:V3Stat
~V3SvrBase	svr/v3SvrBase.cpp	/^V3SvrBase::~V3SvrBase() {$/;"	f	class:V3SvrBase
~V3SvrBoolector	svr/v3SvrBoolector.cpp	/^V3SvrBoolector::~V3SvrBoolector() {$/;"	f	class:V3SvrBoolector
~V3SvrMiniSat	svr/v3SvrMiniSat.cpp	/^V3SvrMiniSat::~V3SvrMiniSat() {$/;"	f	class:V3SvrMiniSat
~V3TraceSimplify	dfx/v3DfxSimplify.cpp	/^V3TraceSimplify::~V3TraceSimplify() {$/;"	f	class:V3TraceSimplify
~V3VrfBMC	vrf/v3VrfBMC.cpp	/^V3VrfBMC::~V3VrfBMC() {$/;"	f	class:V3VrfBMC
~V3VrfBase	vrf/v3VrfBase.cpp	/^V3VrfBase::~V3VrfBase() {$/;"	f	class:V3VrfBase
~V3VrfCITP	vrf/v3VrfCITP.cpp	/^V3VrfCITP::~V3VrfCITP() {$/;"	f	class:V3VrfCITP
~V3VrfFITP	vrf/v3VrfFITP.cpp	/^V3VrfFITP::~V3VrfFITP() {$/;"	f	class:V3VrfFITP
~V3VrfIPDR	vrf/v3VrfIPDR.cpp	/^V3VrfIPDR::~V3VrfIPDR() {$/;"	f	class:V3VrfIPDR
~V3VrfKLive	vrf/v3VrfKLive.cpp	/^V3VrfKLive::~V3VrfKLive() {$/;"	f	class:V3VrfKLive
~V3VrfMPDR	vrf/v3VrfMPDR.cpp	/^V3VrfMPDR::~V3VrfMPDR() {$/;"	f	class:V3VrfMPDR
~V3VrfResult	ext/v3Property.h	/^      ~V3VrfResult() { \/* Memory Will NOT be Released !! Call clear() Explicitly !! *\/ _cexOrInv = 0; }$/;"	f	class:V3VrfResult
~V3VrfSEC	vrf/v3VrfSEC.cpp	/^V3VrfSEC::~V3VrfSEC() {$/;"	f	class:V3VrfSEC
~V3VrfSIM	vrf/v3VrfSIM.cpp	/^V3VrfSIM::~V3VrfSIM() {$/;"	f	class:V3VrfSIM
~V3VrfShared	vrf/v3VrfShared.h	/^      virtual ~V3VrfShared() {}$/;"	f	class:V3VrfShared
~V3VrfSharedBound	vrf/v3VrfShared.cpp	/^V3VrfSharedBound::~V3VrfSharedBound() {$/;"	f	class:V3VrfSharedBound
~V3VrfSharedInv	vrf/v3VrfShared.cpp	/^V3VrfSharedInv::~V3VrfSharedInv() {$/;"	f	class:V3VrfSharedInv
~V3VrfSharedMem	vrf/v3VrfShared.h	/^      ~V3VrfSharedMem() {}$/;"	f	class:V3VrfSharedMem
~V3VrfSharedNtk	vrf/v3VrfShared.cpp	/^V3VrfSharedNtk::~V3VrfSharedNtk() {$/;"	f	class:V3VrfSharedNtk
~V3VrfUMC	vrf/v3VrfUMC.cpp	/^V3VrfUMC::~V3VrfUMC() {$/;"	f	class:V3VrfUMC
~iterator	bdd/myHash.h	/^      ~iterator() {} \/\/ Should NOT delete HashData$/;"	f	class:Hash::iterator
~iterator	bdd/test/myHash.h	/^      ~iterator() {} \/\/ Should NOT delete HashData$/;"	f	class:Hash::iterator
~vec	eng/minisat/Vec.h	/^   ~vec()                                                       { clear(true); }$/;"	f	class:vec
